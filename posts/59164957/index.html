<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-wall.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-wall.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">
  <meta name="baidu-site-verification" content="code-jsxllPgZAX">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="https://fonts.loli.net/css?family=Noto Serif SC:300,300italic,400,400italic,700,700italic|Ma Shan Zheng:300,300italic,400,400italic,700,700italic|JetBrains Mono:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">
<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">
  <link rel="stylesheet" href="/lib/pace/pace-theme-minimal.min.css">
  <script src="/lib/pace/pace.min.js"></script>

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"thysrael.github.io","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":false,"style":"flat"},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="一、设计想法1.1 我的CPU的整体架构 1.2 从单周期到流水线虽然学长一直在强调重构，身边大佬也都对重构乐此不疲。但是以我个人的感觉，感觉不太需要重构（这可能就是我TLE了两天的错误观念）。我个人感觉完全可以在单周期上面改。为了给大家一个直观印象，我从修改原单周期CPU，流水线寄存器，加入阻塞刷新功能，加入转发功能方面分别说一下怎么改（严格说是怎么加，需要改的地方好像没有）：">
<meta property="og:type" content="article">
<meta property="og:title" content="计算机组成-简单流水线">
<meta property="og:url" content="https://thysrael.github.io/posts/59164957/index.html">
<meta property="og:site_name" content="钟鼓楼">
<meta property="og:description" content="一、设计想法1.1 我的CPU的整体架构 1.2 从单周期到流水线虽然学长一直在强调重构，身边大佬也都对重构乐此不疲。但是以我个人的感觉，感觉不太需要重构（这可能就是我TLE了两天的错误观念）。我个人感觉完全可以在单周期上面改。为了给大家一个直观印象，我从修改原单周期CPU，流水线寄存器，加入阻塞刷新功能，加入转发功能方面分别说一下怎么改（严格说是怎么加，需要改的地方好像没有）：">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://thysrael.github.io/posts/59164957/微信图片_20211123100405.jpg">
<meta property="article:published_time" content="2022-01-16T07:59:10.000Z">
<meta property="article:modified_time" content="2025-08-15T12:16:49.067Z">
<meta property="article:author" content="Thysrael">
<meta property="article:tag" content="S3课上">
<meta property="article:tag" content="计算机组成">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://thysrael.github.io/posts/59164957/微信图片_20211123100405.jpg">

<link rel="canonical" href="https://thysrael.github.io/posts/59164957/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'en'
  };
</script>

  <title>计算机组成-简单流水线 | 钟鼓楼</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>


<style>.github-emoji { position: relative; display: inline-block; width: 1.2em; min-height: 1.2em; overflow: hidden; vertical-align: top; color: transparent; }  .github-emoji > span { position: relative; z-index: 10; }  .github-emoji img, .github-emoji .fancybox { margin: 0 !important; padding: 0 !important; border: none !important; outline: none !important; text-decoration: none !important; user-select: none !important; cursor: auto !important; }  .github-emoji img { height: 1.2em !important; width: 1.2em !important; position: absolute !important; left: 50% !important; top: 50% !important; transform: translate(-50%, -50%) !important; user-select: none !important; cursor: auto !important; } .github-emoji-fallback { color: inherit; } .github-emoji-fallback img { opacity: 0 !important; }</style>
<link rel="alternate" href="/atom.xml" title="钟鼓楼" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>
      <a target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/thysrael" class="github-corner" aria-label="View source on GitHub"><svg width="80" height="80" viewBox="0 0 250 250" style="fill:#151513; color:#fff; position: absolute; top: 0; border: 0; right: 0;" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a><style>.github-corner:hover .octo-arm{animation:octocat-wave 560ms ease-in-out}@keyframes octocat-wave{0%,100%{transform:rotate(0)}20%,60%{transform:rotate(-25deg)}40%,80%{transform:rotate(10deg)}}@media (max-width:500px){.github-corner:hover .octo-arm{animation:none}.github-corner .octo-arm{animation:octocat-wave 560ms ease-in-out}}</style>
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">钟鼓楼</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">钟楼瘦，鼓楼胖</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories<span class="badge">31</span></a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags<span class="badge">70</span></a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives<span class="badge">199</span></a>

  </li>
        <li class="menu-item menu-item-resource">

    <a href="/resource/" rel="section"><i class="fa fa-book fa-fw"></i>Resource</a>

  </li>
        <li class="menu-item menu-item-links">

    <a href="/links/" rel="section"><i class="fa fa-link fa-fw"></i>Links</a>

  </li>
        <li class="menu-item menu-item-roam">

    <a href="/obsidian-quartz/" rel="section"><i class="fa fa-sitemap fa-fw"></i>Roam</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>About</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>Search
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="Searching..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://thysrael.github.io/posts/59164957/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar2.png">
      <meta itemprop="name" content="Thysrael">
      <meta itemprop="description" content="Can you hear me ?">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="钟鼓楼">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          计算机组成-简单流水线
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-01-16 15:59:10" itemprop="dateCreated datePublished" datetime="2022-01-16T15:59:10+08:00">2022-01-16</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-08-15 20:16:49" itemprop="dateModified" datetime="2025-08-15T20:16:49+08:00">2025-08-15</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90/" itemprop="url" rel="index"><span itemprop="name">计算机组成</span></a>
                </span>
            </span>

          
            <span class="post-meta-item" title="Views" id="busuanzi_container_page_pv" style="display: none;">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">Views: </span>
              <span id="busuanzi_value_page_pv"></span>
            </span><br>
            <span class="post-meta-item" title="Symbols count in article">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">Symbols count in article: </span>
              <span>22k</span>
            </span>
            <span class="post-meta-item" title="Reading time">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">Reading time &asymp;</span>
              <span>20 mins.</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h2 id="一、设计想法"><a href="#一、设计想法" class="headerlink" title="一、设计想法"></a>一、设计想法</h2><h3 id="1-1-我的CPU的整体架构"><a href="#1-1-我的CPU的整体架构" class="headerlink" title="1.1 我的CPU的整体架构"></a>1.1 我的CPU的整体架构</h3><p><img src="/posts/59164957/微信图片_20211123100405.jpg" alt="微信图片_20211123100405"></p>
<h3 id="1-2-从单周期到流水线"><a href="#1-2-从单周期到流水线" class="headerlink" title="1.2 从单周期到流水线"></a>1.2 从单周期到流水线</h3><p>虽然学长一直在强调重构，身边大佬也都对重构乐此不疲。但是以我个人的感觉，感觉不太需要重构（这可能就是我TLE了两天的错误观念）。我个人感觉完全可以在单周期上面改。为了给大家一个直观印象，我从<strong>修改原单周期CPU，流水线寄存器，加入阻塞刷新功能，加入转发功能</strong>方面分别说一下怎么改（严格说是怎么加，需要改的地方好像没有）：</p>
<h4 id="1-2-1-修改原单周期CPU"><a href="#1-2-1-修改原单周期CPU" class="headerlink" title="1.2.1 修改原单周期CPU"></a>1.2.1 修改原单周期CPU</h4><p>在数据通路方面，就是把NPC放到D级，相应的输入端口因为要从F_instr和D_instr中挑选，所以要加一个MUX，然后加一个CMP（看过我之前帖子，应该知道我的本来就有CMP）。然后去掉GRF的多功能（正常人GRF也没有多功能，只有我的是可以完成set，link，lui功能）。数据通路的修改就完成了。最后要在GRF中实现一个内部转发功能。</p>
<p>在信号方面，只需要加入用于选择F_instr和D_instr的Sel信号就好了，其他不需要更改。</p>
<h4 id="1-2-2-流水线寄存器"><a href="#1-2-2-流水线寄存器" class="headerlink" title="1.2.2 流水线寄存器"></a>1.2.2 流水线寄存器</h4><p>这里集中讨论一下流水线寄存器，对于各级流水线寄存器，需要保存的内容，有下表：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th>DREG</th>
<th>EREG</th>
<th>MREG</th>
<th>WREG</th>
</tr>
</thead>
<tbody>
<tr>
<td>instr</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>1</td>
</tr>
<tr>
<td>CMPOut</td>
<td>-</td>
<td>1</td>
<td>1</td>
<td>1</td>
</tr>
<tr>
<td><strong>PC</strong></td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>1</td>
</tr>
<tr>
<td><strong>EXTOut</strong></td>
<td>-</td>
<td>1</td>
<td>1</td>
<td>1</td>
</tr>
<tr>
<td>rsOut</td>
<td>-</td>
<td>1</td>
<td>-</td>
<td>-</td>
</tr>
<tr>
<td>rtOut</td>
<td>-</td>
<td>1</td>
<td>1</td>
<td>-</td>
</tr>
<tr>
<td><strong>ALUOut</strong></td>
<td>-</td>
<td>-</td>
<td>1</td>
<td>1</td>
</tr>
<tr>
<td><strong>DMOut</strong></td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>1</td>
</tr>
</tbody>
</table>
</div>
<p>首先介绍命名方式，采用的是“数据接收流水级 + REG”的命名方式，比如“EREG”的意思就是EREG里的数据适用于execute阶段（也就是ALU运行）的数据。</p>
<p>然后讨论为什么要保存这些数据？instr和CMPOut是E级及以后的流水线寄存器必须保存的，因为他们决定了一个指令的所有信息，保存instr很好理解，因为诸如opcode，funcode，rs，rt都在里面，保存CMPOut是因为对于b类指令，只依靠instr不能确定指令的所有RTL操作，必须结合CMPOut的结果才能最终确定。但是DREG的寄存器中还没有产生CMPOut，所以他只保存instr。</p>
<p>有些数据被保存下来，是因为它仅仅为了记录某一流水级的运行<strong>成果</strong>，方便下一流水级的使用，比如说rsOut，可以用来给ALUOut当运算数。但是有的数据，比较特殊，是用来保存需要写入寄存器数据的，比如ALUOut，EXTOut，按理说，这些数据在某些流水级没法被利用，应该消亡了，但是他们主要起保存作用，我用<strong>加粗</strong>标出来了，他们的生命周期，刚好是Tnew的值。我们考虑阻塞的时候，要从这个方面去理解原理。</p>
<p>需要注意的是，当一个数据被保存在了流水线寄存器中，他就是流水线级别的，也就是他就需要加流水线前缀了。</p>
<p>此外，注意被保存的数据是经过转发处理之后的，也就是说，输入到EREG中被保存的，不是D_rsOut（直接从GRF中读出的数据），而是经过转发之后的D_FWrsOut。</p>
<h4 id="1-2-3-加入阻塞刷新功能"><a href="#1-2-3-加入阻塞刷新功能" class="headerlink" title="1.2.3 加入阻塞刷新功能"></a>1.2.3 加入阻塞刷新功能</h4><p>在数据通路方面，不需要搭建另外的MUX或则其他的功能部件，只需要将D流水寄存器和PC寄存器改为可以接受en信号即可。</p>
<p>在信号方面，需要构建一个SU单元接受D_instr，E_instr，M_instr产生stall信号。具体实现见下文。</p>
<p>关于流水线寄存器的控制信号，是由SU产生的，用于产生<strong>阻塞和气泡</strong>（同一件事情）。注意这是一个stall信号接在了三个控制端口，PC寄存器也可以看做广义的流水线寄存器，故一并列出，如此，就完后才能了一个周期的<strong>阻塞和气泡</strong>操作。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>信号</th>
<th>解释</th>
</tr>
</thead>
<tbody>
<tr>
<td>stall（起StallPC的作用）</td>
<td>其实就是将这个信号取反连到PC的en端</td>
</tr>
<tr>
<td>stall（起StallD的作用）</td>
<td>其实就是将这个信号取反连到DREG的en端</td>
</tr>
<tr>
<td>stall（起FlushE的作用）</td>
<td>其实就是把这个信号连到EREG的reset端</td>
</tr>
</tbody>
</table>
</div>
<h4 id="1-2-4-加入转发功能"><a href="#1-2-4-加入转发功能" class="headerlink" title="1.2.4 加入转发功能"></a>1.2.4 加入转发功能</h4><p>在数据通路方面，需要加入两种MUX，即 Y_FWxxLevelMux 和 Y_FWSrcMux （Y是流水线级，xx是数据）。具体的作用下文有。</p>
<p>在信号方面，为了控制这两种MUX，需要产生两种Sel信号。所以搭建了一个FU来产生信号。具体的搭建过程见下文。至此，我们的流水线已经实现完成了。</p>
<h3 id="1-3-思考流水线CPU的一个角度"><a href="#1-3-思考流水线CPU的一个角度" class="headerlink" title="1.3 思考流水线CPU的一个角度"></a>1.3 思考流水线CPU的一个角度</h3><p>有些功能，是给定指令就可以得出的，他跟前几个流水级的运行结果没啥关系。比如所有的单周期用到的控制信号：ALUOP，GRFEn，SrcBSel，还有比如说rtTuse，rsTuse，A1，A2，A3，这样的东西都是给定指令就能确定的，他是一个<strong>向量值函数</strong>。完成了由一个指令到一个控制信号向量的映射。这是我们<strong>分布式译码</strong>的理论基础。</p>
<p>有的时候仅凭一条指令是没有办法完成一个流水级功能的，还需要前几个流水级的“成果”。比如说E级想要完成ALU的功能，就必须有SrcA，SrcB和ALUOP，ALUOP是E_instr给出的，但是SrcA，SrcB没办法只从E流水级中获得，所以才需要EREG保存D流水级的成果。我们去思考一个一个流水线寄存器需要保存哪些值的时候，其实就是从这个角度去思考的。</p>
<p>先思考一个简单的问题，CMPOut有没有必要流水（它决定了beq的工作状态的差异），是没有必要的，为什么没必要？是因为beq或者set类指令在D阶段就把所有的需要执行的任务都完成了，所以后面的流水级不需要执行功能，所以就不需要CMPOut了，这是不流水CMPOut的原因。</p>
<p>是不是每级流水线只有他本身的狭义的功能？有一个很有趣的原创指令叫做lwso，它说的是，如果从DMOut中读出的值比0大，那么就写到寄存器中，要不然就不写了。这时采用无脑转发理论，就会有一个缺陷，就是在M级写数据的时候，如果是数据比0小的话，那么就不写了，所以原来持有的数据是错误数据（也就是说，这个错误的数据有可能会被转发，比如先来一个lwso，再来一个sw），那么就会发现sw会接受到一个错误的负数数据，而且没办法更改。这是因为每个流水线除了自己本职工作以外，还有维持转发系统正常运作的功能。所以正确的解决办法就是保存这个值（其实这个值不用加，就是每级的rtOut），并且让他接受后面几级流水的转发更新。是可以建立在<strong>无脑转发理论</strong>上的，不需要对这个理论进行任何的修改。</p>
<p>综上，如果不想在考场上现改数据通路，就要保证流水寄存器的存储了这个流水级和其后流水级实现功能（这里的功能包括本职功能，转发提供，暂停）所需要的所有数据，不能轻易的丢弃用不到的数据。</p>
<h3 id="1-4-对译码方式的讨论"><a href="#1-4-对译码方式的讨论" class="headerlink" title="1.4 对译码方式的讨论"></a>1.4 对译码方式的讨论</h3><h4 id="1-4-1-集中式译码"><a href="#1-4-1-集中式译码" class="headerlink" title="1.4.1 集中式译码"></a>1.4.1 集中式译码</h4><p>我个人没有实现过，但是现在看看，这才叫优雅，越写分布式越觉得集中式的美感和高效（不是指做题的，是客观上）。在效率上能稍微看见其脚后跟的只有分立式的多种类CU可以达到，但是这个写起来难度跟集中式差不多，所以造成了鸡肋的困境。</p>
<p>集中式译码的难度我从外人的角度看，应该是在设计文档的书写上，因为要设计流水线寄存器要保存哪些控制信号，什么时候级不需要保存了，控制信号因为加了流水级前缀，又多又容易弄混，所以很难第一次就写出来（因为不写永远没办法通观全局）。</p>
<p>唯一的缺点就是由于控制信号的传递，使耦合性增加了，流水线CPU被流动的控制信号串成了一个整体。但是好像也没啥不好的，毕竟大家只买CPU，不买FU，FU那么独立也没啥好的（个人观点）。</p>
<h4 id="1-4-2-分布式译码"><a href="#1-4-2-分布式译码" class="headerlink" title="1.4.2 分布式译码"></a>1.4.2 分布式译码</h4><p>代表就是吴佬的设计。但是分布式有一个逃不开的问题，就是FU，SU的实现都需要嵌套CU，这是因为FU，SU都需要比较两个流水线的A、T值，而A，T值是<strong>指令相关的</strong>（1.3的论述），所以必须内置CU来完成这类信息的译码，这样的好处就是加指令的时候只需要修改CU就好了，因为转发和阻塞的规则是用FU和SU实现的，每次指令的不同只是AT值不用，所以加指令的修改很集中，不像分布式那么分散，要修改的地方那么多。</p>
<p>其实为了避免不在FU和SU中实例化CU，还可以考虑把AT值作为输入，输入FU和SU，这也是一个很好很优雅的方法，如果不是我TLE了两天，我就打算这么干了。</p>
<p>但是无论怎么样，多次实例化CU，闲置一些端口，一定会造成资源的浪费和效率的降低，采用这个就与<strong>客观的设计</strong>无缘了。</p>
<h4 id="1-4-3-我的尝试"><a href="#1-4-3-我的尝试" class="headerlink" title="1.4.3 我的尝试"></a>1.4.3 我的尝试</h4><p>为了写出<strong>多样性的CU</strong>来减轻自己的负罪感（真的只是负罪感，写同质化的CU没有任何问题，而且更方便，只用在一个文件里就可以完成加指令操作）。我想了一种代码复用的方法，就是独立出一个叫做CORE的东西，他就是一个指令的向量值函数，但是每个CORE对应的向量值函数是不一样的，比如说阻塞刷新用不到T值，那么SUCORE就不会产生T值，CU中不需要A值和T值，那么CUCORE（就是CORE）就不会产生A和T值，FUCORE和SUCORE都需要产生A值，那么就做一个BasicCORE来实现这个功能，然后让他们嵌套应用。具体如下</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>模块</th>
<th>应用</th>
<th>功能</th>
</tr>
</thead>
<tbody>
<tr>
<td>CORE</td>
<td>无</td>
<td>产生order</td>
</tr>
<tr>
<td>BasicCORE</td>
<td>CORE</td>
<td>产生order，A1，A2，A3</td>
</tr>
<tr>
<td>FUCORE</td>
<td>BasicCORE</td>
<td>产生order，A1，A2，A3，FWSrcSel</td>
</tr>
<tr>
<td>SUCORE</td>
<td>BasicCORE</td>
<td>产生order，A1，A2，A3，rsTuse，rtTuse，E_Tnew，M_Tnew</td>
</tr>
</tbody>
</table>
</div>
<p>这个只是个人习惯，完全没有优势可言，只为博君一笑。</p>
<p><em>考完出来了，大家不要在考场上用这种方法，嵌套的形式改端口太麻烦了，整个人麻了，想给CORE加个端口，就四个CORE还有FU和SU一个一个加，一个一个布线，累死了。</em></p>
<h4 id="1-4-4-郭哥的设计"><a href="#1-4-4-郭哥的设计" class="headerlink" title="1.4.4 郭哥的设计"></a>1.4.4 郭哥的设计</h4><p>郭哥的设计是我觉得在我看到的设计里面最漂亮，最优雅，最客观的一种。总的来说，是集中式译码的一种变体，他把控制信号的流水寄存器集成在了CU中，在mips顶端看，看上去像一个分布式译码，但是实际是集中式。在搭配上郭哥<strong>谨慎</strong>的控制逻辑（没有采用无脑转发理论），可以说，是一个极具个人风格，跟整个CPU的设计气质契合的非常好。不得不说，集中式除了写起来难度巨大（尤其是第一遍），但是在加各种稀奇古怪的指令方面，有着天然的优势。我在考前听得叹为观止。</p>
<p>而且确实，如果不采用老师给的AT无脑法判断，自己思考转发阻塞机制，虽然有一些不稳妥的代价，但是有两点好处：一个是自己发明的方法，理解起来肯定更深。另一个是自己写的东西，是跟自己CPU其他部分的设计思想是契合的。我个人观点，AT法本身就带着过于彪悍的气质（过于简洁，过于强大，过于让人不相信），很容易跟CPU其他设计理念冲突，不是所有人都适合采用这种方法，我自己就亲身见过也是很聪明很牛逼综合素质很好的很多学神（当然包括郭哥），对AT法做了改革，或者完全舍弃了AT法。不稳妥的代价在强测上线以后，也变得稍微少了一些。</p>
<h3 id="1-5-加一条指令需要考虑什么？"><a href="#1-5-加一条指令需要考虑什么？" class="headerlink" title="1.5 加一条指令需要考虑什么？"></a>1.5 加一条指令需要考虑什么？</h3><ul>
<li>在 const.v 中，给这条指令一个编码。</li>
<li>在CORE中，使这条指令可以根据opcode和funcode进行译码。</li>
<li>在BasicCORE中，构造这条指令的A值。（本质是决定这条指令是读数据的地址，又是写数据的地址）</li>
<li>在FUCORE中，构造这条指令的写指令数据保存区域FWSrc，如果没有，就默认。（本质是决定写数据的指令的数据存放的地点）</li>
<li>在SUCORE中，构造这条指令的T值。（本质是决定这条指令与其他指令的相互作用造成的阻塞行为）</li>
<li>在CU中，构造这条指令的控制信号（使能，功能，选择，本质是确定CPU的工作状态）。</li>
</ul>
<p>其实无论构造什么样子的CPU，是集中式译码还是分布式译码，是无脑转发还是谨慎转发，最后考虑的一定都是这几个问题，而一个好的（或者说适合应试的CPU），一定是在考场上，无论这几个问题的答案组合是什么，都可以很轻松的实现添加操作，而不是需要再加控制信号之类的东西。</p>
<hr>
<h2 id="二、理论"><a href="#二、理论" class="headerlink" title="二、理论"></a>二、理论</h2><h3 id="2-1-延迟槽"><a href="#2-1-延迟槽" class="headerlink" title="2.1 延迟槽"></a>2.1 延迟槽</h3><p>延迟槽最难理解的是他的表述，<strong>不论判断结果如何，我们都将执行分支或跳转指令的下一条指令。这也就是所谓的“延迟槽”。通过这种做法，我们可以利用编译调度，将适当的指令移入延迟槽中，充分利用流水线的性能。</strong>那么到底是谁在“移动指令”。按我一开始的理解，肯定是编译器啊，因为封装抽象的特性，软件程序员不应该需要了解CPU硬件实现机制，他应该按照原来的方式编码，然后编译器就自动将指令进行一个重新排布。但是事实是，这个确实是由程序员实现的。他编写的代码就是按照这种不自然的方式运行的（<strong>我们都将执行分支或跳转指令的下一条指令</strong>）。最快了解延迟槽的办法就是打开MARS，然后勾选“Setting-Delayed Branching”，自己写一段指令单步执行一下就好了（延迟槽指令在执行的时候会变成绿色）。</p>
<h3 id="2-2-A和T的构造"><a href="#2-2-A和T的构造" class="headerlink" title="2.2 A和T的构造"></a>2.2 A和T的构造</h3><p>关于A1的构造：</p>
<ul>
<li>如果读指令需要利用rsOUt，则A1是rs，否则是0</li>
<li>0的情况对应有两种，一个是rs真的是0，一个是指令不需要利用rsOut（比如jal）</li>
</ul>
<p>对于A2的构造：</p>
<ul>
<li>如果读指令需要利用rtOUt，则A2是rt，否则是0</li>
<li>0的情况对应有两种，一个是rt真的是0，一个是指令不需要利用rtOut（比如jal，lw）</li>
</ul>
<p>对于A3的构造：</p>
<ul>
<li>如果指令的写地址是rt，那么A3就是rt</li>
<li>如果指令的写地址是rd，那么A3就是rd</li>
<li>如果指令是link操作，那么A3就是31</li>
<li>如果不是写指令，那么A3就是0</li>
<li>A3是0对应两种，一个是写指令的地址本身就是0，一个是不是写指令</li>
</ul>
<p>对于Tuse和Tnew，是一个直接映射，见下表：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>指令</th>
<th>$rsT_{use}$</th>
<th>$rtT_{use}$</th>
</tr>
</thead>
<tbody>
<tr>
<td>addu</td>
<td>1</td>
<td>1</td>
</tr>
<tr>
<td>subu</td>
<td>1</td>
<td>1</td>
</tr>
<tr>
<td>ori</td>
<td>1</td>
<td>-</td>
</tr>
<tr>
<td>lw</td>
<td>1</td>
<td>-</td>
</tr>
<tr>
<td>sw</td>
<td>1</td>
<td>2</td>
</tr>
<tr>
<td>beq</td>
<td>0</td>
<td>0</td>
</tr>
<tr>
<td>lui</td>
<td>-</td>
<td>-</td>
</tr>
<tr>
<td>j</td>
<td>-</td>
<td>-</td>
</tr>
<tr>
<td>jal</td>
<td>-</td>
<td>-</td>
</tr>
<tr>
<td>jr</td>
<td>0</td>
<td>-</td>
</tr>
<tr>
<td>nop</td>
<td>-</td>
<td>-</td>
</tr>
</tbody>
</table>
</div>
<div class="table-container">
<table>
<thead>
<tr>
<th>指令</th>
<th>$ET_{new}$</th>
<th>$MT_{new}$</th>
<th>$WT_{new}$</th>
</tr>
</thead>
<tbody>
<tr>
<td>addu</td>
<td>1</td>
<td>0</td>
<td>0</td>
</tr>
<tr>
<td>subu</td>
<td>1</td>
<td>0</td>
<td>0</td>
</tr>
<tr>
<td>ori</td>
<td>1</td>
<td>0</td>
<td>0</td>
</tr>
<tr>
<td>lw</td>
<td>2</td>
<td>1</td>
<td>0</td>
</tr>
<tr>
<td>sw</td>
<td>-</td>
<td>-</td>
<td>-</td>
</tr>
<tr>
<td>beq</td>
<td>-</td>
<td>-</td>
<td>-</td>
</tr>
<tr>
<td>lui</td>
<td>0</td>
<td>0</td>
<td>0</td>
</tr>
<tr>
<td>j</td>
<td>-</td>
<td>-</td>
<td>-</td>
</tr>
<tr>
<td>jal</td>
<td>0</td>
<td>0</td>
<td>0</td>
</tr>
<tr>
<td>jr</td>
<td>-</td>
<td>-</td>
<td>-</td>
</tr>
<tr>
<td>nop</td>
<td>-</td>
<td>-</td>
<td>-</td>
</tr>
</tbody>
</table>
</div>
<h3 id="2-3-阻塞和刷新"><a href="#2-3-阻塞和刷新" class="headerlink" title="2.3 阻塞和刷新"></a>2.3 阻塞和刷新</h3><p>先介绍一下<strong>流水线寄存器的本质</strong>，<strong>每个流水线寄存器都保存着一条指令执行所需要的的全部信息</strong>，也就是说，如果EREG还正常，前面DREG就算炸了，E流水级对应的指令还是能够得到执行（但是E后面的元器件炸了不行）。与之相对的，如果将EREG的内容修改了，E流水级此时对应指令就被修改了，哪怕其他流水线寄存器的都没有发生改变，E流水级对应的指令还是被修改了。</p>
<p>所谓阻塞，就是对<strong>流水线寄存器和PC寄存器</strong>的使能端进行控制，当使能端为0的时候，当时钟有效沿再来临的时候，就不会再录入新数据了。结合流水线分析，我们可以得到一个性质，<strong>被阻塞的寄存器之前的寄存器一定是需要被阻塞的</strong>（PC寄存器被认为在DREG之前），这是因为如果靠前的寄存器没有被阻塞，而靠后的寄存器阻塞了，那么靠前的寄存器的指令就会发生<strong>丢失</strong>，这显然是与阻塞的目的不同。</p>
<p>所谓刷新，就是对流水线寄存器的reset端进行控制，当刷新信号Flush给到时，流水线寄存器重置，由第一段的介绍可以知道，如果一个流水线寄存器被修改了，那么这个流水级对应的指令就被修改了，如果寄存器被清零了，那么这个流水级对应的指令就改成了清零的数据对应的那条指令了，这个指令一般对应的都是nop（直接说是nop是不严谨的，如果清零的数据对应的不是nop，那么就不是nop）。</p>
<p>然后我们需要意识到，<strong>阻塞和刷新是由一个信号控制的</strong>，当发生的时候，PC寄存器和DREG被阻塞，同时EREG会被刷新。这样，效果就是，指令在F级和D级不流动了，E级产生了一个nop指令，这也是跟我们的设计构想一致。如果没有阻塞，那么指令要么继续流动，要么丢失，都不对。如果没有刷新，那么E级就会接受D级的指令，然后D级在其被阻塞期间就会一一直传给E级相同的信息（D级一直保持不变），那么流水线上就会多一条D级指令（一条是因为阻塞是一个周期），就会造成错误。于此同时，因为 $T<em>{use}$ 最小是0（beq，jr），$T</em>{new}$ 最大是2（lw），所以最多阻塞两个周期（不只是这几个指令，而是所有指令的上下界），也就是最多产生两个nop指令。</p>
<p>我们代码中判断是否发生阻塞的条件如下：</p>
<pre class="line-numbers language-verilog" data-language="verilog"><code class="language-verilog"><span class="token keyword">wire</span> E_StallRs <span class="token operator">=</span> <span class="token punctuation">(</span>rsTuse <span class="token operator">&lt;</span> E_Tnew<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>E_A3 <span class="token operator">&amp;&amp;</span> E_A3 <span class="token operator">==</span> A1<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">wire</span> E_StallRt <span class="token operator">=</span> <span class="token punctuation">(</span>rtTuse <span class="token operator">&lt;</span> E_Tnew<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>E_A3 <span class="token operator">&amp;&amp;</span> E_A3 <span class="token operator">==</span> A2<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">wire</span> E_Stall <span class="token operator">=</span> E_StallRs <span class="token operator">||</span> E_StallRt<span class="token punctuation">;</span>

<span class="token keyword">wire</span> M_StallRs <span class="token operator">=</span> <span class="token punctuation">(</span>rsTuse <span class="token operator">&lt;</span> M_Tnew<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>M_A3 <span class="token operator">&amp;&amp;</span> M_A3 <span class="token operator">==</span> A1<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">wire</span> M_StallRt <span class="token operator">=</span> <span class="token punctuation">(</span>rtTuse <span class="token operator">&lt;</span> M_Tnew<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>M_A3 <span class="token operator">&amp;&amp;</span> M_A3 <span class="token operator">==</span> A2<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">wire</span> M_Stall <span class="token operator">=</span> M_StallRs <span class="token operator">||</span> M_StallRt<span class="token punctuation">;</span>

<span class="token keyword">assign</span> stall <span class="token operator">=</span> E_Stall <span class="token operator">||</span> M_Stall<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>可以看到，对于特定读地址，特定流水级，阻塞和刷新的条件是这样的：</p>
<ul>
<li><p>A3 == A1，说明读地址和写地址是同一个地址，如果不是同一个地址，显然不需要操心阻塞的问题。</p>
</li>
<li><p>A3  != 0，这说明A3一定是个<strong>不写0号寄存器的写指令</strong>的寄存器地址，如果不是写指令，那么自然没有阻塞的必要，如果是向0号寄存器写指令，那么数据显然也是不能用的（传到GRF后也是不能写入），此时阻塞就是多此一举。</p>
</li>
<li>A1 != 0，这说明D级的指令是一个<strong>不读0号寄存器的读指令</strong>，如果它不是一个读指令，那么就没有阻塞的必要了，如果，如果是一个读0号寄存器的读指令，那么也不需要阻塞，因为0号寄存器永远不会被更改，直接读就好了。</li>
<li>Tuse &lt; Tnew，这是因为读数据等待的最长时间小于写数据产生的最短时间，就需要阻塞。</li>
</ul>
<h3 id="2-4-转发"><a href="#2-4-转发" class="headerlink" title="2.4 转发"></a>2.4 转发</h3><h4 id="2-4-1-转发总论"><a href="#2-4-1-转发总论" class="headerlink" title="2.4.1 转发总论"></a>2.4.1 转发总论</h4><p>其实就是<strong>“2种MUX，1个理论”</strong>。</p>
<h4 id="2-4-1-转发的提供者的实现"><a href="#2-4-1-转发的提供者的实现" class="headerlink" title="2.4.1 转发的提供者的实现"></a>2.4.1 转发的提供者的实现</h4><p>转发的提供者其实不需要考虑转发的接受者是谁，因为对于一条指令，他能提供的数据至多一种，他如果不是写指令，就不会提供数据，如果他是写指令，也要区分需要写的数据是否产生。这里我们采用的是，如果是写指令，就通过一个MUX从流水线寄存器的输出里选择结果，比如add就会选择ALUout，lw就会选择DMOut，此时衍生了一个问题，就是万一没有怎么办？比如在EREG中，就没有DMOut，这样我们就随便转发一个数据过去（我转发的是PC+ 8，其实转个0过去更优雅，但是我被TLE折磨怕了），也就是转发了错误数据，但是我们会在后面论证这种错误是可以容忍的。</p>
<p>这是第一种MUX，输入是流水线寄存器的输出，输出是当前指令对应的写数据。</p>
<h4 id="2-4-2-转发的接受者是谁？"><a href="#2-4-2-转发的接受者是谁？" class="headerlink" title="2.4.2 转发的接受者是谁？"></a>2.4.2 转发的接受者是谁？</h4><p>无论是教材还是教程，都告诉我们转发的接受者是功能模块的输入端口，比如NPC的PC端，CMP的num1，num2，ALU的SrcA，SrcB。但是我觉得不够好。因为按照这种思路设计，那么以D级为例，应该在CMP两端连两个MUX进行转发选择（判断要使用哪一级的数据），再在GRF的两个输出端口连接两个MUX进行转发选择。再在NPC的输入连接一个MUX进行转发选择。</p>
<p>但是其实不是这样的。转发的接受者应该是流水级的某个数据，而不是某个模块。比如说在D级的时候，我们需要读出的数据就是rs对应的寄存器数据（rsOUt）和rt对应的寄存器数据（rtOut），然后才是利用这些数据进行各种处理。所以我们转发的目的不应该是仅仅为模块提供正确数据，而应是把rsOut和rtOUt换成正确的，经过转发后的数据FWrsOUt，FWrtOut，这样就是两个MUX（而且无论哪种解释，其实都是俩MUX，就是上面那种说的很不清楚）。</p>
<p>这是第二种MUX，输入是各级的第一种MUX的输出，输出是当前正确（或者可以容忍的错误）的读数据。</p>
<h4 id="2-4-3-无脑转发理论"><a href="#2-4-3-无脑转发理论" class="headerlink" title="2.4.3 无脑转发理论"></a>2.4.3 无脑转发理论</h4><p>当我们实现了阻塞和刷新功能的后，就会发现流水线此时<strong>读数据</strong>一定会在<strong>写数据</strong>产生之后被应用（如果不是这样，对应的就是Tuse &lt; Tnew，就该被阻塞刷新了），所以我们可以推出一个重要理论，就是<strong>无脑转发理论</strong>（这条理论没有在教程中显式的被提到），这条理论说的是</p>
<ul>
<li>转发只有地址相同判断和非0判断，结合<strong>就近原则</strong>（最后一级是本身）</li>
<li>不需要用到T值</li>
</ul>
<p>所谓就近原则，就是离自己最近的后面的流水级优先度最高，越远越低，同时最低的是自己，比如，对于D级来说，优先级是E、M、W、D。所谓<strong>无脑</strong>，指的是只要符合条件就转发，所以转发的数据可能是错误的，但是根据这个理论，转发的数据</p>
<p>不需要用到T值这条是很不直观的，缺少了Tnew的判断，转发的数据可能还没有算出来，比如说 <strong>add(D)-add(E)-add(M)-add(W)</strong>，D的数据根据<strong>就近原则</strong>是从E中获得的（我们假设这后面三个add的写寄存器地址都与第一个add的读寄存器地址相同），但是add（E）中的ALUOut是错的（在实现的时候，我输进去的是PC + 8，属于摆烂行为），但是没关系，因为D级的add就算获得了正确的数据它也不用，他得到了E级才用，而当他到了E级的时候，原来的add（E）就成了add（M），此时还会再进行一次转发，这回就是对的了。</p>
<p>那么<strong>beq(D)-add(E)-add(M)-add(W)</strong>这样的，也就是说，如果我的转发数据现在就要用（NPC在D级），但是遵循就近原则，我要用add（E）的数据，这就错了呀，不会的，因为这时候，会触发阻塞机制，所以还是会有正确的add（M）诞生的。总的来说，在阻塞机制的保障下（<strong>读数据</strong>一定会在<strong>写数据</strong>产生之后被应用），导致就近原则不会出现错误，无脑转发理论是正确的。</p>
<p>判断代码如下（转发D级rsOUt，生成D_FWrsOut的MUX选择信号）：</p>
<pre class="line-numbers language-verilog" data-language="verilog"><code class="language-verilog"><span class="token keyword">assign</span> D_FWrsLevelSel <span class="token operator">=</span> <span class="token punctuation">(</span>E_A3 <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>D_A1 <span class="token operator">==</span> E_A3<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token operator">?</span> E <span class="token punctuation">:</span>
						<span class="token punctuation">(</span>M_A3 <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>D_A1 <span class="token operator">==</span> M_A3<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token operator">?</span> M <span class="token punctuation">:</span>
												  D <span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>关于<strong>无脑转发理论</strong>，其实有一个很大的要求，也是一个可以说很大的缺陷，就是他必须保证在一条写指令结束之前，正确的数据会产生，但是实际有可能达不到这种条件，比如1.3中介绍的lwso。不过我已经解决他了。</p>
<h3 id="2-5-内部转发"><a href="#2-5-内部转发" class="headerlink" title="2.5 内部转发"></a>2.5 内部转发</h3><p>理解这个需要上面提到的六级寄存器观点，将GRF看做在WREG后面的一级寄存器，可以看到，要在W阶段的结尾（将有效沿的来临视为结尾），才能将WREG的内容写入GRF。在没有写入之前，W阶段的转发数据跟其他流水级是相同的，是可以转发到前面的D，E，M流水级的。</p>
<p>我们所说的内部转发，指的就是<strong>从W流水级转发到D流水级</strong>的情况，这样，我们的解决办法就不像普通转发一样：在D级设置的FWrsLevelMux是没有转发W级的选项的，转发是在GRF内部实现的，也就是下面的语句：</p>
<pre class="line-numbers language-verilog" data-language="verilog"><code class="language-verilog"><span class="token keyword">assign</span> GRFOut1 <span class="token operator">=</span> <span class="token punctuation">(</span>GRFAdd1 <span class="token operator">==</span> GRFAdd3 <span class="token operator">&amp;&amp;</span> GRFAdd3 <span class="token operator">&amp;&amp;</span> en<span class="token punctuation">)</span><span class="token operator">?</span> GRFIn <span class="token punctuation">:</span> GRF<span class="token punctuation">[</span>GRFAdd1<span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token keyword">assign</span> GRFOut2 <span class="token operator">=</span> <span class="token punctuation">(</span>GRFAdd2 <span class="token operator">==</span> GRFAdd3 <span class="token operator">&amp;&amp;</span> GRFAdd3 <span class="token operator">&amp;&amp;</span> en<span class="token punctuation">)</span><span class="token operator">?</span> GRFIn <span class="token punctuation">:</span> GRF<span class="token punctuation">[</span>GRFAdd2<span class="token punctuation">]</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>也就是说，转发的条件有三个：</p>
<ul>
<li>读地址和写地址相同：如果不相同当然没有转发的必要。</li>
<li>写地址不是0号寄存器，因为会出现往寄存器0中写数据的指令，所以此时<strong>写数据</strong>非零，但是写数据却没有办法写入0号寄存器（可以理解为写数据实际是0），所以如果贸然转发，就会让一个读0寄存器的指令获得<strong>非零的转发写数据</strong>。</li>
<li>写使能是1，这是因为GRF无时不刻在有GRFAdd3，我们控制写不写是靠写使能，如果没有这条条件，就会导致一些<strong>非写指令</strong>的数据被转发，这显然是我们不希望看到的。</li>
</ul>
<hr>
<h2 id="三、模块"><a href="#三、模块" class="headerlink" title="三、模块"></a>三、模块</h2><h3 id="3-1-CONTROL"><a href="#3-1-CONTROL" class="headerlink" title="3.1 CONTROL"></a>3.1 CONTROL</h3><h4 id="3-1-1-CU"><a href="#3-1-1-CU" class="headerlink" title="3.1.1 CU"></a>3.1.1 CU</h4><h5 id="3-1-1-1-CORE"><a href="#3-1-1-1-CORE" class="headerlink" title="3.1.1.1 CORE"></a>3.1.1.1 CORE</h5><p>他可以根据opcode和funcode识别指令.</p>
<p>CORE模块会在CU里被实例化四次，用于识别D、E、M、W四个流水级的四个不同的指令。进而用于控制信号的产生。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>端口</th>
<th>方向</th>
<th>宽度</th>
<th>解释</th>
</tr>
</thead>
<tbody>
<tr>
<td>instr</td>
<td>IN</td>
<td>32</td>
<td>当前流水级的指令</td>
</tr>
<tr>
<td>order</td>
<td>OUT</td>
<td>7（6位opcode，6位funcode）</td>
<td>当前指令</td>
</tr>
</tbody>
</table>
</div>
<h5 id="3-1-1-2-CU"><a href="#3-1-1-2-CU" class="headerlink" title="3.1.1.2 CU"></a>3.1.1.2 CU</h5><p>这次的CU从原来的“每个指令单独一套控制信号”，变成了“每个信号单独对应一套指令”。这是第一个修改，不知道是不是适用于应试。</p>
<p>还有一个修改就是取消了GRFOP的功能，GRF的写入功能变得单一，相应的功能被外接的选择信号实现，具体发生改变的有lui和jal，lui改为在EXT中扩展，jal的31号的选择在GRFAdd3MUX中出现。</p>
<p>CU内置的四个CORE核，CORE核只能识别对应阶段指令，但是产生的信号是不分阶段的。这也是设计的巧妙之处，也就是说，信号是全局级别的（与之相对的，还有流水级别和数据级别）</p>
<p>使能信号指令统计表：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>指令</th>
<th>GRFEn</th>
<th>DMEn</th>
</tr>
</thead>
<tbody>
<tr>
<td>nop</td>
<td>0</td>
<td>0</td>
</tr>
<tr>
<td>addu</td>
<td>1</td>
<td>0</td>
</tr>
<tr>
<td>subu</td>
<td>1</td>
<td>0</td>
</tr>
<tr>
<td>ori</td>
<td>1</td>
<td>0</td>
</tr>
<tr>
<td>lw</td>
<td>1</td>
<td>0</td>
</tr>
<tr>
<td>lui</td>
<td>1</td>
<td>0</td>
</tr>
<tr>
<td>jal</td>
<td>1</td>
<td>0</td>
</tr>
<tr>
<td>j</td>
<td>0</td>
<td>0</td>
</tr>
<tr>
<td>jr</td>
<td>0</td>
<td>0</td>
</tr>
<tr>
<td>beq</td>
<td>0</td>
<td>0</td>
</tr>
<tr>
<td>sw</td>
<td>1</td>
<td>1</td>
</tr>
</tbody>
</table>
</div>
<p>功能信号表（具体实现的功能在上一篇帖子有）：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>OP</th>
<th>default</th>
<th></th>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>CMPOP</td>
<td>EQ</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>EXTOP</td>
<td>ZE16</td>
<td>SE16</td>
<td>ZE16</td>
<td>LUI</td>
<td></td>
</tr>
<tr>
<td>NPCOP</td>
<td>NORMAL</td>
<td>BRANCH</td>
<td>J</td>
<td>JR</td>
<td></td>
</tr>
<tr>
<td>ALUOP</td>
<td>ADD</td>
<td>SUB</td>
<td>OR</td>
<td></td>
<td></td>
</tr>
<tr>
<td>DMOP</td>
<td>W</td>
<td>H</td>
<td>B</td>
<td></td>
</tr>
</tbody>
</table>
</div>
<p>功能信号指令统计表：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>指令</th>
<th>CMPOP</th>
<th>EXTOP</th>
<th>NPCOP</th>
<th>ALUOP</th>
<th>DMOP</th>
</tr>
</thead>
<tbody>
<tr>
<td>nop</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
</tr>
<tr>
<td>addu</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>ADD</td>
<td>-</td>
</tr>
<tr>
<td>subu</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>SUB</td>
<td>-</td>
</tr>
<tr>
<td>ori</td>
<td>-</td>
<td>ZE16</td>
<td>-</td>
<td>OR</td>
<td>-</td>
</tr>
<tr>
<td>lw</td>
<td>-</td>
<td>SE16</td>
<td>-</td>
<td>ADD</td>
<td>W</td>
</tr>
<tr>
<td>lui</td>
<td>-</td>
<td>LUI</td>
<td>-</td>
<td>-</td>
<td>W</td>
</tr>
<tr>
<td>sw</td>
<td>-</td>
<td>SE16</td>
<td>-</td>
<td>ADD</td>
<td>W</td>
</tr>
<tr>
<td>jal</td>
<td>-</td>
<td>ZE26</td>
<td>J</td>
<td>-</td>
<td>-</td>
</tr>
<tr>
<td>j</td>
<td>-</td>
<td>ZE26</td>
<td>J</td>
<td>-</td>
<td>-</td>
</tr>
<tr>
<td>jr</td>
<td>-</td>
<td>-</td>
<td>JR</td>
<td>-</td>
<td>-</td>
</tr>
<tr>
<td>beq</td>
<td>EQ</td>
<td>-</td>
<td>BRANCH/NORMAL</td>
<td>-</td>
<td>-</td>
</tr>
</tbody>
</table>
</div>
<p>选择信号表</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>Sel</th>
<th>default</th>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>PCSel</td>
<td>F</td>
<td>D</td>
<td></td>
<td></td>
</tr>
<tr>
<td>JumpSel</td>
<td>EXTOut</td>
<td>rsOut</td>
<td></td>
<td></td>
</tr>
<tr>
<td>SrcBSel</td>
<td>EXTOut</td>
<td>rtOut</td>
<td></td>
<td></td>
</tr>
<tr>
<td>GRFInSel</td>
<td>ALUOut</td>
<td>DMOut</td>
<td>PC8</td>
<td>EXTOut</td>
</tr>
<tr>
<td>GRFAdd3Sel</td>
<td>rt</td>
<td>rd</td>
<td>Link</td>
</tr>
</tbody>
</table>
</div>
<p>选择信号指令统计表：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>指令</th>
<th>PCSel</th>
<th>JumpSel</th>
<th>SrcBSel</th>
<th>GRFInSel</th>
<th>GRFAdd3Sel</th>
</tr>
</thead>
<tbody>
<tr>
<td>nop</td>
<td>F</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
</tr>
<tr>
<td>addu</td>
<td>F</td>
<td>-</td>
<td>rtOut</td>
<td>ALUOut</td>
<td>rd</td>
</tr>
<tr>
<td>subu</td>
<td>F</td>
<td>-</td>
<td>rtOut</td>
<td>ALUOut</td>
<td>rd</td>
</tr>
<tr>
<td>ori</td>
<td>F</td>
<td>-</td>
<td>EXTOut</td>
<td>ALUOut</td>
<td>rt</td>
</tr>
<tr>
<td>lw</td>
<td>F</td>
<td>-</td>
<td>EXTOut</td>
<td>DMOut</td>
<td>rt</td>
</tr>
<tr>
<td>lui</td>
<td>F</td>
<td>-</td>
<td>-</td>
<td>EXTOut</td>
<td>rt</td>
</tr>
<tr>
<td>sw</td>
<td>F</td>
<td>-</td>
<td>EXTOut</td>
<td>-</td>
<td>-</td>
</tr>
<tr>
<td>jal</td>
<td>D</td>
<td>EXTOut</td>
<td>-</td>
<td>PC8</td>
<td>Link</td>
</tr>
<tr>
<td>j</td>
<td>D</td>
<td>EXTOut</td>
<td>-</td>
<td>-</td>
<td>-</td>
</tr>
<tr>
<td>jr</td>
<td>D</td>
<td>rsOut</td>
<td>-</td>
<td>-</td>
<td>-</td>
</tr>
<tr>
<td>beq</td>
<td>D/F</td>
<td>EXTOut</td>
<td>-</td>
<td>-</td>
<td>-</td>
</tr>
</tbody>
</table>
</div>
<h4 id="3-1-2-SU"><a href="#3-1-2-SU" class="headerlink" title="3.1.2 SU"></a>3.1.2 SU</h4><h5 id="3-1-2-1-BasicCORE"><a href="#3-1-2-1-BasicCORE" class="headerlink" title="3.1.2.1 BasicCORE"></a>3.1.2.1 BasicCORE</h5><p>用于被FUCORE和SUCORE调用，在其中调用了CORE。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>端口</th>
<th>方向</th>
<th>宽度</th>
<th>解释</th>
</tr>
</thead>
<tbody>
<tr>
<td>instr</td>
<td>IN</td>
<td>32</td>
<td>当前指令</td>
</tr>
<tr>
<td>A1</td>
<td>OUT</td>
<td>5</td>
<td>如果D流水级中的指令需要读取rs中的内容，A1为rs的编号，否则为0（不需要读的情况）</td>
</tr>
<tr>
<td>A2</td>
<td>OUT</td>
<td>5</td>
<td>如果D流水级中的指令需要读取rd中的内容，A2为rd的编号，否则为0</td>
</tr>
<tr>
<td>A3</td>
<td>OUT</td>
<td>5</td>
<td>若输入指令需要写目的寄存器，则A3为目的寄存器的编号，否则为0（不需要写的情况）</td>
</tr>
</tbody>
</table>
</div>
<h5 id="3-1-2-2-SUCORE"><a href="#3-1-2-2-SUCORE" class="headerlink" title="3.1.2.2 SUCORE"></a>3.1.2.2 SUCORE</h5><p>SUCORE是Stall Unit单元里的基本组成成分，它内部实例化了一个CORE，可以看做是功能加强版的CORE，他比CORE多了对于Tuse和Tnew变量的输出，用于在SU中产生stall信号。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>端口</th>
<th>方向</th>
<th>宽度</th>
<th>解释</th>
</tr>
</thead>
<tbody>
<tr>
<td>instr</td>
<td>IN</td>
<td>32</td>
<td>当前流水级的指令</td>
</tr>
<tr>
<td>A1</td>
<td>OUT</td>
<td>5</td>
<td>如果D流水级中的指令需要读取rs中的内容，A1为rs的编号，否则为0（不需要读的情况）</td>
</tr>
<tr>
<td>A2</td>
<td>OUT</td>
<td>5</td>
<td>如果D流水级中的指令需要读取rd中的内容，A2为rd的编号，否则为0</td>
</tr>
<tr>
<td>A3</td>
<td>OUT</td>
<td>5</td>
<td>若输入指令需要写目的寄存器，则A3为目的寄存器的编号，否则为0（不需要写的情况）</td>
</tr>
<tr>
<td>rsTuse</td>
<td>OUT</td>
<td>3</td>
<td>说明再在D流水的基础上过rsTuse个周期，就需要使用到rs中的内容了，如果不使用rs，则该项为0</td>
</tr>
<tr>
<td>rtTuse</td>
<td>OUT</td>
<td>3</td>
<td>说明再在D流水的基础上过rtTuse个周期，就需要使用到rt中的内容了，如果不使用rs，则该项为0</td>
</tr>
<tr>
<td>E_Tnew</td>
<td>OUT</td>
<td>3</td>
<td>在E流水级上的指令再过Tnew个周期，就可以产生要往寄存器里写的值了，如果不写寄存器，该值为0</td>
</tr>
<tr>
<td>M_Tnew</td>
<td>OUT</td>
<td>3</td>
<td>在M流水级上的指令再过Tnew个周期，就可以产生要往寄存器里写的值了，如果不写寄存器，该值为0</td>
</tr>
</tbody>
</table>
</div>
<p>当 A1 == A3 且 A3 != 0 时，说明存在RAW冲突，于此同时，如果还有任一流水级的Tnew大于Tuse（说明产生新值的时间要超过了等待时间），那么就需要进行终止了，只需要考虑E级和M级的Tnew，是因为W级的Tnew恒为0（因为是写寄存器的最后一步了），所以不可能有一个值比0小。所以不用考虑W级。</p>
<h5 id="3-1-2-3-SU"><a href="#3-1-2-3-SU" class="headerlink" title="3.1.2.3 SU"></a>3.1.2.3 SU</h5><p>阻塞模块，其中有3个SUCORE核，分别用于产生D、E、M级产生的阻塞判断信号，W级一定不会造成阻塞，所以不用判断。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>端口</th>
<th>方向</th>
<th>宽度</th>
<th>解释</th>
</tr>
</thead>
<tbody>
<tr>
<td>D_instr</td>
<td>IN</td>
<td>32</td>
<td>D级指令</td>
</tr>
<tr>
<td>E_instr</td>
<td>IN</td>
<td>32</td>
<td>E级指令</td>
</tr>
<tr>
<td>M_instr</td>
<td>IN</td>
<td>32</td>
<td>M级指令</td>
</tr>
<tr>
<td>D_CMPOut</td>
<td>IN</td>
<td>1</td>
<td>D级比较结果</td>
</tr>
<tr>
<td>E_CMPOut</td>
<td>IN</td>
<td>1</td>
<td>E级比较结果</td>
</tr>
<tr>
<td>M_CMPOut</td>
<td>IN</td>
<td>1</td>
<td>M级比较结果</td>
</tr>
<tr>
<td>stall</td>
<td>OUT</td>
<td>1</td>
<td>阻塞信号</td>
</tr>
</tbody>
</table>
</div>
<h4 id="3-1-3-FU"><a href="#3-1-3-FU" class="headerlink" title="3.1.3 FU"></a>3.1.3 FU</h4><p>FU的产生的选择信号：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>信号</th>
<th>解释</th>
</tr>
</thead>
<tbody>
<tr>
<td>E_FWSrcSel</td>
<td>从E级流水寄存器中选择转发数据，其中jal写在PC，lui 写在EXTout</td>
</tr>
<tr>
<td>M_FWSrcSel</td>
<td>从M级流水寄存器中选择转发数据，其中jal写在PC，lui 写在EXTout，cal写在ALUOut</td>
</tr>
<tr>
<td>W_FWSrcSel</td>
<td>从W级流水寄存器中选择转发数据，其中jal写在PC，lui 写在EXTout，cal写在ALUOut，load写在DMOut</td>
</tr>
<tr>
<td>D_FWrsLevelSel</td>
<td>从不同流水级的转发数据中选择出合适的一个，供给D级的NPC的jump和CMP的num1，如果地址是0，那么应该选择32位0</td>
</tr>
<tr>
<td>D_FWrdLevelSel</td>
<td>从不同流水级的转发数据中选择出合适的一个，CMP的num2，如果地址是0，那么应该选择32位0</td>
</tr>
<tr>
<td>E_FWrsLevelSel</td>
<td>从不同流水级的转发数据中选择出合适的一个，供给E级的ALU的SrcA，如果地址是0，那么应该选择32位0</td>
</tr>
<tr>
<td>E_FWrtLevelSel</td>
<td>从不同流水级的转发数据中选择出合适的一个，供给E级的ALU的SrcB，如果地址是0，那么应该选择32位0</td>
</tr>
<tr>
<td>M_FWrtLevelSel</td>
<td>从不同流水级的转发数据中选择出合适的一个，供给M级的DM的DMIn，如果地址是0，那么应该选择32位0</td>
</tr>
</tbody>
</table>
</div>
<p>FU选择信号编码：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>信号</th>
<th>0</th>
<th>1</th>
<th>2</th>
<th>3</th>
<th>4</th>
<th>5</th>
<th>6</th>
<th>7</th>
</tr>
</thead>
<tbody>
<tr>
<td>E_FWSrcSel</td>
<td>PC</td>
<td></td>
<td>EXTOut</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>M_FWSrcSel</td>
<td>PC</td>
<td>ALUOut</td>
<td>EXTOut</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>W_FWSrcSel</td>
<td>PC</td>
<td>ALUOut</td>
<td>EXTOut</td>
<td>DMOut</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>D_FWrsLevelSel</td>
<td>ZERO</td>
<td>D（假转发）</td>
<td>E</td>
<td>M</td>
<td>W（这里不会有，因为被内部转发解决了）</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>D_FWrtLevelSel</td>
<td>ZERO</td>
<td>D（假转发）</td>
<td>E</td>
<td>M</td>
<td>W（这里不会有，因为被内部转发解决了）</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>E_FWrsLevelSel</td>
<td>ZERO</td>
<td></td>
<td>E（假转发）</td>
<td>M</td>
<td>W</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>E_FWrtLevelSel</td>
<td>ZERO</td>
<td></td>
<td>E（假转发）</td>
<td>M</td>
<td>W</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>M_FWrtLevelSel</td>
<td>ZERO</td>
<td></td>
<td></td>
<td>M（假转发）</td>
<td>W</td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
</div>
<h3 id="3-1-Fetch-流水级"><a href="#3-1-Fetch-流水级" class="headerlink" title="3.1 Fetch 流水级"></a>3.1 Fetch 流水级</h3><h4 id="3-1-1-IFU"><a href="#3-1-1-IFU" class="headerlink" title="3.1.1 IFU"></a>3.1.1 IFU</h4><p>IFU跟原来单周期CPU完全一样完全，但是原来在单周期最优雅的设计：将NPC整合进IFU，是没有办法在流水线CPU中体面的实现了，NPC被移至了D级，断绝了整合的可能性。</p>
<p>IFU端口</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>端口</th>
<th>方向</th>
<th>宽度</th>
<th>解释</th>
</tr>
</thead>
<tbody>
<tr>
<td>clk</td>
<td>IN</td>
<td>1</td>
<td>时钟</td>
</tr>
<tr>
<td>reset</td>
<td>IN</td>
<td>1</td>
<td>同步复位信号</td>
</tr>
<tr>
<td>nextPC</td>
<td>IN</td>
<td>32</td>
<td>下一条指令地址</td>
</tr>
<tr>
<td>PC</td>
<td>OUT</td>
<td>32</td>
<td>当前指令地址</td>
</tr>
<tr>
<td>instr</td>
<td>OUT</td>
<td>32</td>
<td>当前指令</td>
</tr>
</tbody>
</table>
</div>
<p>IFU没有控制信号</p>
<h3 id="3-2-Decode-流水级"><a href="#3-2-Decode-流水级" class="headerlink" title="3.2 Decode 流水级"></a>3.2 Decode 流水级</h3><h4 id="3-2-1-DREG"><a href="#3-2-1-DREG" class="headerlink" title="3.2.1 DREG"></a>3.2.1 DREG</h4><p>DREG作为第一级流水线寄存器，保存从F级传入的数据，并输出给D级，供D级使用。</p>
<p><strong>对不起，因为我没有时间写作业了，所以我要开始摆烂了，可能会补，如果P6不难</strong>。</p>
<h4 id="3-2-2-GRF"><a href="#3-2-2-GRF" class="headerlink" title="3.2.2 GRF"></a>3.2.2 GRF</h4><p>只负责读功能。见单周期。</p>
<h4 id="3-2-3-NPC"><a href="#3-2-3-NPC" class="headerlink" title="3.2.3 NPC"></a>3.2.3 NPC</h4><p>见单周期。</p>
<h4 id="3-2-4-CMP"><a href="#3-2-4-CMP" class="headerlink" title="3.2.4 CMP"></a>3.2.4 CMP</h4><p>见单周期。</p>
<h4 id="3-2-5-EXT"><a href="#3-2-5-EXT" class="headerlink" title="3.2.5 EXT"></a>3.2.5 EXT</h4><p>见单周期。</p>
<h4 id="3-2-6-PCMux"><a href="#3-2-6-PCMux" class="headerlink" title="3.2.6 PCMux"></a>3.2.6 PCMux</h4><p>用于选择NPC是采用D_PC还是F_PC</p>
<h4 id="3-2-7-JumpMux"><a href="#3-2-7-JumpMux" class="headerlink" title="3.2.7 JumpMux"></a>3.2.7 JumpMux</h4><p>用于选择NPC跳转的时候，是采用立即数，还是rsOut</p>
<h4 id="3-2-8-D-FWrsLevelMux"><a href="#3-2-8-D-FWrsLevelMux" class="headerlink" title="3.2.8 D_FWrsLevelMux"></a>3.2.8 D_FWrsLevelMux</h4><p>用于选择rsOut要接受哪一个流水级的转发数据（将本级的数据也视为一种转发数据）</p>
<h4 id="3-2-9-D-FWrtLevelMux"><a href="#3-2-9-D-FWrtLevelMux" class="headerlink" title="3.2.9 D_FWrtLevelMux"></a>3.2.9 D_FWrtLevelMux</h4><p>用于选择rtOut要接受哪一个流水级的转发数据（将本级的数据也视为一种转发数据）</p>
<h4 id="3-2-9-D-FWrtLevelMux-1"><a href="#3-2-9-D-FWrtLevelMux-1" class="headerlink" title="3.2.9 D_FWrtLevelMux"></a>3.2.9 D_FWrtLevelMux</h4><h3 id="3-3-Execute-流水级"><a href="#3-3-Execute-流水级" class="headerlink" title="3.3 Execute 流水级"></a>3.3 Execute 流水级</h3><h4 id="3-3-1-EREG"><a href="#3-3-1-EREG" class="headerlink" title="3.3.1 EREG"></a>3.3.1 EREG</h4><p>见上面。</p>
<h4 id="3-3-2-ALU"><a href="#3-3-2-ALU" class="headerlink" title="3.3.2 ALU"></a>3.3.2 ALU</h4><p>见单周期。</p>
<h4 id="3-3-3-SrcBMux"><a href="#3-3-3-SrcBMux" class="headerlink" title="3.3.3 SrcBMux"></a>3.3.3 SrcBMux</h4><p>见单周期。</p>
<h4 id="3-3-4-E-FWSrcMux"><a href="#3-3-4-E-FWSrcMux" class="headerlink" title="3.3.4 E_FWSrcMux"></a>3.3.4 E_FWSrcMux</h4><p>用于选择想其他级转发的数据存储在EREG的那个项中。</p>
<h4 id="3-3-5-E-FWrsLevelMux"><a href="#3-3-5-E-FWrsLevelMux" class="headerlink" title="3.3.5 E_FWrsLevelMux"></a>3.3.5 E_FWrsLevelMux</h4><p>用于选择rsOut要接受哪一个流水级的转发数据（将本级的数据也视为一种转发数据）</p>
<h4 id="3-3-6-E-FWrtLevelMux"><a href="#3-3-6-E-FWrtLevelMux" class="headerlink" title="3.3.6 E_FWrtLevelMux"></a>3.3.6 E_FWrtLevelMux</h4><p>用于选择rtOut要接受哪一个流水级的转发数据（将本级的数据也视为一种转发数据）</p>
<h3 id="3-4-Memory-流水级"><a href="#3-4-Memory-流水级" class="headerlink" title="3.4 Memory 流水级"></a>3.4 Memory 流水级</h3><h4 id="3-4-1-MREG"><a href="#3-4-1-MREG" class="headerlink" title="3.4.1 MREG"></a>3.4.1 MREG</h4><p>见上面。</p>
<h4 id="3-4-2-DM"><a href="#3-4-2-DM" class="headerlink" title="3.4.2 DM"></a>3.4.2 DM</h4><p>见单周期。</p>
<h4 id="3-4-3-M-FWSrcMux"><a href="#3-4-3-M-FWSrcMux" class="headerlink" title="3.4.3 M_FWSrcMux"></a>3.4.3 M_FWSrcMux</h4><p>用于选择想其他级转发的数据存储在MREG的那个项中。</p>
<h4 id="3-4-4-M-FWrtLevelMux"><a href="#3-4-4-M-FWrtLevelMux" class="headerlink" title="3.4.4 M_FWrtLevelMux"></a>3.4.4 M_FWrtLevelMux</h4><p>用于选择rtOut要接受哪一个流水级的转发数据（将本级的数据也视为一种转发数据）</p>
<h3 id="3-5-WriteBack-流水级"><a href="#3-5-WriteBack-流水级" class="headerlink" title="3.5 WriteBack 流水级"></a>3.5 WriteBack 流水级</h3><h4 id="3-5-1-GRFAddMux"><a href="#3-5-1-GRFAddMux" class="headerlink" title="3.5.1 GRFAddMux"></a>3.5.1 GRFAddMux</h4><p>见单周期。</p>
<h4 id="3-5-2-GRFInMux"><a href="#3-5-2-GRFInMux" class="headerlink" title="3.5.2 GRFInMux"></a>3.5.2 GRFInMux</h4><p>见单周期。</p>
<h4 id="3-5-3-W-FWSrcMux"><a href="#3-5-3-W-FWSrcMux" class="headerlink" title="3.5.3 W_FWSrcMux"></a>3.5.3 W_FWSrcMux</h4><p>用于选择想其他级转发的数据存储在WREG的那个项中。</p>
<hr>
<h2 id="四、测试"><a href="#四、测试" class="headerlink" title="四、测试"></a>四、测试</h2><h3 id="4-1-测试样例"><a href="#4-1-测试样例" class="headerlink" title="4.1 测试样例"></a>4.1 测试样例</h3><h4 id="4-2-1-单条指令"><a href="#4-2-1-单条指令" class="headerlink" title="4.2.1 单条指令"></a>4.2.1 单条指令</h4><p>ori测试：</p>
<pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">ori $t0, $t0, 1
ori $t1, $t1, 0
ori $t3, $t3, 0x7fff
ori $t4, $t3, 0xffff<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>addu测试：</p>
<pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">ori $t0, $t0, 2
ori $t1, $t1, 0xffff
addu $t2, $t0, $t0
addu $t3, $t1, $t1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>subu测试：</p>
<pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">ori $t0, $t0, 2
ori $t1, $t1, 0xffff
subu $t2, $t0, $t0
subu $t3, $t1, $t1
subu $t4, $t1, $t0
subu $t4, $t0, $t1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>lui测试：</p>
<pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">lui $t0, 0x7fff
ori $t0, $t0, 0x777f<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>beq测试：</p>
<pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">#三次跳转
ori $t3, $t4, 1
beq $3, $t0, A
ori $t1, $t1, 0xffff
A:
beq $0, $t0, B
lui $t1, 0xffff
C:
ori $t1, $t1, 1
lui $t0, 1
B:
beq $t0, $0, C
lui $t2, 0xffff
//后跳
beq $t3, $t0, A
ori $t1, $t1, 0xffff
ori $t2, $t2, 0xffff
A:
lui $t1, 0xffff
//不跳
beq $3, $t0, A
nop
A:
beq $0, $t0, B
nop
C:
lui $t0, 1
B:
beq $t0, $0, C
nop
//前跳
beq $3, $t0, A
nop
B:
lui $t0, 1
A:
beq $0, $t0, B
nop
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>j，jal，jr测试：</p>
<pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">jal A
ori $s1, $s1, 0x1111
addu $ra, $ra, $t2
ori $s1, $s1, 0x2222
A:
lui $t1, 200

jal A
ori $t0, $t0, 0x1111
subu $t1, $t1, $t0
ori $t2, $t2, 0x1111
beq $t2, $t2, B
nop
A:
jr $ra
addu $t3, $t0, $t0
B:<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>sw，lw测试：</p>
<pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">ori $t0, $t0, 4 #t0 = 4
addu $t1, $t0, $t0 # t1 = 8
subu $t2, $t0, $t1 # t2 = -4
addu $t3, $t2, $t2 #t3 = -8
subu $t4, $t0, $t3 #t4 = c
sw $t4, 16($t4)  # add = 1c
sw $t3, -4($t1) # add = 4
lw $t5, 16($t4) 
lw $t6, -4($t1)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="4-2-2-弱测"><a href="#4-2-2-弱测" class="headerlink" title="4.2.2 弱测"></a>4.2.2 弱测</h4><p>这是课16进制代码对应的MIPS指令，最后那个beq是死循环，据叶哥哥说，是为了防止“CPU跑飞了”的现象出现，大家不用理会。</p>
<pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">ori $28, $0, 0x0
ori $29, $0, 0x0
ori $1, $7, 0x1010
lw $10, 0x0($0)
sw $1, 0x0($0)
lui $2, 0x8723
ori $3, $0, 0x7856
lui $4, 0x85ff
ori $5, $0, 0x1
lui $6, 0xffff
ori $7, $7, 0xffff
addu $1, $1, $2
addu $9, $1, $3
subu $8, $1, $2
subu $0, $7, $0
nop
nop
nop
nop
nop
beq $28, $17, label1
nop
j label2 
nop
label1: beq $1, $2, label2
nop
ori $2, $0, 0xc
nop
nop
nop
jal label3 
sw $1, 0x0($2)
j label2 
addu $1, $1, $2
label3:addu $1, $1, $2
addu $1, $1, $2
addu $1, $1, $2
sw $31, 0x0($2)
lw $1, 0x0($2)
nop
nop
nop
jr $1
sw $31, 0x0($2)
label2: beq $0, $0, label2
nop<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="4-2-3-强测"><a href="#4-2-3-强测" class="headerlink" title="4.2.3 强测"></a>4.2.3 强测</h4><p>测试思想：</p>
<p>我认为，测试的本质是对控制信号的测试，而在AT法里，其实就是对AT中间变量的检测，所以每次测试的时候，考虑转发的接受者和转发的提供者。转发者考虑的是rsTuse和rtTuse，只需要<strong>简单交换</strong>两个源寄存器即可。然后对不同类的指令进行枚举，就可以完成转发接受者的测试。对于转发的提供者。因为每个阶段的Tnew是不一样的，所以要进行三个阶段的枚举，其间插入nop即可。对于不同类的指令再次进行枚举，总结起来就是两个双重for循环：</p>
<p>对于转发接受者</p>
<ul>
<li>交换源寄存器</li>
<li>枚举不同类型指令</li>
</ul>
<p>对于转发提供者</p>
<ul>
<li>枚举位于不同流水级的情况</li>
<li>枚举不同类型的指令</li>
</ul>
<p>测试0寄存器转发：</p>
<pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">ori $0, $0, 1
addu $t1, $0, $0

ori $0, $0, 1
addu $0, $t1, $0<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>测试E级lui转发功能，不能阻塞</p>
<pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">A:
lui $t0, 200
beq $t0, $0, A

B:
lui $t0, 200
beq $0, $t0, B<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>测试E级jal转发功能，不能阻塞</p>
<pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">jal label1
addu $ra $ra $t2
ori $s1 $s1 0x1111
ori $s1 $s1 0x2222
label1:
jr $ra<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>测试M级addu，ori，subu功能</p>
<pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">A:
ori $t0, $t0, 1
beq $t0, $0, A
addu $t1, $t0, $t0
beq $t1, $0, A
subu $t2, $t1, $t0
beq $0, $t2, A<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>测试M级lw功能</p>
<pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">A:
lui $t0, 100
lui $t1, 200
sw $t0, 0($0)
sw $t1, 4($0)
lw $t1, 0($0)
beq $0, $t1, A<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><strong>麻了，写不完了，鸽了。</strong></p>
<hr>
<h2 id="4-2-测试TLE"><a href="#4-2-测试TLE" class="headerlink" title="4.2 测试TLE"></a>4.2 测试TLE</h2><p>这种情况是存在的，而且我已经与他搏斗了两天一夜了。造成这种情况除了要检查循环以外。最重要的是是否存在跳变现象，也就是说，如果组合逻辑存在冲突，那么就会造成<strong>暂停现象</strong>，在ISim上表现为没有跑够周期就停了，然后不能增加中间变量，电脑开始疯狂运转，嗡嗡响。组合逻辑的冲突比如这样，额，我本来想举一个简答的例子的，但是发现好像没法举。构造不出来，给大家看我复杂的CPU也不太现实，所以就不举例了。我描述一下，就是我的beq设计的时候，如果CMPOut不等于0，那么我就视这条指令为nop，相关触发的信号都是nop的信号，但是nop有一个问题就是它的比较结果CMPOut是1（也是因为我的一个傻蛋转发设计，觉得要是没得转或者不需要转，就转发0，结果两个0比较是1），那么这条指令又由nop变为beq了（组合逻辑很快的），但是beq的CMPOut又是0，所以这条指令就又变成nop了，所以就会一直反复横跳，造成了TLE。</p>
<p>如果想要de这种bug，打开ISim，打到塞住那里，然后打开objects面板，就会发现里面有的数据会来回跳动，找到问题所在就可以了，但是在这种状态下是没有办法添加中间变量到观测窗口的，可以点击右上角有一个break按钮，就可以跳出模拟，然后就可以添加变量了。</p>
<h2 id="4-3-测试工具"><a href="#4-3-测试工具" class="headerlink" title="4.3 测试工具"></a>4.3 测试工具</h2><h2 id="五、代码风格"><a href="#五、代码风格" class="headerlink" title="五、代码风格"></a>五、代码风格</h2><h3 id="5-1-译码器风格"><a href="#5-1-译码器风格" class="headerlink" title="5.1 译码器风格"></a>5.1 译码器风格</h3><h4 id="5-1-1-指令驱动型"><a href="#5-1-1-指令驱动型" class="headerlink" title="5.1.1 指令驱动型"></a>5.1.1 指令驱动型</h4><p>指令驱动型就是为每个指令赋予一个参数，根据参数的不同决定控制信号，我P4的时候采用的就是这种方法，大概长这样</p>
<pre class="line-numbers language-verilog" data-language="verilog"><code class="language-verilog"><span class="token function">case</span><span class="token punctuation">(</span>order<span class="token punctuation">)</span>
    nop<span class="token punctuation">:</span> <span class="token keyword">begin</span>
        NPCOP <span class="token operator">=</span> NPCOP_NORMAL<span class="token punctuation">;</span>
        RegWrite <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
        GRFOP <span class="token operator">=</span> GRFOP_FULL<span class="token punctuation">;</span>
        EXTOP <span class="token operator">=</span> EXTOP_ZE16<span class="token punctuation">;</span>
        ALUOP <span class="token operator">=</span> ALUOP_ADD<span class="token punctuation">;</span>
        CMPOP <span class="token operator">=</span> CMPOP_EQ<span class="token punctuation">;</span>
        MemWrite <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
        DMOP <span class="token operator">=</span> DMOP_W<span class="token punctuation">;</span>
        RegInSel <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
        RegAdd3Sel <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
        SrcBSel <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
        BranchSel <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token keyword">end</span>

    sll<span class="token punctuation">:</span> <span class="token keyword">begin</span>
        <span class="token comment">//Load</span>
        RegWrite <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
        RegAdd3Sel <span class="token operator">=</span> RegAdd3Sel_rd<span class="token punctuation">;</span>
        RegInSel <span class="token operator">=</span> RegInSel_ALUOut<span class="token punctuation">;</span>
        GRFOP <span class="token operator">=</span> GRFOP_FULL<span class="token punctuation">;</span>
        DMOP <span class="token operator">=</span> DMOP_W<span class="token punctuation">;</span>
        <span class="token comment">//Caculate</span>
        SrcBSel <span class="token operator">=</span> SrcBSel_RegOut2<span class="token punctuation">;</span>
        ALUOP <span class="token operator">=</span> ALUOP_LLEFT<span class="token punctuation">;</span>
    <span class="token keyword">end</span>
<span class="token keyword">endcase</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>可以看到，加指令还是很方便的，只要新给一个参数，然后只要一条一条的考虑控制信号就可以了，但是缺点就是太长了。对于每个指令，都需要考虑一遍所有信号，在一个单周期CPU中，一个指令我要考虑的信号有13项，每个指令都要写将近10条（默认时nop），加15条就要150行，看起来也不方便（但是过P4还是很香的）。</p>
<h4 id="5-1-2-控制信号驱动型"><a href="#5-1-2-控制信号驱动型" class="headerlink" title="5.1.2 控制信号驱动型"></a>5.1.2 控制信号驱动型</h4><p>吴佬采用的就是这种办法，每个指令都用一个wire值来表示，可以很好的对指令进行分类（对于想分为一类的信号，就是把他们并起来就可以了）。很好的分类可以避免漏填控制信号，比如说加addu，只关注令ALUOP为ADD了，忘了写寄存器了，但是只要把addu归为cal_r类，然后让cal_r来控制控制信号，就可以很好避免忘写的尴尬。还有一个很好的优点就是代码量少，而且指令越多，相对代码量越少。</p>
<p>但是缺点也很明显，就是如果译码模块想要与其他模块通信，就必须一个指令一个端口，这样端口就过长了，比如这么长</p>
<pre class="line-numbers language-verilog" data-language="verilog"><code class="language-verilog"><span class="token keyword">module</span> _CU <span class="token punctuation">(</span>
    <span class="token keyword">input</span> <span class="token punctuation">[</span><span class="token number">31</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> instr<span class="token punctuation">,</span>
    <span class="token comment">// decode</span>
    <span class="token keyword">output</span> <span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> rs_addr<span class="token punctuation">,</span>
    <span class="token keyword">output</span> <span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> rt_addr<span class="token punctuation">,</span>
    <span class="token keyword">output</span> <span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> rd_addr<span class="token punctuation">,</span>
    <span class="token keyword">output</span> <span class="token punctuation">[</span><span class="token number">15</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> imm<span class="token punctuation">,</span>
    <span class="token keyword">output</span> <span class="token punctuation">[</span><span class="token number">25</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> addr<span class="token punctuation">,</span>
    <span class="token comment">// classify</span>
    <span class="token keyword">output</span> load<span class="token punctuation">,</span>
    <span class="token keyword">output</span> store<span class="token punctuation">,</span>
    <span class="token keyword">output</span> calc_r<span class="token punctuation">,</span>
    <span class="token keyword">output</span> calc_i<span class="token punctuation">,</span>
    <span class="token keyword">output</span> shiftS<span class="token punctuation">,</span>
    <span class="token keyword">output</span> shiftV<span class="token punctuation">,</span>
    <span class="token keyword">output</span> branch<span class="token punctuation">,</span>
    <span class="token keyword">output</span> j_r<span class="token punctuation">,</span>
    <span class="token keyword">output</span> j_addr<span class="token punctuation">,</span>
    <span class="token keyword">output</span> j_l<span class="token punctuation">,</span>
    <span class="token comment">// signals</span>
    <span class="token keyword">output</span> <span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> Br<span class="token punctuation">,</span>
    <span class="token keyword">output</span> <span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> B_type<span class="token punctuation">,</span>
    <span class="token keyword">output</span> EXTOp<span class="token punctuation">,</span>

    <span class="token keyword">output</span> <span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> ALUControl<span class="token punctuation">,</span>
    <span class="token keyword">output</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> ALUASrc<span class="token punctuation">,</span>
    <span class="token keyword">output</span> <span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> ALUBSrc<span class="token punctuation">,</span>

    <span class="token keyword">output</span> <span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> DMType<span class="token punctuation">,</span>
    <span class="token keyword">output</span> DMWr<span class="token punctuation">,</span>

    <span class="token keyword">output</span> <span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> RFDst<span class="token punctuation">,</span>
    <span class="token keyword">output</span> RFWr<span class="token punctuation">,</span>
    <span class="token keyword">output</span> <span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> RFWDSrc
<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>与之相比，指令驱动型的端口</p>
<pre class="line-numbers language-verilog" data-language="verilog"><code class="language-verilog"><span class="token keyword">module</span> CORE
	<span class="token punctuation">(</span>
		<span class="token keyword">input</span> <span class="token punctuation">[</span><span class="token number">31</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> instr<span class="token punctuation">,</span>
		<span class="token keyword">output</span> <span class="token keyword">reg</span> <span class="token punctuation">[</span><span class="token number">6</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> order
	<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="5-1-3-我的译码风格"><a href="#5-1-3-我的译码风格" class="headerlink" title="5.1.3 我的译码风格"></a>5.1.3 我的译码风格</h4><p>我的代码风格本质还是指令驱动型，但是对于其缺点：就是代码量太长，我觉得有了一个还算看得过去的解决，就是利用case语句让多个指令对应一个信号，而不是一个指令对应一整套信号，有下例：</p>
<pre class="line-numbers language-verilog" data-language="verilog"><code class="language-verilog"><span class="token comment">/********** Stage M **********/</span>
<span class="token keyword">wire</span> <span class="token punctuation">[</span><span class="token number">6</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> M_order<span class="token punctuation">;</span>
CORE M_core
    <span class="token punctuation">(</span>
        <span class="token punctuation">.</span><span class="token function">instr</span><span class="token punctuation">(</span>M_instr<span class="token punctuation">)</span><span class="token punctuation">,</span>
        <span class="token punctuation">.</span><span class="token function">order</span><span class="token punctuation">(</span>M_order<span class="token punctuation">)</span>
    <span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token important">always @</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">)</span> <span class="token keyword">begin</span>
     <span class="token comment">//about DMEn</span>
    <span class="token function">case</span><span class="token punctuation">(</span>M_order<span class="token punctuation">)</span>
        <span class="token constant">`sw</span> <span class="token punctuation">:</span> DMEn <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
        <span class="token keyword">default</span> <span class="token punctuation">:</span> DMEn <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token keyword">endcase</span>

    <span class="token comment">//about DMOP</span>
    <span class="token function">case</span><span class="token punctuation">(</span>M_order<span class="token punctuation">)</span>
        <span class="token constant">`sw</span><span class="token punctuation">,</span> <span class="token constant">`lw</span> <span class="token punctuation">:</span> DMOP <span class="token operator">=</span> DMOP_W<span class="token punctuation">;</span>
        <span class="token keyword">default</span> <span class="token punctuation">:</span> DMOP <span class="token operator">=</span> DMOP_W<span class="token punctuation">;</span>
    <span class="token keyword">endcase</span>
<span class="token keyword">end</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>可以看到，三个信号对应三个case语句，即使指令的数目再增加，因为信号的数目是不会变的（信号的数目取决于CPU数据通路的功能控制），所以代码行数就被限制住了。</p>
<p>还有一个三目运算符的写法与之类似，就不列举了。</p>
<h3 id="5-2-顶层只有模块实例化"><a href="#5-2-顶层只有模块实例化" class="headerlink" title="5.2 顶层只有模块实例化"></a>5.2 顶层只有模块实例化</h3><p>在mips.v中文件，我看到吴佬代码里有用assign语句结合三目运算符实现MUX的语句，我个人还是偏爱写一个MUX，然后在顶层模块实例化。只能说是个人习惯，并没有优劣之分。</p>
<h3 id="5-3-signed"><a href="#5-3-signed" class="headerlink" title="5.3 $signed"></a>5.3 $signed</h3><p>涉及到sign的我目前考虑到有两个地方，一个是CMP中比较，一个是ALU中右移操作，这样处理应该是没有问题的：</p>
<pre class="line-numbers language-verilog" data-language="verilog"><code class="language-verilog">LT<span class="token punctuation">:</span>
	CMPOut <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token property">$signed</span><span class="token punctuation">(</span>num1<span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token property">$signed</span><span class="token punctuation">(</span>num2<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	
<span class="token keyword">wire</span> <span class="token punctuation">[</span><span class="token number">31</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> res_sra <span class="token operator">=</span> <span class="token property">$signed</span><span class="token punctuation">(</span>A<span class="token punctuation">)</span> <span class="token operator">&gt;&gt;&gt;</span> B<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="5-4-case"><a href="#5-4-case" class="headerlink" title="5.4 case"></a>5.4 case</h3><pre class="line-numbers language-none"><code class="language-none">case(W_order)
    `addu, `subu, `ori, `lw, `lui, `jal : GRFEn = 1;
    default : GRFEn = 0;
endcase<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p><strong>case的情况是可以用逗号连接的。</strong></p>
<hr>
<h2 id="六、思考题"><a href="#六、思考题" class="headerlink" title="六、思考题"></a>六、思考题</h2><h3 id="6-1-在采用本节所述的控制冒险处理方式下，PC-的值应当如何被更新？请从数据通路和控制信号两方面进行说明。"><a href="#6-1-在采用本节所述的控制冒险处理方式下，PC-的值应当如何被更新？请从数据通路和控制信号两方面进行说明。" class="headerlink" title="6.1  在采用本节所述的控制冒险处理方式下，PC 的值应当如何被更新？请从数据通路和控制信号两方面进行说明。"></a>6.1  在采用本节所述的控制冒险处理方式下，PC 的值应当如何被更新？请从数据通路和控制信号两方面进行说明。</h3><p>PC的值由有组合逻辑模块NPC负责产生，NPC的输入是PC值、立即数和寄存器数据，与单周期不同的是，PC在不同的流水线上是不同的，我们的PC有两个来源，一个是F_PC，另一个是D_PC，当非跳转分支指令时，NPC的来源是F_PC，当是跳转分支指令时，NPC的来源是D_PC。这是因为F_PC是D_PC的后一条地址，我们在普通情况，想要的是F_PC的下一条地址，所以是F_PC+4。D_PC+4一般就是F_PC，如果是D_PC+4就是把F_instr发送了两遍，是错误的。对于跳转分支指令，要是用F_PC，就相当于用了D_PC + 4，显然是错误的。</p>
<p>对于数据通路，需要新加入新的MUX来选择NPC的输入PC是什么，输入是F_PC和D_PC。</p>
<p>对于控制信号，需要产生一个MUX选择信号来操控MUX，这个信号在非分支跳转指令的时候置1，其他时候置0。</p>
<h3 id="6-2-对于-jal-等需要将指令地址写入寄存器的指令，为什么需要回写-PC-8？"><a href="#6-2-对于-jal-等需要将指令地址写入寄存器的指令，为什么需要回写-PC-8？" class="headerlink" title="6.2 对于 jal 等需要将指令地址写入寄存器的指令，为什么需要回写 PC+8？"></a>6.2 对于 jal 等需要将指令地址写入寄存器的指令，为什么需要回写 PC+8？</h3><p>因为延迟槽的存在，所以跳转分支指令的下一条指令一定会被执行，如果还像原来一样，写的是D_PC+4，那么再跳回的时候，就又会执行一遍jal的下一条指令，所以这时我们不希望见到的。所以我们写入PC+8，就可以跳回第一条没有被执行的指令。</p>
<h3 id="6-3-为什么所有的供给者都是存储了上一级传来的各种数据的流水级寄存器，而不是由-ALU-或者-DM-等部件来提供数据？"><a href="#6-3-为什么所有的供给者都是存储了上一级传来的各种数据的流水级寄存器，而不是由-ALU-或者-DM-等部件来提供数据？" class="headerlink" title="6.3 为什么所有的供给者都是存储了上一级传来的各种数据的流水级寄存器，而不是由 ALU 或者 DM 等部件来提供数据？"></a>6.3 为什么所有的供给者都是存储了上一级传来的各种数据的<strong>流水级寄存器</strong>，而不是由 ALU 或者 DM 等部件来提供数据？</h3><p>这是因为这与流水线的设计思想是相冲突的，流水线说的是，当流水线达到稳定的时候，每个周期都可以执行完一条指令。他比单周期CPU的优势在于，单周期CPU的周期要长到可以使每个阶段串行地都执行完，而流水线CPU的周期只要比最长阶段的执行时间长就可以了。所以影响流水线效率的就是最长的执行阶段，而如果从每阶流水线的末端获得转发数据，就跟把转发供应阶段与转发需求阶段串联了一样。我们举一个例子，这是各个阶段的时间（我编的）：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>F</th>
<th>D</th>
<th>E</th>
<th>M</th>
<th>W</th>
</tr>
</thead>
<tbody>
<tr>
<td>50</td>
<td>100</td>
<td>100</td>
<td>150</td>
<td>100</td>
</tr>
</tbody>
</table>
</div>
<p>如果此时D阶段需要E的ALU计算的结果，假设数据刚进入D和E级（即刚刚有效沿到来），我们要ALUOut，所以需要100s等待其出结果，然后过了100s后结果出来了，可以转发给D级了，但是此时还没完，D拿到了这个数据，需要对其进行处理，所以又花了100s。也就是说，为了保证正确性，我们的周期最少是200s，而其实150s就够了（即最大周期M150s）。只是因为我们进行了这个错误的设计。</p>
<h3 id="6-4-如果不采用已经转发过的数据，而采用上一级中的原始数据，会出现怎样的问题？试列举指令序列说明这个问题。"><a href="#6-4-如果不采用已经转发过的数据，而采用上一级中的原始数据，会出现怎样的问题？试列举指令序列说明这个问题。" class="headerlink" title="6.4 如果不采用已经转发过的数据，而采用上一级中的原始数据，会出现怎样的问题？试列举指令序列说明这个问题。"></a>6.4 如果不采用已经转发过的数据，而采用上一级中的原始数据，会出现怎样的问题？试列举指令序列说明这个问题。</h3><pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">ori $t0, $t0, 1
addu $t1, $t0, $t0<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>如果不采用转发数据，addu拿到的$t0还是从GRF中读出的，那么此时$t0还是0，所以会造成错误。</p>
<h3 id="6-5-我们为什么要对-GPR-采用内部转发机制？如果不采用内部转发机制，我们要怎样才能解决这种情况下的转发需求呢？"><a href="#6-5-我们为什么要对-GPR-采用内部转发机制？如果不采用内部转发机制，我们要怎样才能解决这种情况下的转发需求呢？" class="headerlink" title="6.5 我们为什么要对 GPR 采用内部转发机制？如果不采用内部转发机制，我们要怎样才能解决这种情况下的转发需求呢？"></a>6.5 我们为什么要对 GPR 采用内部转发机制？如果不采用内部转发机制，我们要怎样才能解决这种情况下的转发需求呢？</h3><p>内部转发解决的是W存有D读寄存器的数据的情况，通过转发，可以保证CPU的正确性。如果不采用内部转发机制，还是需要解决这个问题的。据说可以用<strong>半写半读</strong>的机制解决，我理解的应该是GRF是下降沿写入数据，而其他寄存器都是上升沿写入数据，这样就可以实现在一个周期中既写又读。还可以利用外部转发，就像其他的转发一样，通过MUX选择是否进行转发和转发哪个数据。</p>
<h3 id="6-6-为什么-0-号寄存器需要特殊处理？"><a href="#6-6-为什么-0-号寄存器需要特殊处理？" class="headerlink" title="6.6 为什么 0 号寄存器需要特殊处理？"></a>6.6 为什么 0 号寄存器需要特殊处理？</h3><p>因为0号寄存器是没有办法被写入的。这导致无论是怎样去读，读出来的数据都是0。于此同时，对于写寄存器指令，即使目的寄存器是0号，但是写数据依然会产生，但是此时就不能被转发了，以上文举例：</p>
<pre class="line-numbers language-none"><code class="language-none">ori $0, $0, 1
addu $t1, $0, $0<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>ALUOut的结果还是1，但是这个1是不能被转发的，不然就会给t1寄存器赋值。这是不对的。</p>
<h3 id="6-7-什么是“最新产生的数据”？"><a href="#6-7-什么是“最新产生的数据”？" class="headerlink" title="6.7 什么是“最新产生的数据”？"></a>6.7 什么是“最新产生的数据”？</h3><p>就是靠前的流水级产生的数据，比如E产生的数据比W新，这是因为靠前的流水线上含有程序后面的指令。新产生的数据会掩盖后产生的数据。</p>
<h3 id="6-8-在-AT-方法讨论转发条件的时候，只提到了“供给者需求者的-A-相同，且不为-0”，但在-CPU-写入-GRF-的时候，是有一个-we-信号来控制是否要写入的。为何在-AT-方法中不需要特判-we-呢？为了用且仅用-A-和-T-完成转发，在翻译出-A-的时候，要结合-we-做什么操作呢？"><a href="#6-8-在-AT-方法讨论转发条件的时候，只提到了“供给者需求者的-A-相同，且不为-0”，但在-CPU-写入-GRF-的时候，是有一个-we-信号来控制是否要写入的。为何在-AT-方法中不需要特判-we-呢？为了用且仅用-A-和-T-完成转发，在翻译出-A-的时候，要结合-we-做什么操作呢？" class="headerlink" title="6.8 在 AT 方法讨论转发条件的时候，只提到了“供给者需求者的 A 相同，且不为 0”，但在 CPU 写入 GRF 的时候，是有一个 we 信号来控制是否要写入的。为何在 AT 方法中不需要特判 we 呢？为了用且仅用 A 和 T 完成转发，在翻译出 A 的时候，要结合 we 做什么操作呢？"></a>6.8 在 AT 方法讨论转发条件的时候，只提到了“供给者需求者的 A 相同，且不为 0”，但在 CPU 写入 GRF 的时候，是有一个 we 信号来控制是否要写入的。为何在 AT 方法中不需要特判 we 呢？为了<strong>用且仅用</strong> A 和 T 完成转发，在翻译出 A 的时候，要结合 we 做什么操作呢？</h3><p>因为在构造A的时候，就已经考虑了写使能的问题了。我们是这样构造A的：</p>
<p>关于A1的构造：</p>
<ul>
<li>如果指令需要利用rsOUt，则A1是rs，否则是0</li>
<li>0的情况对应有两种，一个是rs真的是0，一个是指令不需要利用rsOut（比如jal）</li>
</ul>
<p>对于A2的构造：</p>
<ul>
<li>如果指令需要利用rtOUt，则A1是rt，否则是0</li>
<li>0的情况对应有两种，一个是rt真的是0，一个是指令不需要利用rtOut（比如jal，lw）</li>
</ul>
<p>对于A3的构造：</p>
<ul>
<li>如果指令的写地址是rt，那么A3就是rt</li>
<li>如果指令的写地址是rd，那么A3就是rd</li>
<li>如果指令是link操作，那么A3就是31</li>
<li>如果不是写指令，那么A3就是0</li>
<li>A3是0对应两种，一个是写指令的地址本身就是0，一个是不是写指令</li>
</ul>
<h3 id="6-9-在本实验中你遇到了哪些不同指令类型组合产生的冲突？你又是如何解决的？相应的测试样例是什么样的？"><a href="#6-9-在本实验中你遇到了哪些不同指令类型组合产生的冲突？你又是如何解决的？相应的测试样例是什么样的？" class="headerlink" title="6.9 在本实验中你遇到了哪些不同指令类型组合产生的冲突？你又是如何解决的？相应的测试样例是什么样的？"></a>6.9 在本实验中你遇到了哪些不同指令类型组合产生的冲突？你又是如何解决的？相应的测试样例是什么样的？</h3><p>测试思想：</p>
<p>我认为，测试的本质是对控制信号的测试，而在AT法里，其实就是对AT中间变量的检测，所以每次测试的时候，考虑转发的接受者和转发的提供者。转发者考虑的是rsTuse和rtTuse，只需要<strong>简单交换</strong>两个源寄存器即可。然后对不同类的指令进行枚举，就可以完成转发接受者的测试。对于转发的提供者。因为每个阶段的Tnew是不一样的，所以要进行三个阶段的枚举，其间插入nop即可。对于不同类的指令再次进行枚举，总结起来就是两个双重for循环：</p>
<p>对于转发接受者</p>
<ul>
<li>交换源寄存器</li>
<li>枚举不同类型指令</li>
</ul>
<p>对于转发提供者</p>
<ul>
<li>枚举位于不同流水级的情况</li>
<li>枚举不同类型的指令</li>
</ul>
<hr>
<h2 id="七、上机"><a href="#七、上机" class="headerlink" title="七、上机"></a>七、上机</h2><h3 id="7-1-上机题目回顾"><a href="#7-1-上机题目回顾" class="headerlink" title="7.1 上机题目回顾"></a>7.1 上机题目回顾</h3><p>swc，就是判断SrcB有奇数个0，还是偶数个0，如果是奇数个0，那么就循环左移SrcA，SrcB[4:0]位。如果是偶数个0，那么就循环右移SrcA，SrcB[4:0]位。循环的写法类似这样（给a循环右移b位，赋给c）</p>
<pre class="line-numbers language-verilog" data-language="verilog"><code class="language-verilog"><span class="token keyword">module</span> <span class="token function">ALU</span><span class="token punctuation">(</span>
	<span class="token keyword">input</span> <span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> a<span class="token punctuation">,</span>
	<span class="token keyword">input</span> <span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> b<span class="token punctuation">,</span>
	<span class="token keyword">output</span> <span class="token keyword">reg</span> <span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> c 
	<span class="token punctuation">)</span><span class="token punctuation">;</span>

	<span class="token keyword">integer</span> i<span class="token punctuation">;</span>

    <span class="token important">always @</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">)</span> <span class="token keyword">begin</span>
        c <span class="token operator">=</span> a<span class="token punctuation">;</span>
        <span class="token function">for</span><span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> b<span class="token punctuation">;</span> i <span class="token operator">=</span> i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span>
        	c <span class="token operator">=</span> <span class="token operator">{</span>c<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> c<span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">:</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">}</span><span class="token punctuation">;</span>
    <span class="token keyword">end</span>

<span class="token keyword">endmodule</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>bonall，首先进行链接，如果num1和num2是相反数，那么就进行16位立即数跳转，如果不是，那么就<strong>清空延迟槽</strong>。之前没有想过怎样清空延迟槽，考场想的是当bonall进入E级后，产生一个清空信号，这个信号会连接到DREG的reset端，然后就把在D级的延迟槽指令变成nop了，完成了清除。不能bonall在D级的时候就产生这个信号，因为阻塞会导致这个想法有bug。</p>
<p>lhogez，从DM中取出一个半字，然后判断这个半字中是1多还是0多，1多就执行存储lh操作，0多就执行往31号寄存器存PC + 4（好像是这个，不知道为啥不是PC + 8），这个半字，或者字节读出写入，都是要封装到DM中的，具体方法看吴佬代码，判断信号也在DM中比较简洁。然后这种判断写，可以用无脑转发解决。吴佬采用的方法我觉得繁琐了，但是我没有写出来，所以不能确定我的想法是不是正确的（杰哥评价是“太过激进了”，我深以为然）。</p>
<h3 id="7-2-反思"><a href="#7-2-反思" class="headerlink" title="7.2 反思"></a>7.2 反思</h3><p>确实自己做的CPU不够好，这篇文章的CPU有大量的缺点，其中最大的缺点就是嵌套CORE，然后在CU，FU，SU的修改也让我精疲力竭。我现在觉得有这么几个修改方向：</p>
<ul>
<li>增加一个4位的flag，让其流水，flag是为了当<strong>条件指令</strong>出现时，不再大幅修改数据通路</li>
<li>让CORE结构拥有flag端口。</li>
<li>将BasicCore、FUCORE、SUCORE合并为一个，要不然考试的时候改的太慢。</li>
<li>将流水线分级模块化，不然400行的mips顶层考试翻得太慢。</li>
<li>思考有没有更符合我性格和特质的CU，FU，SU设计方法。</li>
<li>统一流水线寄存器的规格，不再分别写模块，统一模块，而且尽量多流水数据，避免考试的时候修改。</li>
</ul>
<h3 id="7-3-一个想法"><a href="#7-3-一个想法" class="headerlink" title="7.3 一个想法"></a>7.3 一个想法</h3><p>lw或者是<strong>条件写指令</strong>的难搞之处是Tnew太大，经常造成堵塞或者其他麻烦，如果DM的读和写功能分开（GRF就分开了），让DM的读功能出现在D流水级，就可以减少CPU的CPI。</p>
<hr>
<h2 id="八、写在后面的话"><a href="#八、写在后面的话" class="headerlink" title="八、写在后面的话"></a>八、写在后面的话</h2><p>流水线真的是得到了很多人的帮助，所以可能鸣谢不全（我忘了之类的），总之谢谢你们（顺序就我想起来谁算谁）：</p>
<ul>
<li>叶哥哥：解决了TLE的调试问题</li>
<li>lc哥哥还有身边另一个助教哥哥：人外有人，天外有天，成功教我做人</li>
<li>ysy：北航最棒的男人，当之无愧，设计精神榜样</li>
<li>cjj：不厌其烦教我条件写，让我想出了无脑转发理论的补丁。</li>
<li>ghy：集中式译码的神，成功打开我新视野。</li>
<li>ccy：温柔的人。</li>
</ul>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/S3%E8%AF%BE%E4%B8%8A/" rel="tag"><i class="fa fa-tag"></i> S3课上</a>
              <a href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90/" rel="tag"><i class="fa fa-tag"></i> 计算机组成</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/posts/50c7e0e6/" rel="prev" title="计算机组成-MIPS高阶">
      <i class="fa fa-chevron-left"></i> 计算机组成-MIPS高阶
    </a></div>
      <div class="post-nav-item">
    <a href="/posts/fc8b68d4/" rel="next" title="计算机组成-HDLBits题解">
      计算机组成-HDLBits题解 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          
<script src="https://utteranc.es/client.js"
        repo="Thysrael/blog-comment"
        issue-term="title"
        theme="github-light"
        crossorigin="anonymous"
        async>
</script>

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%80%E3%80%81%E8%AE%BE%E8%AE%A1%E6%83%B3%E6%B3%95"><span class="nav-text">一、设计想法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-1-%E6%88%91%E7%9A%84CPU%E7%9A%84%E6%95%B4%E4%BD%93%E6%9E%B6%E6%9E%84"><span class="nav-text">1.1 我的CPU的整体架构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-2-%E4%BB%8E%E5%8D%95%E5%91%A8%E6%9C%9F%E5%88%B0%E6%B5%81%E6%B0%B4%E7%BA%BF"><span class="nav-text">1.2 从单周期到流水线</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-2-1-%E4%BF%AE%E6%94%B9%E5%8E%9F%E5%8D%95%E5%91%A8%E6%9C%9FCPU"><span class="nav-text">1.2.1 修改原单周期CPU</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-2-2-%E6%B5%81%E6%B0%B4%E7%BA%BF%E5%AF%84%E5%AD%98%E5%99%A8"><span class="nav-text">1.2.2 流水线寄存器</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-2-3-%E5%8A%A0%E5%85%A5%E9%98%BB%E5%A1%9E%E5%88%B7%E6%96%B0%E5%8A%9F%E8%83%BD"><span class="nav-text">1.2.3 加入阻塞刷新功能</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-2-4-%E5%8A%A0%E5%85%A5%E8%BD%AC%E5%8F%91%E5%8A%9F%E8%83%BD"><span class="nav-text">1.2.4 加入转发功能</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-3-%E6%80%9D%E8%80%83%E6%B5%81%E6%B0%B4%E7%BA%BFCPU%E7%9A%84%E4%B8%80%E4%B8%AA%E8%A7%92%E5%BA%A6"><span class="nav-text">1.3 思考流水线CPU的一个角度</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-4-%E5%AF%B9%E8%AF%91%E7%A0%81%E6%96%B9%E5%BC%8F%E7%9A%84%E8%AE%A8%E8%AE%BA"><span class="nav-text">1.4 对译码方式的讨论</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-4-1-%E9%9B%86%E4%B8%AD%E5%BC%8F%E8%AF%91%E7%A0%81"><span class="nav-text">1.4.1 集中式译码</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-4-2-%E5%88%86%E5%B8%83%E5%BC%8F%E8%AF%91%E7%A0%81"><span class="nav-text">1.4.2 分布式译码</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-4-3-%E6%88%91%E7%9A%84%E5%B0%9D%E8%AF%95"><span class="nav-text">1.4.3 我的尝试</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-4-4-%E9%83%AD%E5%93%A5%E7%9A%84%E8%AE%BE%E8%AE%A1"><span class="nav-text">1.4.4 郭哥的设计</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-5-%E5%8A%A0%E4%B8%80%E6%9D%A1%E6%8C%87%E4%BB%A4%E9%9C%80%E8%A6%81%E8%80%83%E8%99%91%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="nav-text">1.5 加一条指令需要考虑什么？</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%8C%E3%80%81%E7%90%86%E8%AE%BA"><span class="nav-text">二、理论</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2-1-%E5%BB%B6%E8%BF%9F%E6%A7%BD"><span class="nav-text">2.1 延迟槽</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-2-A%E5%92%8CT%E7%9A%84%E6%9E%84%E9%80%A0"><span class="nav-text">2.2 A和T的构造</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-3-%E9%98%BB%E5%A1%9E%E5%92%8C%E5%88%B7%E6%96%B0"><span class="nav-text">2.3 阻塞和刷新</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-4-%E8%BD%AC%E5%8F%91"><span class="nav-text">2.4 转发</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#2-4-1-%E8%BD%AC%E5%8F%91%E6%80%BB%E8%AE%BA"><span class="nav-text">2.4.1 转发总论</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-4-1-%E8%BD%AC%E5%8F%91%E7%9A%84%E6%8F%90%E4%BE%9B%E8%80%85%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="nav-text">2.4.1 转发的提供者的实现</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-4-2-%E8%BD%AC%E5%8F%91%E7%9A%84%E6%8E%A5%E5%8F%97%E8%80%85%E6%98%AF%E8%B0%81%EF%BC%9F"><span class="nav-text">2.4.2 转发的接受者是谁？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-4-3-%E6%97%A0%E8%84%91%E8%BD%AC%E5%8F%91%E7%90%86%E8%AE%BA"><span class="nav-text">2.4.3 无脑转发理论</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-5-%E5%86%85%E9%83%A8%E8%BD%AC%E5%8F%91"><span class="nav-text">2.5 内部转发</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%89%E3%80%81%E6%A8%A1%E5%9D%97"><span class="nav-text">三、模块</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#3-1-CONTROL"><span class="nav-text">3.1 CONTROL</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#3-1-1-CU"><span class="nav-text">3.1.1 CU</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#3-1-1-1-CORE"><span class="nav-text">3.1.1.1 CORE</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-1-1-2-CU"><span class="nav-text">3.1.1.2 CU</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-1-2-SU"><span class="nav-text">3.1.2 SU</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#3-1-2-1-BasicCORE"><span class="nav-text">3.1.2.1 BasicCORE</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-1-2-2-SUCORE"><span class="nav-text">3.1.2.2 SUCORE</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-1-2-3-SU"><span class="nav-text">3.1.2.3 SU</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-1-3-FU"><span class="nav-text">3.1.3 FU</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-1-Fetch-%E6%B5%81%E6%B0%B4%E7%BA%A7"><span class="nav-text">3.1 Fetch 流水级</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#3-1-1-IFU"><span class="nav-text">3.1.1 IFU</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-2-Decode-%E6%B5%81%E6%B0%B4%E7%BA%A7"><span class="nav-text">3.2 Decode 流水级</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#3-2-1-DREG"><span class="nav-text">3.2.1 DREG</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-2-2-GRF"><span class="nav-text">3.2.2 GRF</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-2-3-NPC"><span class="nav-text">3.2.3 NPC</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-2-4-CMP"><span class="nav-text">3.2.4 CMP</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-2-5-EXT"><span class="nav-text">3.2.5 EXT</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-2-6-PCMux"><span class="nav-text">3.2.6 PCMux</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-2-7-JumpMux"><span class="nav-text">3.2.7 JumpMux</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-2-8-D-FWrsLevelMux"><span class="nav-text">3.2.8 D_FWrsLevelMux</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-2-9-D-FWrtLevelMux"><span class="nav-text">3.2.9 D_FWrtLevelMux</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-2-9-D-FWrtLevelMux-1"><span class="nav-text">3.2.9 D_FWrtLevelMux</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-3-Execute-%E6%B5%81%E6%B0%B4%E7%BA%A7"><span class="nav-text">3.3 Execute 流水级</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#3-3-1-EREG"><span class="nav-text">3.3.1 EREG</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-3-2-ALU"><span class="nav-text">3.3.2 ALU</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-3-3-SrcBMux"><span class="nav-text">3.3.3 SrcBMux</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-3-4-E-FWSrcMux"><span class="nav-text">3.3.4 E_FWSrcMux</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-3-5-E-FWrsLevelMux"><span class="nav-text">3.3.5 E_FWrsLevelMux</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-3-6-E-FWrtLevelMux"><span class="nav-text">3.3.6 E_FWrtLevelMux</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-4-Memory-%E6%B5%81%E6%B0%B4%E7%BA%A7"><span class="nav-text">3.4 Memory 流水级</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#3-4-1-MREG"><span class="nav-text">3.4.1 MREG</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-4-2-DM"><span class="nav-text">3.4.2 DM</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-4-3-M-FWSrcMux"><span class="nav-text">3.4.3 M_FWSrcMux</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-4-4-M-FWrtLevelMux"><span class="nav-text">3.4.4 M_FWrtLevelMux</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-5-WriteBack-%E6%B5%81%E6%B0%B4%E7%BA%A7"><span class="nav-text">3.5 WriteBack 流水级</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#3-5-1-GRFAddMux"><span class="nav-text">3.5.1 GRFAddMux</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-5-2-GRFInMux"><span class="nav-text">3.5.2 GRFInMux</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-5-3-W-FWSrcMux"><span class="nav-text">3.5.3 W_FWSrcMux</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9B%9B%E3%80%81%E6%B5%8B%E8%AF%95"><span class="nav-text">四、测试</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#4-1-%E6%B5%8B%E8%AF%95%E6%A0%B7%E4%BE%8B"><span class="nav-text">4.1 测试样例</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#4-2-1-%E5%8D%95%E6%9D%A1%E6%8C%87%E4%BB%A4"><span class="nav-text">4.2.1 单条指令</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-2-2-%E5%BC%B1%E6%B5%8B"><span class="nav-text">4.2.2 弱测</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-2-3-%E5%BC%BA%E6%B5%8B"><span class="nav-text">4.2.3 强测</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-2-%E6%B5%8B%E8%AF%95TLE"><span class="nav-text">4.2 测试TLE</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-3-%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7"><span class="nav-text">4.3 测试工具</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%94%E3%80%81%E4%BB%A3%E7%A0%81%E9%A3%8E%E6%A0%BC"><span class="nav-text">五、代码风格</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#5-1-%E8%AF%91%E7%A0%81%E5%99%A8%E9%A3%8E%E6%A0%BC"><span class="nav-text">5.1 译码器风格</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#5-1-1-%E6%8C%87%E4%BB%A4%E9%A9%B1%E5%8A%A8%E5%9E%8B"><span class="nav-text">5.1.1 指令驱动型</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-1-2-%E6%8E%A7%E5%88%B6%E4%BF%A1%E5%8F%B7%E9%A9%B1%E5%8A%A8%E5%9E%8B"><span class="nav-text">5.1.2 控制信号驱动型</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-1-3-%E6%88%91%E7%9A%84%E8%AF%91%E7%A0%81%E9%A3%8E%E6%A0%BC"><span class="nav-text">5.1.3 我的译码风格</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-2-%E9%A1%B6%E5%B1%82%E5%8F%AA%E6%9C%89%E6%A8%A1%E5%9D%97%E5%AE%9E%E4%BE%8B%E5%8C%96"><span class="nav-text">5.2 顶层只有模块实例化</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-3-signed"><span class="nav-text">5.3 $signed</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-4-case"><span class="nav-text">5.4 case</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%85%AD%E3%80%81%E6%80%9D%E8%80%83%E9%A2%98"><span class="nav-text">六、思考题</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#6-1-%E5%9C%A8%E9%87%87%E7%94%A8%E6%9C%AC%E8%8A%82%E6%89%80%E8%BF%B0%E7%9A%84%E6%8E%A7%E5%88%B6%E5%86%92%E9%99%A9%E5%A4%84%E7%90%86%E6%96%B9%E5%BC%8F%E4%B8%8B%EF%BC%8CPC-%E7%9A%84%E5%80%BC%E5%BA%94%E5%BD%93%E5%A6%82%E4%BD%95%E8%A2%AB%E6%9B%B4%E6%96%B0%EF%BC%9F%E8%AF%B7%E4%BB%8E%E6%95%B0%E6%8D%AE%E9%80%9A%E8%B7%AF%E5%92%8C%E6%8E%A7%E5%88%B6%E4%BF%A1%E5%8F%B7%E4%B8%A4%E6%96%B9%E9%9D%A2%E8%BF%9B%E8%A1%8C%E8%AF%B4%E6%98%8E%E3%80%82"><span class="nav-text">6.1  在采用本节所述的控制冒险处理方式下，PC 的值应当如何被更新？请从数据通路和控制信号两方面进行说明。</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-2-%E5%AF%B9%E4%BA%8E-jal-%E7%AD%89%E9%9C%80%E8%A6%81%E5%B0%86%E6%8C%87%E4%BB%A4%E5%9C%B0%E5%9D%80%E5%86%99%E5%85%A5%E5%AF%84%E5%AD%98%E5%99%A8%E7%9A%84%E6%8C%87%E4%BB%A4%EF%BC%8C%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E5%9B%9E%E5%86%99-PC-8%EF%BC%9F"><span class="nav-text">6.2 对于 jal 等需要将指令地址写入寄存器的指令，为什么需要回写 PC+8？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-3-%E4%B8%BA%E4%BB%80%E4%B9%88%E6%89%80%E6%9C%89%E7%9A%84%E4%BE%9B%E7%BB%99%E8%80%85%E9%83%BD%E6%98%AF%E5%AD%98%E5%82%A8%E4%BA%86%E4%B8%8A%E4%B8%80%E7%BA%A7%E4%BC%A0%E6%9D%A5%E7%9A%84%E5%90%84%E7%A7%8D%E6%95%B0%E6%8D%AE%E7%9A%84%E6%B5%81%E6%B0%B4%E7%BA%A7%E5%AF%84%E5%AD%98%E5%99%A8%EF%BC%8C%E8%80%8C%E4%B8%8D%E6%98%AF%E7%94%B1-ALU-%E6%88%96%E8%80%85-DM-%E7%AD%89%E9%83%A8%E4%BB%B6%E6%9D%A5%E6%8F%90%E4%BE%9B%E6%95%B0%E6%8D%AE%EF%BC%9F"><span class="nav-text">6.3 为什么所有的供给者都是存储了上一级传来的各种数据的流水级寄存器，而不是由 ALU 或者 DM 等部件来提供数据？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-4-%E5%A6%82%E6%9E%9C%E4%B8%8D%E9%87%87%E7%94%A8%E5%B7%B2%E7%BB%8F%E8%BD%AC%E5%8F%91%E8%BF%87%E7%9A%84%E6%95%B0%E6%8D%AE%EF%BC%8C%E8%80%8C%E9%87%87%E7%94%A8%E4%B8%8A%E4%B8%80%E7%BA%A7%E4%B8%AD%E7%9A%84%E5%8E%9F%E5%A7%8B%E6%95%B0%E6%8D%AE%EF%BC%8C%E4%BC%9A%E5%87%BA%E7%8E%B0%E6%80%8E%E6%A0%B7%E7%9A%84%E9%97%AE%E9%A2%98%EF%BC%9F%E8%AF%95%E5%88%97%E4%B8%BE%E6%8C%87%E4%BB%A4%E5%BA%8F%E5%88%97%E8%AF%B4%E6%98%8E%E8%BF%99%E4%B8%AA%E9%97%AE%E9%A2%98%E3%80%82"><span class="nav-text">6.4 如果不采用已经转发过的数据，而采用上一级中的原始数据，会出现怎样的问题？试列举指令序列说明这个问题。</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-5-%E6%88%91%E4%BB%AC%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E5%AF%B9-GPR-%E9%87%87%E7%94%A8%E5%86%85%E9%83%A8%E8%BD%AC%E5%8F%91%E6%9C%BA%E5%88%B6%EF%BC%9F%E5%A6%82%E6%9E%9C%E4%B8%8D%E9%87%87%E7%94%A8%E5%86%85%E9%83%A8%E8%BD%AC%E5%8F%91%E6%9C%BA%E5%88%B6%EF%BC%8C%E6%88%91%E4%BB%AC%E8%A6%81%E6%80%8E%E6%A0%B7%E6%89%8D%E8%83%BD%E8%A7%A3%E5%86%B3%E8%BF%99%E7%A7%8D%E6%83%85%E5%86%B5%E4%B8%8B%E7%9A%84%E8%BD%AC%E5%8F%91%E9%9C%80%E6%B1%82%E5%91%A2%EF%BC%9F"><span class="nav-text">6.5 我们为什么要对 GPR 采用内部转发机制？如果不采用内部转发机制，我们要怎样才能解决这种情况下的转发需求呢？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-6-%E4%B8%BA%E4%BB%80%E4%B9%88-0-%E5%8F%B7%E5%AF%84%E5%AD%98%E5%99%A8%E9%9C%80%E8%A6%81%E7%89%B9%E6%AE%8A%E5%A4%84%E7%90%86%EF%BC%9F"><span class="nav-text">6.6 为什么 0 号寄存器需要特殊处理？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-7-%E4%BB%80%E4%B9%88%E6%98%AF%E2%80%9C%E6%9C%80%E6%96%B0%E4%BA%A7%E7%94%9F%E7%9A%84%E6%95%B0%E6%8D%AE%E2%80%9D%EF%BC%9F"><span class="nav-text">6.7 什么是“最新产生的数据”？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-8-%E5%9C%A8-AT-%E6%96%B9%E6%B3%95%E8%AE%A8%E8%AE%BA%E8%BD%AC%E5%8F%91%E6%9D%A1%E4%BB%B6%E7%9A%84%E6%97%B6%E5%80%99%EF%BC%8C%E5%8F%AA%E6%8F%90%E5%88%B0%E4%BA%86%E2%80%9C%E4%BE%9B%E7%BB%99%E8%80%85%E9%9C%80%E6%B1%82%E8%80%85%E7%9A%84-A-%E7%9B%B8%E5%90%8C%EF%BC%8C%E4%B8%94%E4%B8%8D%E4%B8%BA-0%E2%80%9D%EF%BC%8C%E4%BD%86%E5%9C%A8-CPU-%E5%86%99%E5%85%A5-GRF-%E7%9A%84%E6%97%B6%E5%80%99%EF%BC%8C%E6%98%AF%E6%9C%89%E4%B8%80%E4%B8%AA-we-%E4%BF%A1%E5%8F%B7%E6%9D%A5%E6%8E%A7%E5%88%B6%E6%98%AF%E5%90%A6%E8%A6%81%E5%86%99%E5%85%A5%E7%9A%84%E3%80%82%E4%B8%BA%E4%BD%95%E5%9C%A8-AT-%E6%96%B9%E6%B3%95%E4%B8%AD%E4%B8%8D%E9%9C%80%E8%A6%81%E7%89%B9%E5%88%A4-we-%E5%91%A2%EF%BC%9F%E4%B8%BA%E4%BA%86%E7%94%A8%E4%B8%94%E4%BB%85%E7%94%A8-A-%E5%92%8C-T-%E5%AE%8C%E6%88%90%E8%BD%AC%E5%8F%91%EF%BC%8C%E5%9C%A8%E7%BF%BB%E8%AF%91%E5%87%BA-A-%E7%9A%84%E6%97%B6%E5%80%99%EF%BC%8C%E8%A6%81%E7%BB%93%E5%90%88-we-%E5%81%9A%E4%BB%80%E4%B9%88%E6%93%8D%E4%BD%9C%E5%91%A2%EF%BC%9F"><span class="nav-text">6.8 在 AT 方法讨论转发条件的时候，只提到了“供给者需求者的 A 相同，且不为 0”，但在 CPU 写入 GRF 的时候，是有一个 we 信号来控制是否要写入的。为何在 AT 方法中不需要特判 we 呢？为了用且仅用 A 和 T 完成转发，在翻译出 A 的时候，要结合 we 做什么操作呢？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-9-%E5%9C%A8%E6%9C%AC%E5%AE%9E%E9%AA%8C%E4%B8%AD%E4%BD%A0%E9%81%87%E5%88%B0%E4%BA%86%E5%93%AA%E4%BA%9B%E4%B8%8D%E5%90%8C%E6%8C%87%E4%BB%A4%E7%B1%BB%E5%9E%8B%E7%BB%84%E5%90%88%E4%BA%A7%E7%94%9F%E7%9A%84%E5%86%B2%E7%AA%81%EF%BC%9F%E4%BD%A0%E5%8F%88%E6%98%AF%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E7%9A%84%EF%BC%9F%E7%9B%B8%E5%BA%94%E7%9A%84%E6%B5%8B%E8%AF%95%E6%A0%B7%E4%BE%8B%E6%98%AF%E4%BB%80%E4%B9%88%E6%A0%B7%E7%9A%84%EF%BC%9F"><span class="nav-text">6.9 在本实验中你遇到了哪些不同指令类型组合产生的冲突？你又是如何解决的？相应的测试样例是什么样的？</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%83%E3%80%81%E4%B8%8A%E6%9C%BA"><span class="nav-text">七、上机</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#7-1-%E4%B8%8A%E6%9C%BA%E9%A2%98%E7%9B%AE%E5%9B%9E%E9%A1%BE"><span class="nav-text">7.1 上机题目回顾</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-2-%E5%8F%8D%E6%80%9D"><span class="nav-text">7.2 反思</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-3-%E4%B8%80%E4%B8%AA%E6%83%B3%E6%B3%95"><span class="nav-text">7.3 一个想法</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%85%AB%E3%80%81%E5%86%99%E5%9C%A8%E5%90%8E%E9%9D%A2%E7%9A%84%E8%AF%9D"><span class="nav-text">八、写在后面的话</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Thysrael"
      src="/images/avatar2.png">
  <p class="site-author-name" itemprop="name">Thysrael</p>
  <div class="site-description" itemprop="description">Can you hear me ?</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">199</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">31</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">70</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>
  <div class="">
    <a target="_blank" class="social-link" href="/atom.xml" style="color: burlywood;">
      <span class="icon">
        <i class="fa fa-rss"></i>
      </span>
      <span class="label">RSS</span>
    </a>
  </div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/thysrael" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;thysrael" rel="noopener external nofollow noreferrer" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:thysrael@163.com" title="E-Mail → mailto:thysrael@163.com" rel="noopener external nofollow noreferrer" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 2021.12.18 – 
  <span itemprop="copyrightYear">2025</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Thysrael</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
    <span title="Symbols count total">1.3m</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="Reading time total">20:17</span>
</div>

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="Total Visitors">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="Total Views">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  
  <script>
    (function(){
      var canonicalURL, curProtocol;
      //Get the <link> tag
      var x=document.getElementsByTagName("link");
		//Find the last canonical URL
		if(x.length > 0){
			for (i=0;i<x.length;i++){
				if(x[i].rel.toLowerCase() == 'canonical' && x[i].href){
					canonicalURL=x[i].href;
				}
			}
		}
    //Get protocol
	    if (!canonicalURL){
	    	curProtocol = window.location.protocol.split(':')[0];
	    }
	    else{
	    	curProtocol = canonicalURL.split(':')[0];
	    }
      //Get current URL if the canonical URL does not exist
	    if (!canonicalURL) canonicalURL = window.location.href;
	    //Assign script content. Replace current URL with the canonical URL
      !function(){var e=/([http|https]:\/\/[a-zA-Z0-9\_\.]+\.baidu\.com)/gi,r=canonicalURL,t=document.referrer;if(!e.test(r)){var n=(String(curProtocol).toLowerCase() === 'https')?"https://sp0.baidu.com/9_Q4simg2RQJ8t7jm9iCKT-xh_/s.gif":"//api.share.baidu.com/s.gif";t?(n+="?r="+encodeURIComponent(document.referrer),r&&(n+="&l="+r)):r&&(n+="?l="+r);var i=new Image;i.src=n}}(window);})();
  </script>




  
<script src="/js/local-search.js"></script>













  

  
      

<script>
  if (typeof MathJax === 'undefined') {
    window.MathJax = {
      loader: {
        source: {
          '[tex]/amsCd': '[tex]/amscd',
          '[tex]/AMScd': '[tex]/amscd'
        }
      },
      tex: {
        inlineMath: {'[+]': [['$', '$']]},
        tags: 'ams'
      },
      options: {
        renderActions: {
          findScript: [10, doc => {
            document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
              const display = !!node.type.match(/; *mode=display/);
              const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
              const text = document.createTextNode('');
              node.parentNode.replaceChild(text, node);
              math.start = {node: text, delim: '', n: 0};
              math.end = {node: text, delim: '', n: 0};
              doc.math.push(math);
            });
          }, '', false],
          insertedScript: [200, () => {
            document.querySelectorAll('mjx-container').forEach(node => {
              let target = node.parentNode;
              if (target.nodeName.toLowerCase() === 'li') {
                target.parentNode.classList.add('has-jax');
              }
            });
          }, '', false]
        }
      }
    };
    (function () {
      var script = document.createElement('script');
      script.src = '//cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js';
      script.defer = true;
      document.head.appendChild(script);
    })();
  } else {
    MathJax.startup.document.state(0);
    MathJax.texReset();
    MathJax.typeset();
  }
</script>

    

  

</body>
</html>
