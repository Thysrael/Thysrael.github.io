<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-wall.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-wall.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">
  <meta name="baidu-site-verification" content="code-jsxllPgZAX">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="https://fonts.loli.net/css?family=Noto Serif SC:300,300italic,400,400italic,700,700italic|Ma Shan Zheng:300,300italic,400,400italic,700,700italic|JetBrains Mono:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">
<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">
  <link rel="stylesheet" href="/lib/pace/pace-theme-minimal.min.css">
  <script src="/lib/pace/pace.min.js"></script>

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"thysrael.github.io","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":false,"style":"flat"},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="一、总论1.1 软硬件分工首先先明确，异常处理流是一个需要软硬件协作的流程。如果仅仅掌握了计组的知识，是没有办法对于异常处理流有一个很好的认识的。但是如果掌握了操作系统知识，而没有掌握计组知识，则不会有任何的实现负担。这是因为在 CPU 层面已经将异常处理流的硬件部分封装起来了（整个封装过程就是 P7，可以看到 P7 还是很难的），我们只要了解一下 CPU 提供给操作系统的接口，就可以利用这些接口">
<meta property="og:type" content="article">
<meta property="og:title" content="操作系统-异常处理流">
<meta property="og:url" content="https://thysrael.github.io/posts/671ebf76/index.html">
<meta property="og:site_name" content="钟鼓楼">
<meta property="og:description" content="一、总论1.1 软硬件分工首先先明确，异常处理流是一个需要软硬件协作的流程。如果仅仅掌握了计组的知识，是没有办法对于异常处理流有一个很好的认识的。但是如果掌握了操作系统知识，而没有掌握计组知识，则不会有任何的实现负担。这是因为在 CPU 层面已经将异常处理流的硬件部分封装起来了（整个封装过程就是 P7，可以看到 P7 还是很难的），我们只要了解一下 CPU 提供给操作系统的接口，就可以利用这些接口">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://thysrael.github.io/posts/671ebf76/异常处理总论.drawio-16509617693631.png">
<meta property="og:image" content="https://thysrael.github.io/posts/671ebf76/image-20220426173308911.png">
<meta property="og:image" content="https://thysrael.github.io/posts/671ebf76/异常处理流程.drawio.png">
<meta property="og:image" content="https://thysrael.github.io/posts/671ebf76/image-20220426200407641.png">
<meta property="og:image" content="https://thysrael.github.io/posts/671ebf76/image-20220426205044011.png">
<meta property="og:image" content="https://thysrael.github.io/posts/671ebf76/image-20220426205144463.png">
<meta property="og:image" content="https://thysrael.github.io/posts/671ebf76/image-20220426213212839.png">
<meta property="og:image" content="https://thysrael.github.io/posts/671ebf76/image-20220426213741842.png">
<meta property="og:image" content="https://thysrael.github.io/posts/671ebf76/image-20220426213754952.png">
<meta property="og:image" content="https://thysrael.github.io/posts/671ebf76/内核栈结构.drawio.png">
<meta property="og:image" content="https://thysrael.github.io/posts/671ebf76/异常内核栈.drawio.png">
<meta property="og:image" content="https://thysrael.github.io/posts/671ebf76/内核栈结构.drawio-16526749882911.png">
<meta property="og:image" content="https://thysrael.github.io/posts/671ebf76/image-20220516122924259.png">
<meta property="og:image" content="https://thysrael.github.io/posts/671ebf76/MMU缺失中断流程图.drawio.png">
<meta property="og:image" content="https://thysrael.github.io/posts/671ebf76/tlb.drawio.png">
<meta property="og:image" content="https://thysrael.github.io/posts/671ebf76/tlb_entry.png">
<meta property="og:image" content="https://thysrael.github.io/posts/671ebf76/image-20220409154810627.png">
<meta property="og:image" content="https://thysrael.github.io/posts/671ebf76/image-20220409154846877.png">
<meta property="og:image" content="https://thysrael.github.io/posts/671ebf76/时钟中断流程图.drawio.png">
<meta property="og:image" content="https://thysrael.github.io/posts/671ebf76/微信图片_20220510093613.jpg">
<meta property="og:image" content="https://thysrael.github.io/posts/671ebf76/写时复制异常流程图.drawio.png">
<meta property="og:image" content="https://thysrael.github.io/posts/671ebf76/image-20220516163430299.png">
<meta property="og:image" content="https://thysrael.github.io/posts/671ebf76/系统调用流程图.drawio.png">
<meta property="og:image" content="https://thysrael.github.io/posts/671ebf76/image-20220511204955352-16527034425482.png">
<meta property="og:image" content="https://thysrael.github.io/posts/671ebf76/4_fork_process.png">
<meta property="article:published_time" content="2022-04-26T07:41:52.000Z">
<meta property="article:modified_time" content="2025-08-15T12:16:48.835Z">
<meta property="article:author" content="Thysrael">
<meta property="article:tag" content="S4课上">
<meta property="article:tag" content="直观理解">
<meta property="article:tag" content="操作系统">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://thysrael.github.io/posts/671ebf76/异常处理总论.drawio-16509617693631.png">

<link rel="canonical" href="https://thysrael.github.io/posts/671ebf76/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'en'
  };
</script>

  <title>操作系统-异常处理流 | 钟鼓楼</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>


<style>.github-emoji { position: relative; display: inline-block; width: 1.2em; min-height: 1.2em; overflow: hidden; vertical-align: top; color: transparent; }  .github-emoji > span { position: relative; z-index: 10; }  .github-emoji img, .github-emoji .fancybox { margin: 0 !important; padding: 0 !important; border: none !important; outline: none !important; text-decoration: none !important; user-select: none !important; cursor: auto !important; }  .github-emoji img { height: 1.2em !important; width: 1.2em !important; position: absolute !important; left: 50% !important; top: 50% !important; transform: translate(-50%, -50%) !important; user-select: none !important; cursor: auto !important; } .github-emoji-fallback { color: inherit; } .github-emoji-fallback img { opacity: 0 !important; }</style>
<link rel="alternate" href="/atom.xml" title="钟鼓楼" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>
      <a target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/thysrael" class="github-corner" aria-label="View source on GitHub"><svg width="80" height="80" viewBox="0 0 250 250" style="fill:#151513; color:#fff; position: absolute; top: 0; border: 0; right: 0;" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a><style>.github-corner:hover .octo-arm{animation:octocat-wave 560ms ease-in-out}@keyframes octocat-wave{0%,100%{transform:rotate(0)}20%,60%{transform:rotate(-25deg)}40%,80%{transform:rotate(10deg)}}@media (max-width:500px){.github-corner:hover .octo-arm{animation:none}.github-corner .octo-arm{animation:octocat-wave 560ms ease-in-out}}</style>
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">钟鼓楼</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">钟楼瘦，鼓楼胖</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories<span class="badge">31</span></a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags<span class="badge">68</span></a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives<span class="badge">195</span></a>

  </li>
        <li class="menu-item menu-item-resource">

    <a href="/resource/" rel="section"><i class="fa fa-book fa-fw"></i>Resource</a>

  </li>
        <li class="menu-item menu-item-links">

    <a href="/links/" rel="section"><i class="fa fa-link fa-fw"></i>Links</a>

  </li>
        <li class="menu-item menu-item-roam">

    <a href="/Roam-Site/" rel="section"><i class="fa fa-sitemap fa-fw"></i>Roam</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>About</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>Search
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="Searching..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://thysrael.github.io/posts/671ebf76/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar2.png">
      <meta itemprop="name" content="Thysrael">
      <meta itemprop="description" content="Can you hear me ?">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="钟鼓楼">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          操作系统-异常处理流
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-04-26 15:41:52" itemprop="dateCreated datePublished" datetime="2022-04-26T15:41:52+08:00">2022-04-26</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-08-15 20:16:48" itemprop="dateModified" datetime="2025-08-15T20:16:48+08:00">2025-08-15</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" itemprop="url" rel="index"><span itemprop="name">操作系统</span></a>
                </span>
            </span>

          
            <span class="post-meta-item" title="Views" id="busuanzi_container_page_pv" style="display: none;">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">Views: </span>
              <span id="busuanzi_value_page_pv"></span>
            </span><br>
            <span class="post-meta-item" title="Symbols count in article">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">Symbols count in article: </span>
              <span>40k</span>
            </span>
            <span class="post-meta-item" title="Reading time">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">Reading time &asymp;</span>
              <span>36 mins.</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h2 id="一、总论"><a href="#一、总论" class="headerlink" title="一、总论"></a>一、总论</h2><h3 id="1-1-软硬件分工"><a href="#1-1-软硬件分工" class="headerlink" title="1.1 软硬件分工"></a>1.1 软硬件分工</h3><p>首先先明确，异常处理流是一个需要软硬件协作的流程。如果仅仅掌握了计组的知识，是没有办法对于异常处理流有一个很好的认识的。但是如果掌握了操作系统知识，而没有掌握计组知识，则不会有任何的实现负担。这是因为在 CPU 层面已经将异常处理流的硬件部分封装起来了（整个封装过程就是 P7，可以看到 P7 还是很难的），我们只要了解一下 CPU 提供给操作系统的接口，就可以利用这些接口提供的信息和功能完成异常处理流的软件部分。这是完全没有问题的。</p>
<p>我们有如下示意图：</p>
<p><img src="/posts/671ebf76/异常处理总论.drawio-16509617693631.png" alt="异常处理总论.drawio"></p>
<p>其中蓝色的是硬件部分（也就是计组要解决的问题），黄色的是软件部分（也就是操作系统），其中红色的部分，就是两个部分的接口。</p>
<p>这幅图最重要的就是搞懂那两个接口寄存器的意义。Cause 为选择哪一个异常处理函数提供了决策的依据，EPC 为有朝一日返回这个进程接着执行提供了支持（注意异常处理完成后不一定会返回异常发生时所在的进程，比如由于时钟中断导致的进程切换）。</p>
<h3 id="1-2-明确概念"><a href="#1-2-明确概念" class="headerlink" title="1.2 明确概念"></a>1.2 明确概念</h3><p>这个问题其实在计组实践的时候，就已经出现了。因为我们要处理的 “意外情况” 特别的多，所以我们需要一些名词来描述概念，但是往往会有一些因为名词冲突，而导致概念混淆的情况。所以在开始文章之前，还是先介绍一下概念名词，这些名词只在这篇文章中有效。另外声明，这里的概念定义跟我在计组P7博客里的概念是冲突的（只能说年少无知太轻狂）。</p>
<p>概念有如下关系</p>
<p><img src="/posts/671ebf76/image-20220426173308911.png" alt="image-20220426173308911"></p>
<p>所有的“控制流异常情况的原因”统称为“异常”，同步异常指的是处理器执行某条指令而导致的异常，异步异常指的是异常触发的原因与处理器当前正在执行的指令无关的异常。更低一级的概念并不能保证正确性。</p>
<h3 id="1-3-异常处理流程"><a href="#1-3-异常处理流程" class="headerlink" title="1.3 异常处理流程"></a>1.3 异常处理流程</h3><p>这里给出异常处理的<strong>一般</strong>流程</p>
<p><img src="/posts/671ebf76/异常处理流程.drawio.png" alt="异常处理流程.drawio"></p>
<hr>
<h2 id="二、硬件部分"><a href="#二、硬件部分" class="headerlink" title="二、硬件部分"></a>二、硬件部分</h2><h3 id="2-1-计组-CP0-结构"><a href="#2-1-计组-CP0-结构" class="headerlink" title="2.1 计组 CP0 结构"></a>2.1 计组 CP0 结构</h3><p>这里给出上个学期我实现 P7 的时候的源码，但是需要注意的是计组实现的 CPU 架构好像是 Mips32，与操作系统用的 R3000 并不相同，CP0 的结构有一些细节上的差异。</p>
<p>这是 CP0 的实现。</p>
<pre class="line-numbers language-verilog" data-language="verilog"><code class="language-verilog"><span class="token constant">`timescale</span> <span class="token number">1</span>ns <span class="token operator">/</span> <span class="token number">1</span>ps
<span class="token constant">`define</span> IM SR<span class="token punctuation">[</span><span class="token number">15</span><span class="token punctuation">:</span><span class="token number">10</span><span class="token punctuation">]</span>
<span class="token constant">`define</span> EXL SR<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span>
<span class="token constant">`define</span> IE SR<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>
<span class="token constant">`define</span> BD Cause<span class="token punctuation">[</span><span class="token number">31</span><span class="token punctuation">]</span>
<span class="token constant">`define</span> IP Cause<span class="token punctuation">[</span><span class="token number">15</span><span class="token punctuation">:</span><span class="token number">10</span><span class="token punctuation">]</span>
<span class="token constant">`define</span> ExcCode Cause<span class="token punctuation">[</span><span class="token number">6</span><span class="token punctuation">:</span><span class="token number">2</span><span class="token punctuation">]</span>

<span class="token keyword">module</span> CP0
	<span class="token punctuation">(</span>
		<span class="token keyword">input</span> clk<span class="token punctuation">,</span>
		<span class="token keyword">input</span> reset<span class="token punctuation">,</span>
		<span class="token keyword">input</span> en<span class="token punctuation">,</span>
		<span class="token keyword">input</span> <span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> CP0Add<span class="token punctuation">,</span>
		<span class="token keyword">input</span> <span class="token punctuation">[</span><span class="token number">31</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> CP0In<span class="token punctuation">,</span>
		<span class="token keyword">output</span> <span class="token punctuation">[</span><span class="token number">31</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> CP0Out<span class="token punctuation">,</span>
		<span class="token keyword">input</span> <span class="token punctuation">[</span><span class="token number">31</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> VPC<span class="token punctuation">,</span>
		<span class="token keyword">input</span> BDIn<span class="token punctuation">,</span>
		<span class="token keyword">input</span> <span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> ExcCodeIn<span class="token punctuation">,</span>
		<span class="token keyword">input</span> <span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> HWInt<span class="token punctuation">,</span>
		<span class="token keyword">input</span> EXLClr<span class="token punctuation">,</span>
		<span class="token keyword">output</span> <span class="token punctuation">[</span><span class="token number">31</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> EPCOut<span class="token punctuation">,</span>
		<span class="token keyword">output</span> Req<span class="token punctuation">,</span>
		<span class="token keyword">output</span> tbReq
	<span class="token punctuation">)</span><span class="token punctuation">;</span>
	
	<span class="token keyword">reg</span> <span class="token punctuation">[</span><span class="token number">31</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> SR<span class="token punctuation">,</span> Cause<span class="token punctuation">,</span> EPC<span class="token punctuation">,</span> PrID<span class="token punctuation">;</span>
	
	<span class="token comment">//为了测试约定</span>
	<span class="token keyword">assign</span> tbReq <span class="token operator">=</span> <span class="token punctuation">(</span>HWInt<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">&amp;</span> SR<span class="token punctuation">[</span><span class="token number">12</span><span class="token punctuation">]</span> <span class="token operator">&amp;</span> <span class="token punctuation">(</span><span class="token operator">~</span><span class="token constant">`EXL</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span> <span class="token constant">`IE</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	
	<span class="token keyword">wire</span> IntReq <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token operator">|</span><span class="token punctuation">(</span>HWInt <span class="token operator">&amp;</span> <span class="token constant">`IM</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span> <span class="token punctuation">(</span><span class="token operator">~</span><span class="token constant">`EXL</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span> <span class="token constant">`IE</span><span class="token punctuation">;</span>
	<span class="token comment">//无论有没有全局中断使能，都要响应异常</span>
	<span class="token keyword">wire</span> ExcReq <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token operator">|</span>ExcCodeIn<span class="token punctuation">)</span> <span class="token operator">&amp;</span> <span class="token punctuation">(</span><span class="token operator">~</span><span class="token constant">`EXL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">assign</span> Req <span class="token operator">=</span> IntReq <span class="token operator">|</span> ExcReq<span class="token punctuation">;</span>
	<span class="token comment">//如果发生了中断，就要给更新 EPC，否则保持原值</span>
	<span class="token keyword">wire</span> <span class="token punctuation">[</span><span class="token number">31</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> nextEPC <span class="token operator">=</span> <span class="token punctuation">(</span>Req<span class="token punctuation">)</span><span class="token operator">?</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>BDIn<span class="token punctuation">)</span><span class="token operator">?</span> VPC <span class="token operator">-</span> <span class="token number">4</span> <span class="token punctuation">:</span> VPC<span class="token punctuation">)</span> <span class="token punctuation">:</span>
								 EPC<span class="token punctuation">;</span>							 
	
	<span class="token keyword">assign</span> EPCOut <span class="token operator">=</span> EPC<span class="token punctuation">;</span>
	
	<span class="token keyword">assign</span> CP0Out <span class="token operator">=</span> <span class="token punctuation">(</span>CP0Add <span class="token operator">==</span> <span class="token number">5'd12</span><span class="token punctuation">)</span><span class="token operator">?</span> SR <span class="token punctuation">:</span>
					<span class="token punctuation">(</span>CP0Add <span class="token operator">==</span> <span class="token number">5'd13</span><span class="token punctuation">)</span><span class="token operator">?</span> Cause <span class="token punctuation">:</span> 
					<span class="token punctuation">(</span>CP0Add <span class="token operator">==</span> <span class="token number">5'd14</span><span class="token punctuation">)</span><span class="token operator">?</span> EPC <span class="token punctuation">:</span>
					<span class="token punctuation">(</span>CP0Add <span class="token operator">==</span> <span class="token number">5'd15</span><span class="token punctuation">)</span><span class="token operator">?</span> PrID <span class="token punctuation">:</span>
					<span class="token number">0</span><span class="token punctuation">;</span>
	
	<span class="token keyword">initial</span> <span class="token keyword">begin</span>
		SR <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">;</span>
		Cause <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">;</span>
		EPC <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">;</span>
		PrID <span class="token operator">&lt;=</span> <span class="token number">32'hDEAD_C0DE</span><span class="token punctuation">;</span>
	<span class="token keyword">end</span>
	
	<span class="token important">always @</span><span class="token punctuation">(</span><span class="token keyword">posedge</span> clk<span class="token punctuation">)</span> <span class="token keyword">begin</span>
		<span class="token function">if</span><span class="token punctuation">(</span>reset<span class="token punctuation">)</span> <span class="token keyword">begin</span>
			SR <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">;</span>
			Cause <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">;</span>
			EPC <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">;</span>
			PrID <span class="token operator">&lt;=</span> <span class="token number">32'hDEAD_C0DE</span><span class="token punctuation">;</span>		
		<span class="token keyword">end</span>
		<span class="token keyword">else</span> <span class="token keyword">begin</span>
			<span class="token function">if</span><span class="token punctuation">(</span>EXLClr<span class="token punctuation">)</span> <span class="token constant">`EXL</span> <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">;</span>
			
			<span class="token function">if</span><span class="token punctuation">(</span>Req<span class="token punctuation">)</span> <span class="token keyword">begin</span> <span class="token comment">//相当于Req来临的时候，是没有办法用mt来写东西的</span>
				<span class="token constant">`ExcCode</span> <span class="token operator">&lt;=</span> IntReq <span class="token operator">?</span> <span class="token number">5'b0</span> <span class="token punctuation">:</span> ExcCodeIn<span class="token punctuation">;</span>
				<span class="token constant">`EXL</span> <span class="token operator">&lt;=</span> <span class="token number">1</span><span class="token punctuation">;</span>
				EPC <span class="token operator">&lt;=</span> nextEPC<span class="token punctuation">;</span>
				<span class="token constant">`BD</span> <span class="token operator">&lt;=</span> BDIn<span class="token punctuation">;</span>
			<span class="token keyword">end</span>
			<span class="token keyword">else</span> <span class="token function">if</span><span class="token punctuation">(</span>en<span class="token punctuation">)</span> <span class="token keyword">begin</span>
				<span class="token function">if</span><span class="token punctuation">(</span>CP0Add <span class="token operator">==</span> <span class="token number">12</span><span class="token punctuation">)</span> SR <span class="token operator">&lt;=</span> CP0In<span class="token punctuation">;</span>
				<span class="token comment">//if(CP0Add == 13) Cause &lt;= CP0In;</span>
				<span class="token function">if</span><span class="token punctuation">(</span>CP0Add <span class="token operator">==</span> <span class="token number">14</span><span class="token punctuation">)</span> EPC <span class="token operator">&lt;=</span> CP0In<span class="token punctuation">;</span>
				<span class="token comment">//if(CP0Add == 15) PrID &lt;= CP0In;</span>
			<span class="token keyword">end</span>
			<span class="token constant">`IP</span> <span class="token operator">&lt;=</span> HWInt<span class="token punctuation">;</span>
		<span class="token keyword">end</span>
	<span class="token keyword">end</span>
	
	
<span class="token keyword">endmodule</span> <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>这是 CP0 的布线</p>
<pre class="line-numbers language-verilog" data-language="verilog"><code class="language-verilog">CP0 cp0
<span class="token punctuation">(</span>
    <span class="token punctuation">.</span><span class="token function">clk</span><span class="token punctuation">(</span>clk<span class="token punctuation">)</span><span class="token punctuation">,</span>
    <span class="token punctuation">.</span><span class="token function">reset</span><span class="token punctuation">(</span>reset<span class="token punctuation">)</span><span class="token punctuation">,</span>
    <span class="token punctuation">.</span><span class="token function">en</span><span class="token punctuation">(</span>CP0En<span class="token punctuation">)</span><span class="token punctuation">,</span>
    <span class="token punctuation">.</span><span class="token function">CP0Add</span><span class="token punctuation">(</span>M_rd<span class="token punctuation">)</span><span class="token punctuation">,</span>
    <span class="token punctuation">.</span><span class="token function">CP0In</span><span class="token punctuation">(</span>M_FWrtOut<span class="token punctuation">)</span><span class="token punctuation">,</span>
    <span class="token punctuation">.</span><span class="token function">CP0Out</span><span class="token punctuation">(</span>M_CP0Out<span class="token punctuation">)</span><span class="token punctuation">,</span>
    <span class="token punctuation">.</span><span class="token function">VPC</span><span class="token punctuation">(</span>M_PC<span class="token punctuation">)</span><span class="token punctuation">,</span>
    <span class="token punctuation">.</span><span class="token function">BDIn</span><span class="token punctuation">(</span>M_BD<span class="token punctuation">)</span><span class="token punctuation">,</span>
    <span class="token punctuation">.</span><span class="token function">ExcCodeIn</span><span class="token punctuation">(</span>M_ExcCode<span class="token punctuation">)</span><span class="token punctuation">,</span>
    <span class="token punctuation">.</span><span class="token function">HWInt</span><span class="token punctuation">(</span>HWInt<span class="token punctuation">)</span><span class="token punctuation">,</span>
    <span class="token punctuation">.</span><span class="token function">EXLClr</span><span class="token punctuation">(</span>EXLClr<span class="token punctuation">)</span><span class="token punctuation">,</span>
    <span class="token punctuation">.</span><span class="token function">EPCOut</span><span class="token punctuation">(</span>M_EPCOut<span class="token punctuation">)</span><span class="token punctuation">,</span>
    <span class="token punctuation">.</span><span class="token function">Req</span><span class="token punctuation">(</span>Req<span class="token punctuation">)</span><span class="token punctuation">,</span>
    <span class="token punctuation">.</span><span class="token function">tbReq</span><span class="token punctuation">(</span>tbReq<span class="token punctuation">)</span>
<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="2-2-SR-寄存器"><a href="#2-2-SR-寄存器" class="headerlink" title="2.2 SR 寄存器"></a>2.2 SR 寄存器</h3><p>这个寄存不是接口！！！也就是说，这个寄存器不需要给操作系统看到。那么这个寄存器在异常处理方面是干啥的呢（它不止在异常流控制这一个方面发挥作用），其实是<strong>控制异常</strong>的。也就是说，所有的异常，都需要经过和 SR 寄存器某些位的加工处理以后，才可以将生成的数据放在 Cause 中提供给操作系统。</p>
<p>在计组中，表现为这样的形式：</p>
<pre class="line-numbers language-verilog" data-language="verilog"><code class="language-verilog"><span class="token constant">`define</span> IM SR<span class="token punctuation">[</span><span class="token number">15</span><span class="token punctuation">:</span><span class="token number">10</span><span class="token punctuation">]</span>
<span class="token constant">`define</span> EXL SR<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span>
<span class="token constant">`define</span> IE SR<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>

<span class="token keyword">wire</span> IntReq <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token operator">|</span><span class="token punctuation">(</span>HWInt <span class="token operator">&amp;</span> <span class="token constant">`IM</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span> <span class="token punctuation">(</span><span class="token operator">~</span><span class="token constant">`EXL</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span> <span class="token constant">`IE</span><span class="token punctuation">;</span>
<span class="token keyword">wire</span> ExcReq <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token operator">|</span>ExcCodeIn<span class="token punctuation">)</span> <span class="token operator">&amp;</span> <span class="token punctuation">(</span><span class="token operator">~</span><span class="token constant">`EXL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">assign</span> Req <span class="token operator">=</span> IntReq <span class="token operator">|</span> ExcReq<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>可以看到，SR 主要提供中断的掩码 <code>IM</code> 和中断使能 <code>IE</code> ，异常等级 <code>EXL</code> 三个位。之后通过这些位的运算后来确定到底要不要发出异常信号和更新 EPC 之类的一系列处理。重点其实就是<strong>掩码</strong>与<strong>使能</strong>。因为操作系统使用的是 R3000，所以重点介绍 R3000 的结构</p>
<p><img src="/posts/671ebf76/image-20220426200407641.png" alt="image-20220426200407641"></p>
<p>虽然有很多位，而且每一位都很重要，但是其实真正用到的没有几个，首先是 <code>IM</code> ，他是中断掩码，也就是说，R3000 有 8 个外部中断源，只有该位置 1 ，对应的外部中断才会被引发异常，否则不会。</p>
<p>然后就是所谓的二重栈结构，这个结构在 <code>SR[5:0]</code> ，首先解释一下，<code>KU</code> 如果置 1，就说明当前进程处于内核态（ 内核态可以使用的指令更多，访问的地址空间更大），<code>IE</code> 如果置 1，这说明当前允许异常发生（注意是异常，而不是中断，范围扩大了）。然后在解释一下下标，<code>o</code> 是 old 的意思，<code>p</code> 是 previous 的意思，<code>c</code> 是 current 的意思。</p>
<p>然后介绍一下这个所谓的二重三级栈，其实就是当发生异常的时候，previous 的内容会被拷贝到 old 中，current 的内容会被拷贝到 previous 中。然后当 <code>eret</code> 指令一下达，previous 的内容会被拷贝到 current 中，old 中内容会被拷贝到 previous 中。</p>
<p>关于这个神奇的栈设置，还是妄谈几句。R3000 应该是不希望允许嵌套中断的，所以当处理中断的时候，先把 IEc 设置为 0 ，这样就不允许其他的中断在处理这个中断的时候发生了，屏蔽了其他中断。但是似乎不允许嵌套中断，CPU 功能又实现不了了，如果缺页中断中又有一个缺页中断，那么就崩了（具体我不知道，下面截图），所以为了支持嵌套中断，所以必须有所记录。就跟我们用栈来支持函数嵌套一样，我们同样需要栈结构来支持，<code>EPC</code> 似乎自己找地方去了，然后 <code>SR</code> 这两位就是用这个栈结构。</p>
<p><img src="/posts/671ebf76/image-20220426205044011.png" alt="image-20220426205044011"></p>
<p><img src="/posts/671ebf76/image-20220426205144463.png" alt="image-20220426205144463"></p>
<h3 id="2-3-Cause-寄存器"><a href="#2-3-Cause-寄存器" class="headerlink" title="2.3 Cause 寄存器"></a>2.3 Cause 寄存器</h3><p> Cause 寄存器里的内容由 CP0 生成，然后操作系统会访问这个值，我们在计组中，有</p>
<pre class="line-numbers language-verilog" data-language="verilog"><code class="language-verilog"><span class="token constant">`define</span> BD Cause<span class="token punctuation">[</span><span class="token number">31</span><span class="token punctuation">]</span>
<span class="token constant">`define</span> IP Cause<span class="token punctuation">[</span><span class="token number">15</span><span class="token punctuation">:</span><span class="token number">10</span><span class="token punctuation">]</span>
<span class="token constant">`define</span> ExcCode Cause<span class="token punctuation">[</span><span class="token number">6</span><span class="token punctuation">:</span><span class="token number">2</span><span class="token punctuation">]</span>

<span class="token function">if</span><span class="token punctuation">(</span>Req<span class="token punctuation">)</span> <span class="token keyword">begin</span> <span class="token comment">//相当于Req来临的时候，是没有办法用mt来写东西的</span>
    <span class="token constant">`ExcCode</span> <span class="token operator">&lt;=</span> IntReq <span class="token operator">?</span> <span class="token number">5'b0</span> <span class="token punctuation">:</span> ExcCodeIn<span class="token punctuation">;</span>
    <span class="token constant">`EXL</span> <span class="token operator">&lt;=</span> <span class="token number">1</span><span class="token punctuation">;</span>
    EPC <span class="token operator">&lt;=</span> nextEPC<span class="token punctuation">;</span>
    <span class="token constant">`BD</span> <span class="token operator">&lt;=</span> BDIn<span class="token punctuation">;</span>
<span class="token keyword">end</span>
<span class="token constant">`IP</span> <span class="token operator">&lt;=</span> HWInt<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>可以看到，Cause 里比较重要的一个域就是 <code>ExcCode</code> 用来记录到底是哪一种异常。这样操作系统才可以根据信息来选择不同的异常处理函数去处理。</p>
<p>对于R3000架构来说，Cause 寄存器如图：</p>
<p><img src="/posts/671ebf76/image-20220426213212839.png" alt="image-20220426213212839"></p>
<p>BD 这个域同样是接口，如果异常指令是一个分支延迟槽指令，那么这位就会被置 1。这是因为当异常指令为延迟槽指令的时候，<code>EPC</code> 的值会变成延迟槽指令的前一条指令（为了程序的正常执行）。我们在软件侧可以利用 <code>BD</code> 来获得真正发生异常的指令。</p>
<p>IP 是 Interrupt pending 的意思，他的意思结合代码来看就很容易，它记录的是现在发生的中断，但是这些中断不一定被响应，还有看 IM 的设置。IP 只是一个单纯的记录者</p>
<pre class="line-numbers language-verilog" data-language="verilog"><code class="language-verilog"><span class="token constant">`IP</span> <span class="token operator">&lt;=</span> HWInt<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>最重要的是 ExcCode，异常码，CPU 会根据异常的不同，将这个域设置成不同的值，操作系统通过读取这里的值，就可以获得这次异常的信息，R3000 常用的异常码如下：</p>
<p><img src="/posts/671ebf76/image-20220426213741842.png" alt="image-20220426213741842"></p>
<p><img src="/posts/671ebf76/image-20220426213754952.png" alt="image-20220426213754952"></p>
<h3 id="2-4-EPC-寄存器"><a href="#2-4-EPC-寄存器" class="headerlink" title="2.4 EPC 寄存器"></a>2.4 EPC 寄存器</h3><p>计组 CP0 跟 R3000 这个是一样的，可以看代码</p>
<pre class="line-numbers language-verilog" data-language="verilog"><code class="language-verilog"><span class="token keyword">wire</span> <span class="token punctuation">[</span><span class="token number">31</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> nextEPC <span class="token operator">=</span> <span class="token punctuation">(</span>Req<span class="token punctuation">)</span><span class="token operator">?</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>BDIn<span class="token punctuation">)</span><span class="token operator">?</span> VPC <span class="token operator">-</span> <span class="token number">4</span> <span class="token punctuation">:</span> VPC<span class="token punctuation">)</span> <span class="token punctuation">:</span>
								 EPC<span class="token punctuation">;</span>		<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>就是保存一下当前的 PC，然后方便返回。</p>
<hr>
<h2 id="三、软件总论"><a href="#三、软件总论" class="headerlink" title="三、软件总论"></a>三、软件总论</h2><h3 id="3-1-文章结构"><a href="#3-1-文章结构" class="headerlink" title="3.1 文章结构"></a>3.1 文章结构</h3><p>本文会分析先分析异常处理的共性，然后会每一章介绍一个异常的具体流程。</p>
<p>因为异常是一个很宏大的主题，期间逻辑错综复杂，所以我并没有能力把他们组织成一个逻辑完备的整体，所以可能有的时候只能放源码解读，而不是有理有据的总结。这个摆烂的部分可以看做是之前博文《MOS源码解读》的 lab3 和 lab4 部分。</p>
<p>我们要讲的异常处理函数有如下几个：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>异常处理函数</th>
<th>编号</th>
<th>解释</th>
</tr>
</thead>
<tbody>
<tr>
<td>handle_reserved</td>
<td>无</td>
<td>没有内容，用于初始化异常分发矩阵</td>
</tr>
<tr>
<td>handle_int</td>
<td>0</td>
<td>用于处理时钟中断，主要是换进程调度</td>
</tr>
<tr>
<td>handle_mod</td>
<td>1</td>
<td>当尝试写一个只读的虚拟页面的时候会触发，主要会进行一个写时复制处理</td>
</tr>
<tr>
<td>handle_tlb</td>
<td>2</td>
<td>当 TLB 缺失的时候会触发，会把需要的页表项调入 TLB</td>
</tr>
<tr>
<td>handle_tlb</td>
<td>3</td>
<td>似乎与上面相同</td>
</tr>
<tr>
<td>handle_sys</td>
<td>8</td>
<td>当使用 <code>syscall</code> 指令的时候调用，会根据系统调用号去决定异常处理的功能</td>
</tr>
</tbody>
</table>
</div>
<h3 id="3-2-直观理解"><a href="#3-2-直观理解" class="headerlink" title="3.2 直观理解"></a>3.2 直观理解</h3><p>异常处理真的是很复杂，但是感觉第一次提出异常处理流并且利用它构建了各个抽象概念，比如进程的时候，简直就像在欣赏一件艺术品一样，实在是感到十分震撼。</p>
<p>我个人觉得异常处理跟<strong>进程抽象</strong>联系还是很紧密的，或者说是内核态用户态转换是很紧密的。异常处理的本质是<strong>异常处理流</strong>。换句话说，就是程序计数器的变化，执行指令的变化。通过这种异常处理，我们可以实现在各个功能的实现间的跳转。我们把一部分功能交给操作系统去实现，而让用户进程只考虑跟自己有关的事情。</p>
<p>落实到比较具体的，就是在异常处理的时候 PC 会怎么变化，为了恢复现场会怎么做，我们需要新的栈空间吗？之类的问题，是我们要关注的重点。</p>
<hr>
<h2 id="四、异常的共性"><a href="#四、异常的共性" class="headerlink" title="四、异常的共性"></a>四、异常的共性</h2><h3 id="4-1-普遍流程"><a href="#4-1-普遍流程" class="headerlink" title="4.1 普遍流程"></a>4.1 普遍流程</h3><p>在 <code>lib/genex.S</code> 中有一个异常处理函数的构建宏，它总结了一些异常处理函数的普遍规律，我们可以通过这个函数来看一下异常的共性</p>
<pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">.macro	BUILD_HANDLER exception handler clear
	.align	5
	NESTED(handle_\exception, TF_SIZE, sp)  
	nop
	SAVE_ALL				
	__build_clear_\clear
	.set	at
	move	a0, sp
	jal		\handler
	nop
	j		ret_from_exception
	nop
	END(handle_\exception)
.endm<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>这里面虽然函数我都没有解释，但是从名字可以看出来，里面大概是先通过 <code>SAVE_ALL</code> 来保存现场，然后通过<code>_build_clear_\cli</code> 来禁用中断，然后会直接到达一个真正的 <code>handler</code>，这是各个异常处理的差异性体现，这个 handler 会接受一个参数，我们回头去讲。最后会通过 <code>ret_from_exception</code> 进行一个异常的返回。</p>
<p>需要强调的是，并不是所有异常处理都用了这个统一的模板，用这个模板的只有下面这几个</p>
<pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">BUILD_HANDLER 	reserved 		do_reserved 			cli
BUILD_HANDLER 	tlb				do_refill				cli
BUILD_HANDLER 	mod				page_fault_handler 		cli<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>但是其他的，比如说 <code>handle_int</code> 和 <code>handle_sys</code> 并没有使用这个模板处理。但是更需要强调的是，即使没有使用这个模板，但是他们的流程基本上也与模板类似，比如 <code>handle_int</code> 中就有如下代码片段，可以看出与模板是很类似的。</p>
<pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">SAVE_ALL
CLI
j			sched_yield
j			ret_from_exception<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>但是显然光看函数和宏的名字是没有办法来了解异常处理流程的，这里先简单介绍一下我们大致有干什么，然后再结合每一章进行介绍：</p>
<ul>
<li><strong>选择内核栈</strong>：这是因为异常一定是由一个原来的进程转换到操作系统进程的，那么之前使用的栈肯定是不能用了（有可能异常的原因就是栈对应的虚拟页面 TLB 缺失），我们需要一个新的栈来保存上下文，完成异常处理函数的各个子函数的调用。</li>
<li><strong>在内核栈上保存上下文</strong>：这里保存的上下文就是指通用寄存器、乘除寄存器和一些协处理器的寄存器（在 MOS 中这些东西被打包成 <code>Trapframe</code>  结构体），这些寄存器的值都来自发生异常的用户进程。我们要保存他们是因为我们的异常处理函数可能会覆盖这些值，而我们又需要这些值。主要是因为我们异常处理的时候有时候会用到他们（通过上下文指定政策），而我们在结束处理后还需要将其恢复（但是并不一定完全不变）。</li>
<li><strong>禁用中断</strong>：MOS 并不支持嵌套中断，所以进入异常后就会把中断使能端关掉。</li>
<li><strong>进行异常处理</strong>：这个根据具体情况分析，是特异性的体现。</li>
<li><strong>恢复栈指针</strong>：因为之前使用了内核栈，所以我们现在要进行一个恢复，不过其实可以看做恢复上下文的一部分。</li>
<li><strong>恢复上下文</strong>：将内核栈上保存的用户进程上下文恢复。</li>
<li><strong>跳转回用户进程</strong>：将 <code>PC</code> 设置为 <code>EPC</code> ，跳转回用户进程。</li>
</ul>
<p>下面就会结合这个流程来进行进行介绍。</p>
<h3 id="4-2-选择内核栈"><a href="#4-2-选择内核栈" class="headerlink" title="4.2 选择内核栈"></a>4.2 选择内核栈</h3><h4 id="4-2-1-内核中的栈"><a href="#4-2-1-内核中的栈" class="headerlink" title="4.2.1 内核中的栈"></a>4.2.1 内核中的栈</h4><p>选择内核栈是通过重置栈指针实现的。为什么要重置栈指针？这是因为此时计算机刚刚处于异常后的状态，虽然 PC 已经被纠正到了 <code>0x80000080</code> 。但是栈指针还是用户进程的栈指针，这显然是不能正常发挥作用的，我们需要将栈指针设置成一个内核栈指针。</p>
<p>在内核上我们有三个栈（先别纠结为啥仨栈），一个栈的栈底是 <code>0x8040_0000</code> 一个栈的栈底是 <code>KERNEL_SP</code> （在 <code>settimer</code> 中设置 ）另一个栈的栈底是 <code>TIMESTACK</code>。他们在内存中的分布是这样的</p>
<p><img src="/posts/671ebf76/内核栈结构.drawio.png" alt="内核栈结构.drawio"></p>
<p>我们说这几个栈的作用是不一样的，<code>Kernel Init Stack</code> 是初始化操作系统的时候用到的栈，之后就不会再使用了，因为这个栈上没法减少，也就没法重复利用。</p>
<p><code>Kernel Stack</code> 是在原来的栈上新增出的栈，这个栈的栈底是变量 <code>KERNEL_SP</code> ，这个变量在 <code>set_timer</code> 这个函数中设置</p>
<pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">sw	    sp, 			KERNEL_SP<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>他将这个时刻的栈指针存储在一个叫做 <code>KERNEL_SP</code> 的变量中，这个变量就定义在 <code>env_asm.S</code> 中，就一个字大小。</p>
<p>为什么要存储这个栈指针，是因为当发生异常的时候，不仅 PC 需要从用户进程更新到操作系统的指令流中，同时栈指针也需要调整到操作系统的栈，这就需要我们确定一下异常之后操作系统的栈指针应该在那里，那么就应该在这里。这是因为 <code>set_timer</code> 被 <code>klock_init</code> 调用，而 <code>mips_init</code> 的最后一个函数调用就是 <code>klock_init</code> 。之后会执行一个死循环，直到被时钟中断改变。所以此时的栈结构是这样的：</p>
<p><img src="/posts/671ebf76/异常内核栈.drawio.png" alt="异常内核栈.drawio"></p>
<p>第三个栈是 TIMESTACK，这个栈主要是处理时钟中断的时候需要使用。这里讨论一下为啥内核需要两个栈（用于异常处理），我初步的结论（与叶哥哥和郭哥哥讨论过后）觉得一个就够了，没必要用两个。姜姐姐提供了一种说法，认为这两种栈的设计可能是一个未完成的设计，这个设计可能是为了支持在进行其他异常处理的时候也可以响应时钟中断，但是没有完成这个设计，所以现在的 MOS 两个栈的设计看上去就是很冗余。</p>
<h4 id="4-2-2-get-sp"><a href="#4-2-2-get-sp" class="headerlink" title="4.2.2 get_sp"></a>4.2.2 get_sp</h4><p>这个宏就是用来选择栈的，我们来看一下其功能</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token punctuation">.</span>macro get_sp
	mfc0	k1<span class="token punctuation">,</span> CP0_CAUSE
    <span class="token comment">// 0x107c = 0001_0000_0111_1100, which means the exccode and the time irq</span>
	andi	k1<span class="token punctuation">,</span> <span class="token number">0x107C</span>
	xori	k1<span class="token punctuation">,</span> <span class="token number">0x1000</span>
    <span class="token comment">// if it's not a time interupt,then jump</span>
	bnez	k1<span class="token punctuation">,</span> <span class="token number">1f</span>
	nop
    <span class="token comment">// 0x82000000 is the TIMESTACK</span>
	li	    sp<span class="token punctuation">,</span> <span class="token number">0x82000000</span>
	j	<span class="token number">2f</span>
	nop
<span class="token number">1</span><span class="token operator">:</span>
	<span class="token comment">// 当 sp 已经为内核栈的时候，不变</span>
	bltz	sp<span class="token punctuation">,</span> <span class="token number">2f</span>	
	nop
	lw	    sp<span class="token punctuation">,</span> KERNEL_SP
	nop

<span class="token number">2</span><span class="token operator">:</span>	nop

<span class="token punctuation">.</span>endm<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>总之这一套下来，有一个固定的结论：</p>
<ul>
<li>如果发生的为时钟中断，那么 sp 会被设置为 <code>TIMESTACK</code></li>
<li>如果是其他异常，那么 sp 会被设置为 <code>KERNEL_SP</code>。</li>
<li>如果栈指针已经被设置为内核栈指针了（上面俩个中的一个），那么就不变，这个设计是为了支持嵌套异常。</li>
</ul>
<p>再看 <code>SAVE_ALL</code> 中的代码就很清楚了</p>
<pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">move	k0,sp
get_sp
move	k1,sp
subu	sp,k1,TF_SIZE
sw	    k0,TF_REG29(sp)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><code>sp</code> 原本的值被保留了，而 <code>sp</code> 现在的值，作为了保存的基地址。</p>
<p>换句话说，当异常为时钟中断的时候，我们将进程的上下文保存在 <code>TIMESTACK</code> ，而当其他异常的时候，我们将进程的上下文保存在 <code>KERNEL_SP</code>。然后我们会继续使用这附近的栈作为我们的内核栈空间。</p>
<h3 id="4-3-保存上下文"><a href="#4-3-保存上下文" class="headerlink" title="4.3 保存上下文"></a>4.3 保存上下文</h3><p>主要通过 <code>SAVEALL</code> 中的部分实现，因为还有一部分是调用 <code>get_sp</code> 实现栈选择，对于 <code>SAVE_ALL</code> 之后的栈的结构，大概就是这样的</p>
<p><img src="/posts/671ebf76/内核栈结构.drawio-16526749882911.png" alt="内核栈结构.drawio"></p>
<p>此时 <code>sp</code> 指向 <code>Trapframe</code> 的底部。之所以要强调这一点，是因为在这之后，有这个语句（在build里）</p>
<pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">move	    a0,         sp<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>这就表示如果是 C 函数，那么是可以完全利用这里面的上下文的，比如说</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">page_fault_handler</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">Trapframe</span> <span class="token operator">*</span>tf<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>但是这个用法太低级了，lab3-2 的考试题目可以用 C 来写，用法很高级，而且比汇编简单多了。我本来已经总结了，但是找不到了，摆烂放一张 banana 的图就好了（她没处理延迟槽）。可以看到可以利用这个指针获得基本上所有的信息。</p>
<p><img src="/posts/671ebf76/image-20220516122924259.png" alt="image-20220516122924259"></p>
<h3 id="4-4-禁止中断"><a href="#4-4-禁止中断" class="headerlink" title="4.4 禁止中断"></a>4.4 禁止中断</h3><p>主要通过 <code>CLI</code> 进行设置，具体的代码之前博客里有。但是这件事情有待商榷，因为据叶哥哥说，异常处理的禁用是在硬件层次上实现的，而 R3000 并没有实现这个功能（或者说实现了支持嵌套异常的功能），在软件方面是没有办法禁止中断的，我就不细讨论了。</p>
<h3 id="4-5-进行异常处理"><a href="#4-5-进行异常处理" class="headerlink" title="4.5 进行异常处理"></a>4.5 进行异常处理</h3><p>这个每个都不一样，具体的回头再说。</p>
<h3 id="4-6-从异常返回"><a href="#4-6-从异常返回" class="headerlink" title="4.6 从异常返回"></a>4.6 从异常返回</h3><h4 id="4-6-1-ret-from-exception"><a href="#4-6-1-ret-from-exception" class="headerlink" title="4.6.1 ret_from_exception"></a>4.6.1 ret_from_exception</h4><p>这个函数功能是从栈上恢复寄存器，并且跳转用户进程。</p>
<pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">FEXPORT(ret_from_exception)
	.set noat
	.set noreorder
	RESTORE_SOME
	.set at
	lw		k0,			TF_EPC(sp)				 
	lw		sp,			TF_REG29(sp) /* Deallocate stack */  
	nop
	jr		k0								 
	rfe	<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>恢复寄存器采用的是 <code>RESTORE_SOME</code></p>
<pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">RESTORE_SOME<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>然后恢复栈指针和 PC 用的是下面的操作</p>
<pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">lw		k0,			TF_EPC(sp)				 
lw		sp,			TF_REG29(sp) /* Deallocate stack */  
nop
jr		k0								 
rfe	<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="4-6-2-restore-some"><a href="#4-6-2-restore-some" class="headerlink" title="4.6.2 restore_some"></a>4.6.2 restore_some</h4><p>这个宏可以分为两个部分，一个是设置 STATUS 寄存器的状态，一个是恢复各种通用寄存器。</p>
<p>对于第一点，没有全部看懂，这只知道它应该是先开启了异常功能。（因为 MOS 不太允许嵌套异常，所以会在进入中断后关闭异常）。</p>
<pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">// set the STATUS normal
mfc0	t0,         CP0_STATUS
ori	    t0,         0x3
xori	t0,         0x3
mtc0	t0,         CP0_STATUS
// I don't know exactly what it had done 
lw	    v0,         TF_STATUS(sp)
li	    v1,         0xff00 
and	    t0,         v1 
nor	    v1,         $0,             v1 
and	    v0,         v1 
or		v0, 		t0 
mtc0	v0,			CP0_STATUS <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>然后进行寄存器的恢复，利用的依然是栈指针，这里需要注意的是，为什么可以利用栈指针，这是因为当异常处理完事后，栈指针就会回到当时 SAVE_ALL 之后的位置，所以地址向上查找就可以恢复现场</p>
<pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">lw		v1,			TF_LO(sp)
mtlo	v1
lw		v0,			TF_HI(sp)
lw		v1,			TF_EPC(sp)
mthi	v0
mtc0	v1,CP0_EPC
lw	$31,TF_REG31(sp)
lw	$30,TF_REG30(sp)
lw	$28,TF_REG28(sp)
lw	$25,TF_REG25(sp)
lw	$24,TF_REG24(sp)
lw	$23,TF_REG23(sp)
lw	$22,TF_REG22(sp)
lw	$21,TF_REG21(sp)
lw	$20,TF_REG20(sp)
lw	$19,TF_REG19(sp)
lw	$18,TF_REG18(sp)
lw	$17,TF_REG17(sp)
lw	$16,TF_REG16(sp)
lw	$15,TF_REG15(sp)
lw	$14,TF_REG14(sp)
lw	$13,TF_REG13(sp)
lw	$12,TF_REG12(sp)
lw	$11,TF_REG11(sp)
lw	$10,TF_REG10(sp)
lw	$9,TF_REG9(sp)
lw	$8,TF_REG8(sp)
lw	$7,TF_REG7(sp)
lw	$6,TF_REG6(sp)
lw	$5,TF_REG5(sp)
lw	$4,TF_REG4(sp)
lw	$3,TF_REG3(sp)
lw	$2,TF_REG2(sp)
lw	$1,TF_REG1(sp)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>在这里没有恢复的寄存器是 PC 和 栈指针，二者的恢复是在其他函数里实现的（比如 <code>ret_from_exception</code> ） 这可能是因为设计的原因。</p>
<h3 id="4-7-异常的分发"><a href="#4-7-异常的分发" class="headerlink" title="4.7 异常的分发"></a>4.7 异常的分发</h3><p>当发生异常的时候，就会自动跳转到一个固定的物理地址，然后执行一段固定的程序，这个程序就叫做异常分发程序，他根据 Cause 寄存器中的值决定到底要调用哪一个异常处理程序。</p>
<p>首先我们需要把程序链接到固定的位置，因此要修改链接脚本</p>
<pre class="line-numbers language-none"><code class="language-none">. = 0x80000080;
.except_vec3 : {
    *(.text.exc_vec3)
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>然后我们来看这段代码</p>
<pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">.section .text.exc_vec3
NESTED(except_vec3, 0, sp)
    .set noat 
    .set noreorder
1:
    mfc0 	k1,		CP0_CAUSE
    la 		k0,		exception_handlers
    andi 	k1,		0x7c
    addu 	k0,		k1
    lw 		k0,		(k0)
    nop
    jr k0
    nop
END(except_vec3)
.set at<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>首先它指定了输出段的名称</p>
<pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">.section .text.exc_vec3<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>然后可以看到他用多个语句去分析 Cause，Cause 的具体设置，我异常处理那篇博客写了</p>
<pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">mfc0 	k1,		CP0_CAUSE
andi 	k1,		0x7c<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>然后利用异常码作为索引去跳转</p>
<pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">la 		k0,		exception_handlers
addu 	k0,		k1
lw 		k0,		(k0)
nop
jr 		k0<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<hr>
<h2 id="五、TLB-缺失中断"><a href="#五、TLB-缺失中断" class="headerlink" title="五、TLB 缺失中断"></a>五、TLB 缺失中断</h2><h3 id="5-1-总体概览"><a href="#5-1-总体概览" class="headerlink" title="5.1 总体概览"></a>5.1 总体概览</h3><p>这种异常会发生在 TLB 缺失的时候，流程图如下：</p>
<p><img src="/posts/671ebf76/MMU缺失中断流程图.drawio.png" alt="MMU缺失中断流程图.drawio"></p>
<h3 id="5-2-TLB-结构"><a href="#5-2-TLB-结构" class="headerlink" title="5.2 TLB 结构"></a>5.2 TLB 结构</h3><p>首先我们需要弄懂 tlb 的结构，计组认为的 TLB，是长这样的：</p>
<p><img src="/posts/671ebf76/tlb.drawio.png" alt="tlb.drawio"></p>
<p>也就是说，TLB 是一个全相连的 cache，既然是全相连，就不由 index 段了。我们用虚拟地址的前 22 位作为 TAG，并行的比较 64 个TLB 的 line，如果 TAG 相等，就说明找到了，反之，这说明没有找到。</p>
<p>不过这个模型还是有些粗糙的，很多细节并没有说明白。</p>
<p>在操作系统指导书里提到，tlb 构建了一个映射关系，我简化一下，就是 $VPN\space \rightarrow\space PPN$ 。当然这是对的了，但是这种说法我就弄成了每个 VPN 都会对应一个 PPN，但是其实这种映射关系只有 64 对。而且叫映射似乎就是一下就射过去了，而不是一个并行的比较过程。</p>
<p>其次就是，我们没有了解具体硬件发生了啥，比如 VPN 是怎样被检索的，被检索到的 PPN 放到了哪里，tlb 缺失以后具体怎么填补。都是没有的。这其实跟协处理器有很大关系。</p>
<p>在了解协处理器之前，我们先来看一下 tlb 的表项，他比计组版本要复杂一些，我们以 MOS 中 64MB （也就是共有 $2^{14}$ 页 ）的物理内存为例</p>
<p><img src="/posts/671ebf76/tlb_entry.png" alt="tlb_entry"></p>
<p>我们来说明一下这些差别：</p>
<ul>
<li>朴素版的 PPN 只有 14 位，是因为物理页框号可以最少用 14 位表示，但是真实版的 PPN 也与 VPN 相同，是 22 位。可能是考虑到不同电脑上内存不同吧，这估计也是 mips_detect_memory() 这个函数的设置。</li>
<li>朴素版一个 entry 是 36 位，而真实版一个 entry 是 64 位。这是因为真实版的标志位更多，所以需要的位数就更多</li>
<li>朴素版没有 ASID 段，而真实版有。ASID（address space identifier）应该是用于区分不同进程的一个标识符，因为操作系统可以同时运行多个进程，要是不用 ASID 的话，只要进程一切换，那么 TLB 里的所有内容都需要失效（因为进程切换就以为着虚拟地址和物理地址的映射关系切换），而这样是低效的，因为每次 TLB 中的内容清空，就意味着会发生 64 次的冷缺失。</li>
<li>朴素版没有物理地址权限标志位（N，D，V，G），而真实版有。这四个标志位的解释见下表</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th>标志位</th>
<th>解释</th>
</tr>
</thead>
<tbody>
<tr>
<td>N（Non-cachable）</td>
<td>当该位置高时，后续的物理地址访存将不通过 cache</td>
</tr>
<tr>
<td>D（Dirty）</td>
<td>事实上是可写位。当该位置高时，该地址可写；否则任何写操作都将引发 TLB 异常。</td>
</tr>
<tr>
<td>V（Valid）</td>
<td>如果该位为低，则任何访问该地址的操作都将引发 TLB 异常。</td>
</tr>
<tr>
<td>G（Global）</td>
<td>如果该位置高，那么允许不同的虚拟地址映射到相同的物理地址，可能类似于进程级别的共享</td>
</tr>
</tbody>
</table>
</div>
<p>总结起来就是真实版的 tlb 建立了一个这样的映射 $<vpn,asid>\space\rightarrow\space<ppn,n,d,v,g>$ 。</ppn,n,d,v,g></vpn,asid></p>
<p>然后我们来解决下一个问题，就是 tlb 怎么用的问题。这是一个我之前忽略的点，因为其实我对于 tlb 的定位并不清楚，我本以为它就好像是一个 cache，是对于程序员是透明的，我就在编程的时候写虚拟地址，然后就有硬件（MMU）拿着这个地址去问 tlb，tb再做出相关反应，这一切都是我不需要了解的，但是实际上 tlb 的各种操作，都是需要软件协作的。之所以有这个错误认知，是因为似乎在 X86 架构下确实是由硬件干的，但是由于我们的 MIPS 架构，也就是 RISC 架构，所以似乎交由软件负责效率更高一些。</p>
<p>如果 tlb 是程序员可见的，那么我们必然要管理它，那么我们就需要思考怎样管理它？我们管理它的方式就是设置了专门的寄存器和专门的指令。指令用于读或者写 tlb 中的内容，而寄存器则用于作为 CPU 和 tlb 之间沟通的媒介，就好像我们需要用 hi 和 lo 寄存器与乘除单元沟通一样。这些寄存器，都位于 CP0 中</p>
<p>在协处理器里面与 tlb 有关的寄存器如下表：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>寄存器</th>
<th>编号</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>EntryHi</td>
<td>10</td>
<td>保存某个 tlb 表项的高 32 位，任何对 tlb 的读写，都需要通过 EntryHi 和 EntryLo</td>
</tr>
<tr>
<td>EntryLo</td>
<td>2</td>
<td>保存某个 tlb 表项的低 32 位</td>
</tr>
<tr>
<td>Index</td>
<td>0</td>
<td>决定索引号为某个值的 tlb 表项被读或者写</td>
</tr>
<tr>
<td>Random</td>
<td>1</td>
<td>提供一个随机的索引号用于 tlb 的读写</td>
</tr>
</tbody>
</table>
</div>
<p>这里再说一下各个寄存器的域</p>
<ul>
<li>EntryHi，EntryLo 的域与 tlb 表项完全相同</li>
<li>Index 的域：<img src="/posts/671ebf76/image-20220409154810627.png" alt="image-20220409154810627"></li>
<li>Random 的域：<img src="/posts/671ebf76/image-20220409154846877.png" alt="image-20220409154846877"></li>
</ul>
<p>与 tlb 相关的指令</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>指令</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>tlbr</td>
<td>以 Index 寄存器中的值为索引,读出 TLB 中对应的表项到 EntryHi 与 EntryLo。</td>
</tr>
<tr>
<td>tlbwi</td>
<td>以 Index 寄存器中的值为索引,将此时 EntryHi 与 EntryLo 的值写到索引指定的 TLB 表项中。</td>
</tr>
<tr>
<td>tlbwr</td>
<td>将 EntryHi 与 EntryLo 的数据随机写到一个 TLB 表项中（此处使用 Random 寄存器来“随机”指定表项，Random 寄存器本质上是一个不停运行的循环计数器）</td>
</tr>
<tr>
<td>tlbp</td>
<td>tlb probe。用于查看 tlb 是否可以转换虚拟地址（即命中与否）根据 EntryHi 中的 Key（包含 VPN 与 ASID），查找 TLB 中与之对应的表项。如果命中，并将表项的索引存入 Index 寄存器。若未找到匹配项，则 Index 最高位被置 1。</td>
</tr>
</tbody>
</table>
</div>
<h3 id="5-3-do-refill"><a href="#5-3-do-refill" class="headerlink" title="5.3 do_refill"></a>5.3 do_refill</h3><p>那么当引发异常以后，我们的操作系统干了什么？可以很容易看到哈，找到异常向量组，发现处理这类异常的函数是 <code>handle_tlb()</code>，然后再把通用的部分忽略，发现实现功能的是 <code>do_refill</code> 这个函数，我们看一下</p>
<pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">.extern tlbra
.set	noreorder
NESTED(do_refill,0 , sp)
			.extern	mCONTEXT
//this "1" is important
1:			
			lw		k1,			mCONTEXT
			and		k1,			0xfffff000
			mfc0	k0,			CP0_BADVADDR
			srl		k0,			20
			and		k0,			0xfffffffc
			addu	k0,			k1
			lw		k1,			0(k0)
			nop
			
			move	t0,			k1
			and		t0,			0x0200
			beqz	t0,			NOPAGE
			nop
			
			and		k1,			0xfffff000
			mfc0	k0,			CP0_BADVADDR
			srl		k0,			10
			and		k0,			0xfffffffc
			and		k0,			0x00000fff
			addu	k0,			k1
			or		k0,			0x80000000
			lw		k1,			0(k0)
			nop
			
			move	t0,			k1
			and		t0,			0x0200
			beqz	t0,			NOPAGE
			nop
			
			move	k0,			k1
			and		k0,			0x1
			beqz	k0,			NoCOW
			nop
			and		k1,			0xfffffbff
NoCOW:
			mtc0	k1,         CP0_ENTRYLO0
			nop
			tlbwr

			j		2f
			nop
NOPAGE:
			mfc0    a0,         CP0_BADVADDR
			lw		a1,         mCONTEXT
			nop
				
			sw	 	ra,         tlbra
			jal		pageout
			nop
			
			lw		ra,         tlbra
			nop

			j	    1b
2:			nop

			jr		ra
			nop
END(do_refill)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>首先我们需要找到引发异常的地址的页目录项，这个地址被存在了 <code>CP0_BADVADDR</code>。此时的页目录为 <code>mCONTEXT</code>。</p>
<pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">lw		k1,			mCONTEXT			# k1 存着当前用户进程页目录的地址
and		k1,			0xfffff000			# k1 的后12位偏移量被抹去，其实应该本来就没有
mfc0	k0,			CP0_BADVADDR		# k0 存着引发异常的虚拟地址
srl		k0,			20					# 取出 k0 的一级页目录号并 * 4,这是因为一个页目录是 4 字节
and		k0,			0xfffffffc			# 抹去 k0 后 2 位，对齐
addu	k0,			k1					# 页目录基地址加偏移量
lw		k1,			0(k0)				# k1 现在存着对应的页目录项
nop<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>当我们拿到这个页目录项以后，要看这个页目录项是否有效</p>
<pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">move	t0,			k1					# t0 存着页目录项
and		t0,			0x0200				# 0x200 是 PTE_V，所以进行与运算，如果该位有效，则 t0 非 0
beqz	t0,			NOPAGE				# 如果是 0 ，无效，那么跳转到 NOPAGE
nop<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>我们来看 NOPAGE 的操作</p>
<pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">NOPAGE:
mfc0    a0,         CP0_BADVADDR		# 把 a0 存成出现异常的虚拟地址
lw		a1,         mCONTEXT			# 把 a1 存成当前页目录地址
nop
sw	 	ra,         tlbra				# 把当前的栈指针保存一下，
										# 这么做是因为又要调用新的函数了，ra 马上被覆盖了。tlbra是块内存指定空间
jal		pageout							# 调用 pageout 这个C函数
nop<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>我们来看一下 pageout</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">pageout</span><span class="token punctuation">(</span><span class="token keyword">int</span> va<span class="token punctuation">,</span> <span class="token keyword">int</span> context<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
	<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>r <span class="token operator">=</span> <span class="token function">page_alloc</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>p<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> 
	<span class="token punctuation">{</span>
		<span class="token function">panic</span> <span class="token punctuation">(</span><span class="token string">"page alloc error!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>

	p<span class="token operator">-&gt;</span>pp_ref<span class="token operator">++</span><span class="token punctuation">;</span>

	<span class="token function">page_insert</span><span class="token punctuation">(</span><span class="token punctuation">(</span>Pde <span class="token operator">*</span><span class="token punctuation">)</span>context<span class="token punctuation">,</span> p<span class="token punctuation">,</span> <span class="token function">VA2PFN</span><span class="token punctuation">(</span>va<span class="token punctuation">)</span><span class="token punctuation">,</span> PTE_R<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"pageout:\t@@@___0x%x___@@@  ins a page \n"</span><span class="token punctuation">,</span> va<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>可以看出这个函数就是就是分配一个空闲物理页面，然后把对应关系建立起来。这里才是用到页表结构的地方。也就是说，这个函数是体现我们用页表管理映射关系的地方。但是这里还没完，因为这个其实对应的是虚拟页面没有在物理内存中被映射的情况。解决了这个问题，还有把映射好的物理页号填到 TLB 中的工作。</p>
<p>出来这个函数以后，就是一些收尾工作</p>
<pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">			lw		ra,         tlbra 			# 把栈指针恢复了
			nop		
			j	    1b							# 跳回一开始重新来一遍
2:			nop
			jr		ra							# do_refill 执行完成
			nop<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>那么如果页目录项有效呢？我们会继续执行，检索第二级页表</p>
<pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">and		k1,			0xfffff000				# k1 原来是页目录项，抹掉后 12 位权限位
mfc0	k0,			CP0_BADVADDR			# k0 存着异常的地址
srl		k0,			10						# 取出 k0 的二级页表号并 * 4,这是因为一个页目录是 4 字节
and		k0,			0xfffffffc				# 抹去 k0 后 2 位，对齐
and		k0,			0x00000fff				# 前面的一级页目录号去掉
addu	k0,			k1						# 基地址加偏移量
or		k0,			0x80000000				# 物理地址转换成虚拟地址
lw		k1,			0(k0)					# 把对应的页表项存到 k1
nop<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>然后接着对页表项进行权限检查</p>
<pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">move	t0,			k1
and		t0,			0x0200
beqz	t0,			NOPAGE
nop<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>然后下面开展重填操作（如果都处理好了）</p>
<pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">    move	k0,			k1					# k0 k1 存着万事具备的页表项
    and		k0,			0x1					# 看 k0 的最低位，是 PTE_COW copy on write 
    beqz	k0,			NoCOW				# 如果没有，就不需要特殊处理了
    nop
    and		k1,			0xfffffbff			# 有的话，把 PTE_R 位置 0 ，相当于限制写权限
NoCOW:
    mtc0	k1,         CP0_ENTRYLO0		# 把 k1 装到 EntryLow 中
    nop
    tlbwr									# 随便找个 tlb 项用 EntryLow 覆盖掉
    j		2f<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>综上，能看见页表的是操作系统，而不是硬件。操作系统在 TLB 缺失异常的时候，给 TLB 提供的内容都是经过页表系统管理的，所以 TLB 的所有内容都是经过页表系统管理的，不得不说真是巧妙啊。</p>
<h3 id="5-5-COW-的处理"><a href="#5-5-COW-的处理" class="headerlink" title="5.5 COW 的处理"></a>5.5 COW 的处理</h3><p>在这里的 <code>do_refill</code> 会有一个对于页表项权限位 <code>PTE_COW</code> 的判断。但是由于我们还没有介绍写时复制机制，所以这里只需要了解一下，如果一个页面被标记为 <code>PTW_COW</code> 了，那么我们就会去掉他的写权限，也就是说，如果这个页面被写了，就会触发 <code>handle_mod</code>。那么是不是所有的 <code>COW</code> 都会被去掉写权限呢？我们说是的，因为这些页面被标记为 <code>COW</code> 的时候要么没在 TLB 中，要么在 TLB 中被失效了（在 page_insert 中），所以这些页面都是被使用都需要先经过 TLB，所以一定会发生缺失，那么就一定会被去掉写权限。</p>
<hr>
<h2 id="六、时钟中断"><a href="#六、时钟中断" class="headerlink" title="六、时钟中断"></a>六、时钟中断</h2><h3 id="6-1-总体概览"><a href="#6-1-总体概览" class="headerlink" title="6.1 总体概览"></a>6.1 总体概览</h3><p>这个异常其实虽然叫做时钟中断，但是其实现的功能其实是进程切换。这个流程也是一个极其复杂的流程，所以需要有很好的理解。总体的流程如下：</p>
<p><img src="/posts/671ebf76/时钟中断流程图.drawio.png" alt="时钟中断流程图.drawio"></p>
<h3 id="6-2-恢复另一个现场"><a href="#6-2-恢复另一个现场" class="headerlink" title="6.2 恢复另一个现场"></a>6.2 恢复另一个现场</h3><p>这是跟其他异常最大的区别。就是其他异常都是在操作系统运行完异常处理程序以后，就会返回那个引发异常的进程。但是时钟中断不是，它不会返回发生异常的那个进程，而是重新挑选一个进程去运行。</p>
<p>这就提出了一个很严峻的问题，就是 <code>TIMESTACK</code> 不够用了，因为对于其他异常，我们会把用户进程的现场存储在内核栈上，在干完事情以后再从内核栈上把这个现场恢复了。但是对于进程调度，这个就不行了，因为栈上存储的还是原来进程的现场，所以即使在某个函数里把现场调整成了新进程的现场，但是一个 <code>ret_from_exception</code> 就又给恢复了。正是因为如此，在流程图中可以看到，这个流程里是没有 <code>ret_from_exception</code> 的。不仅如此，我们还需要把被替换掉的进程上下文保存在进程控制块中，这是因为不然等这个进程再次被调用的时候，又怎么知道当时的现场是啥呢？这件事也可以这样理解，就是我们恢复现场的来源变成了不再是从 <code>TIMESTACK</code> 上，而是从进程控制块里。</p>
<h3 id="6-3-handle-int"><a href="#6-3-handle-int" class="headerlink" title="6.3 handle_int"></a>6.3 handle_int</h3><p>先是在栈上保存用户寄存器的值，都是调用 SAVE_ALL。这个函数有两个功能，一个是选择一个内核栈（是 <code>KERNEL_SP</code> 还是 <code>TIMESTACK</code>）。另一个是在栈上报存寄存器。在时钟中断中，我们选择的是 <code>TIMESTACK</code>。</p>
<pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">SAVE_ALL<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>然后是禁用一切异常，这是通过将 <code>STATUS</code> 的最低位清 0 设置的</p>
<pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">CLI<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>然后就进入了特殊环节，每个异常处理程序具体会变得存在差异，我们首先检验是不是时钟中断，利用的是 <code>STATUS</code> 和 <code>CAUSE</code> 寄存器的值，这里可能是 <code>handle_int</code> 要单独处理的原因，因为时钟中断是一个外部中断，所以在处理的时候要检测<strong>中断掩码</strong>，而其他的很多异常是不需要检测中断掩码的。</p>
<pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly"># 上面所作的一切都是为了检验是不是时钟中断
mfc0		t0, 		CP0_CAUSE
mfc0		t2, 		CP0_STATUS
and			t0, 		t2
andi		t1, 		t0, 		STATUSF_IP4<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>当检测通过之后，我们需要进行真正的处理。首先是要响应时钟的信号（可能是为了让这个信号停止吧，计组中也出现过）</p>
<pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">sb 			zero, 		0xb5000110<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>然后跳到 C 的调度函数中</p>
<pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">j			sched_yield<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>最后由恢复了统一的格式，即所有异常都需要恢复用户寄存器的值，并且将控制权重新归还给用户进程，但是这个函数从来不会用到，因为前面跳 <code>sched_yield</code> 连 <code>jal</code> 都没用。</p>
<pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">j			ret_from_exception<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<h3 id="6-4-env-yield"><a href="#6-4-env-yield" class="headerlink" title="6.4 env_yield"></a>6.4 env_yield</h3><p>这个函数实现的功能是进行进程调度，即选择一个进程去运行。根据函数的名字，其实是当前进程进行一次谦让，然后如果谦让成功就会挑选另一个进程去运行，这大概就是调度方式。</p>
<p>这个函数还是一个非常困难的函数的，首先我们需要知道一些 C 的语法知识。对于一个静态局部变量，只会初始化一次，并且其值不会在函数外部发生变化，所以这三个数只有在第一次执行 <code>env_yield</code> 的时候是这三个值，之后执行的时候不会赋值。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">static</span> <span class="token keyword">int</span> count <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> 			<span class="token comment">// remaining time slices of current env</span>
<span class="token keyword">static</span> <span class="token keyword">int</span> point <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> 			<span class="token comment">// current env_sched_list index</span>
<span class="token keyword">static</span> <span class="token keyword">struct</span> <span class="token class-name">Env</span> <span class="token operator">*</span>e <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>	<span class="token comment">// the current env</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p><code>count</code> 表示当前进程还剩多少个时间片，<code>point</code> 表示当前用的是哪一个调度链表，<code>e</code> 是当前进程，那么为啥不用 <code>curenv</code> 。我觉得是因为 <code>e</code> 在这个函数里还有 “遍历” 的功能，而且在其他函数里还设置了这个，所以实在是没必要。</p>
<p>我们首先要明确要挑一个进程的条件，有三个：</p>
<ul>
<li>当前的时间片为0</li>
<li>第一次调度，要挑一个</li>
<li>当前进程的状态不再是可运行的</li>
</ul>
<p>对应了下面的三个条件</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">if</span> <span class="token punctuation">(</span>count <span class="token operator">==</span> <span class="token number">0</span> <span class="token operator">||</span> e <span class="token operator">==</span> <span class="token constant">NULL</span> <span class="token operator">||</span> e<span class="token operator">-&gt;</span>env_status <span class="token operator">!=</span> ENV_RUNNABLE<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>这里提一嘴 MOS 中的三个状态，<code>ENV_RUNNABLE</code> 对应的是当前运行和就绪的进程，<code>ENV_NOT_RUNNABLE</code> 指的是被阻塞的进程，即缺少一定条件的进程，<code>ENV_FREE</code> 指的是空闲的进程，它们应该被插入到 <code>free_list</code> 中。</p>
<p>我们首先要把这个要被替换掉的进程从当前的队列中移除掉，然后根据它的状态考虑要不要把他插入到另一个队列的队尾</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">if</span> <span class="token punctuation">(</span>e <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token function">LIST_REMOVE</span><span class="token punctuation">(</span>e<span class="token punctuation">,</span> env_sched_link<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>e<span class="token operator">-&gt;</span>env_status <span class="token operator">!=</span> ENV_FREE<span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        <span class="token function">LIST_INSERT_TAIL</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>env_sched_list<span class="token punctuation">[</span><span class="token number">1</span> <span class="token operator">-</span> point<span class="token punctuation">]</span><span class="token punctuation">,</span> e<span class="token punctuation">,</span> env_sched_link<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>然后考虑挑出下一个要运行的进程，方法是遍历链表</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token function">LIST_EMPTY</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>env_sched_list<span class="token punctuation">[</span>point<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
        point <span class="token operator">=</span> <span class="token number">1</span> <span class="token operator">-</span> point<span class="token punctuation">;</span>
    e <span class="token operator">=</span> <span class="token function">LIST_FIRST</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>env_sched_list<span class="token punctuation">[</span>point<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>e<span class="token operator">-&gt;</span>env_status <span class="token operator">==</span> ENV_FREE<span class="token punctuation">)</span>
        <span class="token function">LIST_REMOVE</span><span class="token punctuation">(</span>e<span class="token punctuation">,</span> env_sched_link<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>e<span class="token operator">-&gt;</span>env_status <span class="token operator">==</span> ENV_NOT_RUNNABLE<span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        <span class="token function">LIST_REMOVE</span><span class="token punctuation">(</span>e<span class="token punctuation">,</span> env_sched_link<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">LIST_INSERT_TAIL</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>env_sched_list<span class="token punctuation">[</span><span class="token number">1</span> <span class="token operator">-</span> point<span class="token punctuation">]</span><span class="token punctuation">,</span> e<span class="token punctuation">,</span> env_sched_link<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">else</span>
    <span class="token punctuation">{</span>
        count <span class="token operator">=</span> e<span class="token operator">-&gt;</span>env_pri<span class="token punctuation">;</span>
        <span class="token keyword">break</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>挑出后就可以运行了</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c">count<span class="token operator">--</span><span class="token punctuation">;</span>
e<span class="token operator">-&gt;</span>env_runs<span class="token operator">++</span><span class="token punctuation">;</span>
<span class="token function">env_run</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>这里有个细节是无论换不换进程，都会进行一个 <code>env_run</code> 的操作。我一开始觉得很没必要，因为只有换进程才有执行env_run的必要。如果不换进程，<code>env_yield</code> 会正常返回，那么就会由 <code>ret_from_exception</code>恢复现场。但是我发现呵呵，<code>time_irq</code> 里调用 <code>env_yield</code> 用的是 <code>j</code> 而不是 <code>jal</code> ，也就是说 MOS 就没把 <code>env_yield</code> 当作一个可以返回的函数用。</p>
<p>最后看一下整体的布局：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">sched_yield</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">static</span> <span class="token keyword">int</span> count <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token comment">// remaining time slices of current env</span>
    <span class="token keyword">static</span> <span class="token keyword">int</span> point <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token comment">// current env_sched_list index</span>
    <span class="token keyword">static</span> <span class="token keyword">struct</span> <span class="token class-name">Env</span> <span class="token operator">*</span>e <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>
    <span class="token comment">/*  hint:
     *  1. if (count==0), insert `e` into `env_sched_list[1-point]`
     *     using LIST_REMOVE and LIST_INSERT_TAIL.
     *  2. if (env_sched_list[point] is empty), point = 1 - point;
     *     then search through `env_sched_list[point]` for a runnable env `e`, 
     *     and set count = e-&gt;env_pri
     *  3. count--
     *  4. env_run()
     *
     *  functions or macros below may be used (not all):
     *  LIST_INSERT_TAIL, LIST_REMOVE, LIST_FIRST, LIST_EMPTY
     */</span>

    <span class="token keyword">if</span> <span class="token punctuation">(</span>count <span class="token operator">==</span> <span class="token number">0</span> <span class="token operator">||</span> e <span class="token operator">==</span> <span class="token constant">NULL</span> <span class="token operator">||</span> e<span class="token operator">-&gt;</span>env_status <span class="token operator">!=</span> ENV_RUNNABLE<span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>e <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>
        <span class="token punctuation">{</span>
            <span class="token function">LIST_REMOVE</span><span class="token punctuation">(</span>e<span class="token punctuation">,</span> env_sched_link<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>e<span class="token operator">-&gt;</span>env_status <span class="token operator">!=</span> ENV_FREE<span class="token punctuation">)</span>
            <span class="token punctuation">{</span>
                <span class="token function">LIST_INSERT_TAIL</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>env_sched_list<span class="token punctuation">[</span><span class="token number">1</span> <span class="token operator">-</span> point<span class="token punctuation">]</span><span class="token punctuation">,</span> e<span class="token punctuation">,</span> env_sched_link<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>
        <span class="token punctuation">{</span>
            <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token function">LIST_EMPTY</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>env_sched_list<span class="token punctuation">[</span>point<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
                point <span class="token operator">=</span> <span class="token number">1</span> <span class="token operator">-</span> point<span class="token punctuation">;</span>
            e <span class="token operator">=</span> <span class="token function">LIST_FIRST</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>env_sched_list<span class="token punctuation">[</span>point<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>e<span class="token operator">-&gt;</span>env_status <span class="token operator">==</span> ENV_FREE<span class="token punctuation">)</span>
                <span class="token function">LIST_REMOVE</span><span class="token punctuation">(</span>e<span class="token punctuation">,</span> env_sched_link<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>e<span class="token operator">-&gt;</span>env_status <span class="token operator">==</span> ENV_NOT_RUNNABLE<span class="token punctuation">)</span>
            <span class="token punctuation">{</span>
                <span class="token function">LIST_REMOVE</span><span class="token punctuation">(</span>e<span class="token punctuation">,</span> env_sched_link<span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token function">LIST_INSERT_TAIL</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>env_sched_list<span class="token punctuation">[</span><span class="token number">1</span> <span class="token operator">-</span> point<span class="token punctuation">]</span><span class="token punctuation">,</span> e<span class="token punctuation">,</span> env_sched_link<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
            <span class="token keyword">else</span>
            <span class="token punctuation">{</span>
                count <span class="token operator">=</span> e<span class="token operator">-&gt;</span>env_pri<span class="token punctuation">;</span>
                <span class="token keyword">break</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    count<span class="token operator">--</span><span class="token punctuation">;</span>
    e<span class="token operator">-&gt;</span>env_runs<span class="token operator">++</span><span class="token punctuation">;</span>
    <span class="token function">env_run</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="6-5-新进程运行"><a href="#6-5-新进程运行" class="headerlink" title="6.5 新进程运行"></a>6.5 新进程运行</h3><h4 id="6-5-1-lcontext"><a href="#6-5-1-lcontext" class="headerlink" title="6.5.1 lcontext"></a>6.5.1 lcontext</h4><p>当 <code>env_run</code> 被调用的时候，会调用这个函数，来改变 <code>mCONTEXT</code> 的值，有一说一，我不知道为啥要写一个汇编来实现这个功能，我觉得普通 C 语言就够了</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">/* Step 3: Use lcontext() to switch to its address space. */</span>
<span class="token function">lcontext</span><span class="token punctuation">(</span>curenv<span class="token operator">-&gt;</span>env_pgdir<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>这是具体的汇编</p>
<pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">LEAF(lcontext)
		.extern	    mCONTEXT
		sw		    a0,         mCONTEXT
		jr	        ra
		nop
END(lcontext)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>可以看到 mCONTEXT 被赋值成了 <code>curenv-&gt;env_pgdir</code> 。</p>
<p>这里讲一下 <code>mCONTEXT</code> 的作用，主要是用在 <code>do_refill</code> 中，汇编会根据虚拟地址和页目录去定位页表。所以需要用到</p>
<pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">lw		k1,			mCONTEXT
and		k1,			0xfffff000
mfc0	k0,			CP0_BADVADDR
srl		k0,			20
and		k0,			0xfffffffc
addu	k0,			k1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>具体的我在前面那一章讲到了。</p>
<h4 id="6-5-2-env-pop-tf"><a href="#6-5-2-env-pop-tf" class="headerlink" title="6.5.2 env_pop_tf"></a>6.5.2 env_pop_tf</h4><p>这个函数的最重要作用就是将处理器的控制权从操作系统手中交还给了用户进程。在这个函数里，我们会恢复用户进程的寄存器值，并且将 PC 重新设置成用户进程的 PC（之前是操作系统的 PC）。</p>
<p>同样也是在 <code>env_run</code> 中被调用，具体的调用如下，这里需要注意的是恢复现场是根据进程控制块的 <code>tf</code> 恢复的，而不是根据 <code>TIMESTACK</code> 恢复的</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token function">env_pop_tf</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token punctuation">(</span>curenv<span class="token operator">-&gt;</span>env_tf<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">GET_ENV_ASID</span><span class="token punctuation">(</span>curenv<span class="token operator">-&gt;</span>env_id<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>我们来解析一下这个函数</p>
<pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">LEAF(env_pop_tf)
.set	mips1
		//1:	j	1b
	nop
		# k0 is the address of e.tf
		move		k0,         a0
		mtc0	    a1,         CP0_ENTRYHI
		# 这里的操作相当于清空 CP0_STATUS 的后两位，达到的效果就是说明在内核态，而且禁止中断
		mfc0	    t0,         CP0_STATUS
		ori	        t0,         0x3
		xori	    t0,         0x3
		mtc0	    t0,         CP0_STATUS
		# 这里是分别恢复 LO, HI, EPC，可能顺序稍微有点奇怪，不知道为啥
		lw	        v1,         TF_LO(k0)
		mtlo	    v1
		lw	        v0,         TF_HI(k0)
		lw	        v1,         TF_EPC(k0)
		mthi	    v0
		mtc0	    v1,         CP0_EPC
		# 后面是按照 curenv 的 tf 恢复现场
		lw	$31,TF_REG31(k0)
		lw	$30,TF_REG30(k0)
		lw	$29,TF_REG29(k0)
		lw	$28,TF_REG28(k0)
		lw	$25,TF_REG25(k0)
		lw	$24,TF_REG24(k0)
		lw	$23,TF_REG23(k0)
		lw	$22,TF_REG22(k0)
		lw	$21,TF_REG21(k0)
		lw	$20,TF_REG20(k0)
		lw	$19,TF_REG19(k0)
		lw	$18,TF_REG18(k0)
		lw	$17,TF_REG17(k0)
		lw	$16,TF_REG16(k0)
		lw	$15,TF_REG15(k0)
		lw	$14,TF_REG14(k0)
		lw	$13,TF_REG13(k0)
		lw	$12,TF_REG12(k0)
		lw	$11,TF_REG11(k0)
		lw	$10,TF_REG10(k0)
		lw	$9,TF_REG9(k0)
		lw	$8,TF_REG8(k0)
		lw	$7,TF_REG7(k0)
		lw	$6,TF_REG6(k0)
		lw	$5,TF_REG5(k0)
		lw	$4,TF_REG4(k0)
		lw	$3,TF_REG3(k0)
		lw	$2,TF_REG2(k0)
		lw	$1,TF_REG1(k0)
		lw	        k1,         TF_PC(k0)
		lw	        k0,         TF_STATUS(k0)
		nop
		mtc0	    k0,         CP0_STATUS
		# k1 是 EPC 的值，现在可以跳转到那里运行了
		j			k1
		// 恢复中断设置
		rfe
		nop

END(env_pop_tf)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>也就是说，这个函数实现的是一个把一个即将调用的进程的上下文恢复并且设置 PC 的功能。</p>
<p>这里说一下 <code>rfe</code> 指令，这个指令会对 <code>sTATUS</code> 的后六位寄存器进行一个弹栈的操作，所以是在这一步恢复的异常</p>
<p>此外，在这个文件里（<code>env_asm.S</code>），还声明了一个变量</p>
<pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">			.data
			.global	KERNEL_SP;
KERNEL_SP:
			.word		0<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>这个值因为是是 <code>.data</code> 段，所以属于一个全局变量。也就是在高地址区一个很低的地方，我们待会在说</p>
<h4 id="6-5-3-env-run"><a href="#6-5-3-env-run" class="headerlink" title="6.5.3 env_run"></a>6.5.3 env_run</h4><p>在了解上面的函数的作用后，我们就可以看 <code>env_run</code> 的作用了，他完成了一个将一个运行一个用户进程的功能。需要注意的是，这个函数是一个操作系统的函数，所以最后这个函数的目的是把控制权重新交还给用户进程。</p>
<p>首先他把前面的进程在的 tf 换成了 <code>TIMESTACK</code> 中的值。那么这里面的值是什么呢？其实在 <code>SAVE_ALL</code> 中有描述，正是即将被换掉的进程的上下文。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">if</span> <span class="token punctuation">(</span>curenv <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
	<span class="token keyword">struct</span> <span class="token class-name">Trapframe</span> <span class="token operator">*</span>old <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">Trapframe</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">(</span>TIMESTACK <span class="token operator">-</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">Trapframe</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">bcopy</span><span class="token punctuation">(</span>old<span class="token punctuation">,</span> <span class="token operator">&amp;</span><span class="token punctuation">(</span>curenv<span class="token operator">-&gt;</span>env_tf<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">Trapframe</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	curenv<span class="token operator">-&gt;</span>env_tf<span class="token punctuation">.</span>pc <span class="token operator">=</span> curenv<span class="token operator">-&gt;</span>env_tf<span class="token punctuation">.</span>cp0_epc<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>然后设置当前进程为要 run 的那个进程，相当于进行一个操作系统登记</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c">curenv <span class="token operator">=</span> e<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>下面两个函数用于恢复进程的上下文</p>
<p>将页表换成这个进程的页表，及恢复虚拟环境</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token function">lcontext</span><span class="token punctuation">(</span>curenv<span class="token operator">-&gt;</span>env_pgdir<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>恢复这个进程的上下文，并跳转到用户进程</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token function">env_pop_tf</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token punctuation">(</span>curenv<span class="token operator">-&gt;</span>env_tf<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">GET_ENV_ASID</span><span class="token punctuation">(</span>curenv<span class="token operator">-&gt;</span>env_id<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<h3 id="6-6-计时器的设置"><a href="#6-6-计时器的设置" class="headerlink" title="6.6 计时器的设置"></a>6.6 计时器的设置</h3><p>这一节并不属于异常处理流程，而是一些关于计时器的设置，也就是说，属于操作系统的初始化部分，在这里记录一下，主要是 <strong>set_timer</strong>这个函数用于开启时钟计时器并且开启中断（中断在 <code>start.S</code> 中关闭了）</p>
<pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">.macro	setup_c0_status set clr
	.set	push
	mfc0	t0,         CP0_STATUS
	or	    t0,         \set|\clr
	xor	    t0,         \clr
	mtc0	t0, 		CP0_STATUS			
	.set	pop
.endm

	.text
LEAF(set_timer)
	li      t0,             0xc8
	sb      t0,             0xb5000100
	sw	    sp, 			KERNEL_SP
    setup_c0_status     	STATUS_CU0|0x1001 			0
	jr 		ra
	nop
END(set_timer)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>这里先介绍一下 MOS 计时器的配置</p>
<p><img src="/posts/671ebf76/微信图片_20220510093613.jpg" alt="微信图片_20220510093613"></p>
<p>可以看到，这个函数的前两句将产生时钟中断的频率设置在了 200 次 / 秒。 </p>
<pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">li      t0,             0xc8
sb      t0,             0xb5000100<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>然后它进行了一个赋值</p>
<pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">sw	    sp, 			KERNEL_SP<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>他将这个时刻的栈指针存储在一个叫做 <code>KERNEL_SP</code> 的变量中，这个变量就定义在 <code>env_asm.S</code> 中，就一个字大小。</p>
<hr>
<h2 id="七、读写异常"><a href="#七、读写异常" class="headerlink" title="七、读写异常"></a>七、读写异常</h2><h3 id="7-1-总体概述"><a href="#7-1-总体概述" class="headerlink" title="7.1 总体概述"></a>7.1 总体概述</h3><p>这个是当我们去写只读页面的时候，就会触发这个异常。但是这还不够精确，因为我们不会闲的没事去写一个只读的页面，所以很多时候就是发生在写时复制的情况，也就是当父进程 <code>fork</code> 出一个子进程的时候，父子进程都会把基本上所有的可写页面设置成 COW，而这些页面在通过 <code>do_refill</code> 进入 TLB 之后，都会变成只读页面，而当我们尝试去写这个只读页面的时候（我们不知道它已经变成只读的了），就会有异常发生，就是这个异常，这个异常会复制出一个页面来，这样两人就不存在“共享写”的情况了。</p>
<p>具体流程如下：</p>
<p><img src="/posts/671ebf76/写时复制异常流程图.drawio.png" alt="写时复制异常流程图.drawio"></p>
<h3 id="7-2-微内核设计"><a href="#7-2-微内核设计" class="headerlink" title="7.2 微内核设计"></a>7.2 微内核设计</h3><h4 id="7-2-1-分布式"><a href="#7-2-1-分布式" class="headerlink" title="7.2.1 分布式"></a>7.2.1 分布式</h4><p>微内核设计可以看做是将本来应该由操作系统负责的一些功能，移出到了用户进程中负责。在这个异常处理中，操作系统并不会处理异常，而是将异常处理的任务转交给用户进程。</p>
<p>这就涉及一个很有意思的问题，就是如果这些函数不是在内核中实现的，那么它就应该是每个用户进程都各自有一个的，这是因为如果由某个进程独占，那么本质上其实还是操作系统的性质，只不过是一个被放在低位的操作系统罢了。所以一定是每个用户进程都有异常处理函数的，就像一个分布式的操作系统，而微内核带来的好处就是一个用户进程崩了，但是其他进程的异常处理函数还能用，这正是分布式的好处。</p>
<p>具体的实现分布式，就是在 <code>Makefile</code> 中实现的</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token operator">%</span><span class="token punctuation">.</span>b<span class="token operator">:</span> entry<span class="token punctuation">.</span>o syscall_wrap<span class="token punctuation">.</span>o <span class="token operator">%</span><span class="token punctuation">.</span>o $<span class="token punctuation">(</span>USERLIB<span class="token punctuation">)</span>
	echo ld $@
	$<span class="token punctuation">(</span>LD<span class="token punctuation">)</span> <span class="token operator">-</span>o $@ $<span class="token punctuation">(</span>LDFLAGS<span class="token punctuation">)</span> <span class="token operator">-</span>G <span class="token number">0</span> <span class="token operator">-</span><span class="token keyword">static</span> <span class="token operator">-</span>n <span class="token operator">-</span>nostdlib <span class="token operator">-</span>T <span class="token punctuation">.</span><span class="token operator">/</span>user<span class="token punctuation">.</span>lds $<span class="token operator">^</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>最后说一嘴闲话，这个东西让应用程序的移植问题暴露出来，因为每个操作系统的系统调用和异常处理都是不同的，所以一个应用程序移植到操作系统上也是有一大堆需要改的</p>
<blockquote>
<p>操作系统移植考虑的是 ABI，应用程序移植考虑的是 API。</p>
</blockquote>
<h4 id="7-2-2-用户异常栈"><a href="#7-2-2-用户异常栈" class="headerlink" title="7.2.2 用户异常栈"></a>7.2.2 用户异常栈</h4><p>与我们需要内核栈的原因相同，我们依然不能在原来的用户栈上进行异常处理，我们需要在用户进程的虚拟地址空间上另外找一个地方，来当我们的异常处理栈，最后我们找到了，如图所示</p>
<p><img src="/posts/671ebf76/image-20220516163430299.png" alt="image-20220516163430299"></p>
<h3 id="7-3-内核部分"><a href="#7-3-内核部分" class="headerlink" title="7.3 内核部分"></a>7.3 内核部分</h3><p>内核部分采用的也是一个异常包装函数，所以主要的功能实现就是底下这个函数 <code>page_fault_handler</code>。</p>
<p>这是异常处理函数，是一个内核函数，其地位与 <code>do_refill</code> 类似，都是被包装过的。那么它到底进行了一个怎样的过程呢？。其实就是先看这个用户进程的栈指针在哪里，如果还在 <code>xstacktop</code> 这个页面上，就让其保存一下 <code>tf</code> 。如果已经超过了，那么就将栈指针重新定位到 <code>xstacktop</code> 然后再保存 <code>tf</code>。</p>
<p>也就是下面的代码</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token function">bcopy</span><span class="token punctuation">(</span>tf<span class="token punctuation">,</span> <span class="token operator">&amp;</span>PgTrapFrame<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">Trapframe</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">if</span> <span class="token punctuation">(</span>tf<span class="token operator">-&gt;</span>regs<span class="token punctuation">[</span><span class="token number">29</span><span class="token punctuation">]</span> <span class="token operator">&gt;=</span> <span class="token punctuation">(</span>curenv<span class="token operator">-&gt;</span>env_xstacktop <span class="token operator">-</span> BY2PG<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span>
    tf<span class="token operator">-&gt;</span>regs<span class="token punctuation">[</span><span class="token number">29</span><span class="token punctuation">]</span> <span class="token operator">&lt;=</span> <span class="token punctuation">(</span>curenv<span class="token operator">-&gt;</span>env_xstacktop <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    tf<span class="token operator">-&gt;</span>regs<span class="token punctuation">[</span><span class="token number">29</span><span class="token punctuation">]</span> <span class="token operator">=</span> tf<span class="token operator">-&gt;</span>regs<span class="token punctuation">[</span><span class="token number">29</span><span class="token punctuation">]</span> <span class="token operator">-</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">Trapframe</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">bcopy</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>PgTrapFrame<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span><span class="token punctuation">)</span>tf<span class="token operator">-&gt;</span>regs<span class="token punctuation">[</span><span class="token number">29</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">Trapframe</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">else</span>
<span class="token punctuation">{</span>
    tf<span class="token operator">-&gt;</span>regs<span class="token punctuation">[</span><span class="token number">29</span><span class="token punctuation">]</span> <span class="token operator">=</span> curenv<span class="token operator">-&gt;</span>env_xstacktop <span class="token operator">-</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">Trapframe</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">bcopy</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>PgTrapFrame<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span><span class="token punctuation">)</span>curenv<span class="token operator">-&gt;</span>env_xstacktop <span class="token operator">-</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">Trapframe</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">Trapframe</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>然后把 <code>EPC</code> 设置成 <code>env_pgfault_handler</code> 。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">page_fault_handler</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">Trapframe</span> <span class="token operator">*</span>tf<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">struct</span> <span class="token class-name">Trapframe</span> PgTrapFrame<span class="token punctuation">;</span>
    <span class="token keyword">extern</span> <span class="token keyword">struct</span> <span class="token class-name">Env</span> <span class="token operator">*</span>curenv<span class="token punctuation">;</span>

    <span class="token function">bcopy</span><span class="token punctuation">(</span>tf<span class="token punctuation">,</span> <span class="token operator">&amp;</span>PgTrapFrame<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">Trapframe</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">if</span> <span class="token punctuation">(</span>tf<span class="token operator">-&gt;</span>regs<span class="token punctuation">[</span><span class="token number">29</span><span class="token punctuation">]</span> <span class="token operator">&gt;=</span> <span class="token punctuation">(</span>curenv<span class="token operator">-&gt;</span>env_xstacktop <span class="token operator">-</span> BY2PG<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span>
        tf<span class="token operator">-&gt;</span>regs<span class="token punctuation">[</span><span class="token number">29</span><span class="token punctuation">]</span> <span class="token operator">&lt;=</span> <span class="token punctuation">(</span>curenv<span class="token operator">-&gt;</span>env_xstacktop <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        tf<span class="token operator">-&gt;</span>regs<span class="token punctuation">[</span><span class="token number">29</span><span class="token punctuation">]</span> <span class="token operator">=</span> tf<span class="token operator">-&gt;</span>regs<span class="token punctuation">[</span><span class="token number">29</span><span class="token punctuation">]</span> <span class="token operator">-</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">Trapframe</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">bcopy</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>PgTrapFrame<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span><span class="token punctuation">)</span>tf<span class="token operator">-&gt;</span>regs<span class="token punctuation">[</span><span class="token number">29</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">Trapframe</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">else</span>
    <span class="token punctuation">{</span>
        tf<span class="token operator">-&gt;</span>regs<span class="token punctuation">[</span><span class="token number">29</span><span class="token punctuation">]</span> <span class="token operator">=</span> curenv<span class="token operator">-&gt;</span>env_xstacktop <span class="token operator">-</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">Trapframe</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">bcopy</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>PgTrapFrame<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span><span class="token punctuation">)</span>curenv<span class="token operator">-&gt;</span>env_xstacktop <span class="token operator">-</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">Trapframe</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">Trapframe</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token comment">// TODO: Set EPC to a proper value in the trapframe</span>
    tf<span class="token operator">-&gt;</span>cp0_epc <span class="token operator">=</span> curenv<span class="token operator">-&gt;</span>env_pgfault_handler<span class="token punctuation">;</span>
    
    <span class="token keyword">return</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>这个函数最有意思的是，他全程的赋值都是用的 <code>env</code> 里的成员，而没有用实际的值，所以 <code>env</code> 成员的值又是谁赋的呢？是在 <code>sys_set_pgfault_handler</code> 这个函数中完成的。但是这个函数对于 <code>env</code> 的赋值依然是通过传递进来的参数，那么 <code>sys_set_pgfault_handler</code> 又是谁调用的呢？是 <code>syscall_set_pgfault_handler</code> ，这是一个系统调用，但是依然是通过传参进行的，所以还要考虑这个系统调用是谁调用的？是在 <code>fork</code> 函数中的这句调用</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token function">syscall_set_pgfault_handler</span><span class="token punctuation">(</span>newenvid<span class="token punctuation">,</span> __asm_pgfault_handler<span class="token punctuation">,</span> UXSTACKTOP<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p><code>UXSTACKTOP</code> 这个值就是 <code>UTOP</code> ，关于 <code>__asm_pgfault_handler</code> ，会单独开设一章介绍。</p>
<p>这里面还有一个有意思的点，就是在使用 <code>bcopy</code> 的时候，出现了低地址区，就是这里</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token function">bcopy</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>PgTrapFrame<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span><span class="token punctuation">)</span>tf<span class="token operator">-&gt;</span>regs<span class="token punctuation">[</span><span class="token number">29</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">Trapframe</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>这里的 <code>tf-&gt;regs[29]</code> 是低地址区的地址，但是在内核态依然写了。这个与我之前在《操作系统不相信抽象》中说的是不一致的，那篇博客最后看起来漏洞百出，不止这一处。</p>
<p>现在看上去应该是这样的，MMU 是一个硬件结构，他接受虚拟地址转换成物理地址，对于高地址，他会选择高三位抹零转换，而对于低地址，他会选择在 TLB 中查找转换。</p>
<h3 id="7-4-用户部分"><a href="#7-4-用户部分" class="headerlink" title="7.4 用户部分"></a>7.4 用户部分</h3><h4 id="7-4-1-asm-pgfault-handler"><a href="#7-4-1-asm-pgfault-handler" class="headerlink" title="7.4.1 __asm_pgfault_handler"></a>7.4.1 __asm_pgfault_handler</h4><p>这个函数就是当 <code>page_fault_handler</code>（异常处理程序）结束以后，返回到用户态之后的第一个函数（严格说就是指令序列，并不算函数），这个函数有两个功能，一个是跳转到 <code>__pgfault_handler</code> 中，这个函数被 <code>set_pgfault_handler</code> 设置为 <code>pgfault</code>。然后在结束完真正的处理以后，会重新恢复现场，这是因为恢复现场本应该在内核态完成，但是实际上并没有完成，所以需要在用户态恢复现场。</p>
<pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">__asm_pgfault_handler:
	// save the caller-save registers
	lw		a0, 		TF_BADVADDR(sp)
	lw		t1, 		__pgfault_handler
	jalr	t1
	nop
	
	lw		v1,	TF_LO(sp)
    mtlo	v1
    lw		v0,	TF_HI(sp)
    lw		v1,	TF_EPC(sp)
    mthi	v0
    mtc0	v1,	CP0_EPC
    lw	$31,TF_REG31(sp)
    lw	$30,TF_REG30(sp)
    lw	$28,TF_REG28(sp)
    lw	$25,TF_REG25(sp)
    lw	$24,TF_REG24(sp)
    lw	$23,TF_REG23(sp)
    lw	$22,TF_REG22(sp)
    lw	$21,TF_REG21(sp)
    lw	$20,TF_REG20(sp)
    lw	$19,TF_REG19(sp)
    lw	$18,TF_REG18(sp)
    lw	$17,TF_REG17(sp)
    lw	$16,TF_REG16(sp)
    lw	$15,TF_REG15(sp)
    lw	$14,TF_REG14(sp)
    lw	$13,TF_REG13(sp)
    lw	$12,TF_REG12(sp)
    lw	$11,TF_REG11(sp)
    lw	$10,TF_REG10(sp)
    lw	$9,TF_REG9(sp)
    lw	$8,TF_REG8(sp)
    lw	$7,TF_REG7(sp)
    lw	$6,TF_REG6(sp)
    lw	$5,TF_REG5(sp)
    lw	$4,TF_REG4(sp)
    lw	$3,TF_REG3(sp)
    lw	$2,TF_REG2(sp)
    lw	$1,TF_REG1(sp)
    lw	k0,TF_EPC(sp) 	
    jr	k0
    lw	sp,TF_REG29(sp)  /* Deallocate stack */<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="7-4-2-pgfault"><a href="#7-4-2-pgfault" class="headerlink" title="7.4.2 pgfault"></a>7.4.2 pgfault</h4><p>首先需要强调这是一个用户函数。这个函数实现的是根据虚拟地址 <code>va</code> 为其分配一个物理页面，而且这个新的物理页面要有一些内容。</p>
<p>最有意思的是，这个 <code>va</code> 之前是对应了一个物理页面的（这是一个子进程函数，所以之前是和父进程共享这个页面）。那么我们要实现的，似乎是让一个 <code>va</code> 对应两个物理页面。显然是不合理的。所以严谨地阐述这个函数的功能，是将 <code>va</code> 对应到新的物理页面，并将原来的物理页面映射关系去掉。这个新的物理页面的内容跟原来的物理页面内容一致。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">pgfault</span><span class="token punctuation">(</span>u_int va<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    u_int <span class="token operator">*</span>tmp <span class="token operator">=</span> USTACKTOP<span class="token punctuation">;</span>
    <span class="token comment">//	writef("fork.c:pgfault():\t va:%x\n",va);</span>
    u_long perm <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>Pte <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token operator">*</span>vpt<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token function">VPN</span><span class="token punctuation">(</span>va<span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token operator">&amp;</span> <span class="token number">0xfff</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>perm <span class="token operator">&amp;</span> PTE_COW<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        <span class="token function">user_panic</span><span class="token punctuation">(</span><span class="token string">"pgfault err: COW not found"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    perm <span class="token operator">-=</span> PTE_COW<span class="token punctuation">;</span>
    <span class="token comment">// map the new page at a temporary place</span>
    <span class="token function">syscall_mem_alloc</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> tmp<span class="token punctuation">,</span> perm<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// copy the content</span>
    <span class="token function">user_bcopy</span><span class="token punctuation">(</span><span class="token function">ROUNDDOWN</span><span class="token punctuation">(</span>va<span class="token punctuation">,</span> BY2PG<span class="token punctuation">)</span><span class="token punctuation">,</span> tmp<span class="token punctuation">,</span> BY2PG<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// map the page on the appropriate place</span>
    <span class="token function">syscall_mem_map</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> tmp<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> va<span class="token punctuation">,</span> perm<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// unmap the temporary place</span>
    <span class="token function">syscall_mem_unmap</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> tmp<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>这就引发了一个矛盾，就是如果没有原来的映射关系，我就没有办法把原来物理页面的内容拷贝到新的物理页面上，而保持原来的映射关系，就会存在一个虚拟页面映射新的和旧的两个物理页面的情况。为了解决这个矛盾，我们选择一个临时的虚拟页面去映射这个新的物理页面，然后完成拷贝。在拷贝完成后，再将虚拟地址映射到这个新的物理页面上。</p>
<p>至于选择哪一个虚拟页面，我们选择的是用户栈的上方的一个页面，这个页面是 <code>invalid memory</code> 保证不会被使用。</p>
<h3 id="7-5-设置函数指针"><a href="#7-5-设置函数指针" class="headerlink" title="7.5 设置函数指针"></a>7.5 设置函数指针</h3><p>这是这个异常比较有特点的地方，就是它永远不可能好好的调用各个函数名，而是非得用个类似于函数指针的东西实现调用，最后函数指针和函数名分不开，导致了理解的难度 up。这里进行一个总结</p>
<h4 id="7-1-1-set-pgfault-handler"><a href="#7-1-1-set-pgfault-handler" class="headerlink" title="7.1.1 set_pgfault_handler"></a>7.1.1 set_pgfault_handler</h4><p>这个函数看着很奇怪，是因为把函数调用写到了条件里，其实比较好看懂的写法应该是这样（不严谨）</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">set_pgfault_handler</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token punctuation">(</span><span class="token operator">*</span>fn<span class="token punctuation">)</span><span class="token punctuation">(</span>u_int va<span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span>__pgfault_handler <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> 
    <span class="token punctuation">{</span>
    	<span class="token function">syscall_mem_alloc</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> UXSTACKTOP <span class="token operator">-</span> BY2PG<span class="token punctuation">,</span> PTE_V <span class="token operator">|</span> PTE_R<span class="token punctuation">)</span><span class="token punctuation">;</span>
    	<span class="token function">syscall_set_pgfault_handler</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> __asm_pgfault_handler<span class="token punctuation">,</span> UXSTACKTOP<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>

	<span class="token comment">// Save handler pointer for assembly to call.</span>
	__pgfault_handler <span class="token operator">=</span> fn<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>也就是说，当一个进程第一次调用 <code>fork</code> 的时候（对应的就是 <code>__pgfault_handler == 0</code> ）。那么这个函数就会为他分配出一个用来处理 <code>pgfault</code> 异常的栈，而且设置他处理这种异常的函数是 <code>__asm_pgfault_handler</code> 。</p>
<p>每次这个函数都会将 <code>__pgfault_handler</code> 设置成 <code>fn</code>，在 <code>fork</code> 中是传入参数是 <code>pgfault</code>。 </p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">set_pgfault_handler</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token punctuation">(</span><span class="token operator">*</span>fn<span class="token punctuation">)</span><span class="token punctuation">(</span>u_int va<span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span>__pgfault_handler <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> 
    <span class="token punctuation">{</span>
		<span class="token comment">// Your code here:</span>
		<span class="token comment">// map one page of exception stack with top at UXSTACKTOP</span>
		<span class="token comment">// register assembly handler and stack with operating system</span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">syscall_mem_alloc</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> UXSTACKTOP <span class="token operator">-</span> BY2PG<span class="token punctuation">,</span> PTE_V <span class="token operator">|</span> PTE_R<span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token number">0</span> <span class="token operator">||</span>
			<span class="token function">syscall_set_pgfault_handler</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> __asm_pgfault_handler<span class="token punctuation">,</span> UXSTACKTOP<span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> 
        <span class="token punctuation">{</span>
			<span class="token function">writef</span><span class="token punctuation">(</span><span class="token string">"cannot set pgfault handler\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token keyword">return</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>

		<span class="token comment">//		panic("set_pgfault_handler not implemented");</span>
	<span class="token punctuation">}</span>

	<span class="token comment">// Save handler pointer for assembly to call.</span>
	__pgfault_handler <span class="token operator">=</span> fn<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="7-1-2-sys-set-pgfault-handler"><a href="#7-1-2-sys-set-pgfault-handler" class="headerlink" title="7.1.2 sys_set_pgfault_handler"></a>7.1.2 sys_set_pgfault_handler</h4><p>用来给指定的进程设置它的 <code>pgfault</code> 函数和发生 <code>pgfault</code> 的时候所用的栈，是一个很基础的函数。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">sys_set_pgfault_handler</span><span class="token punctuation">(</span><span class="token keyword">int</span> sysno<span class="token punctuation">,</span> u_int envid<span class="token punctuation">,</span> u_int func<span class="token punctuation">,</span> u_int xstacktop<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token comment">// Your code here.</span>
    <span class="token keyword">struct</span> <span class="token class-name">Env</span> <span class="token operator">*</span>env<span class="token punctuation">;</span>
    <span class="token keyword">int</span> ret<span class="token punctuation">;</span>

    <span class="token comment">// get the env</span>
    ret <span class="token operator">=</span> <span class="token function">envid2env</span><span class="token punctuation">(</span>envid<span class="token punctuation">,</span> <span class="token operator">&amp;</span>env<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>ret<span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        <span class="token keyword">return</span> ret<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment">// set the env_pgfault_handler as the set_pgfault_handler</span>
    env<span class="token operator">-&gt;</span>env_pgfault_handler <span class="token operator">=</span> func<span class="token punctuation">;</span>
    env<span class="token operator">-&gt;</span>env_xstacktop <span class="token operator">=</span> xstacktop<span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token comment">//	panic("sys_set_pgfault_handler not implemented");</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>这个函数会在 <code>fork</code> 中被调用，可以理解成需要给子进程设置一些状态，好让它比较方便</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token function">syscall_set_pgfault_handler</span><span class="token punctuation">(</span>newenvid<span class="token punctuation">,</span> __asm_pgfault_handler<span class="token punctuation">,</span> UXSTACKTOP<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<hr>
<h2 id="八、系统调用异常"><a href="#八、系统调用异常" class="headerlink" title="八、系统调用异常"></a>八、系统调用异常</h2><h3 id="8-1-总体概述"><a href="#8-1-总体概述" class="headerlink" title="8.1 总体概述"></a>8.1 总体概述</h3><p>前面的异常或多或少都有“被动”的成分，而系统调用是一种主动的异常，主要是通过陷入异常来获得一些更高权限的功能，所以这个异常逻辑是很简单的，复杂的是不同的系统调用的处理，流程如下：</p>
<p><img src="/posts/671ebf76/系统调用流程图.drawio.png" alt="系统调用流程图.drawio"></p>
<h3 id="8-2-系统调用的前期"><a href="#8-2-系统调用的前期" class="headerlink" title="8.2 系统调用的前期"></a>8.2 系统调用的前期</h3><h4 id="8-2-1-syscall"><a href="#8-2-1-syscall" class="headerlink" title="8.2.1 syscall_*"></a>8.2.1 syscall_*</h4><p>所有的系统调用函数在用户进程看来都长成这样</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c">syscall_<span class="token operator">*</span><span class="token punctuation">(</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>然后他们所有函数都会调用 <code>myscall</code>，大概这样</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token function">msyscall</span><span class="token punctuation">(</span>id<span class="token punctuation">,</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p><code>id</code> 就是系统调用号，他跟异常分发一样，都是由一个类似于数组的结构去分发</p>
<h4 id="8-2-2-msyscall"><a href="#8-2-2-msyscall" class="headerlink" title="8.2.2 msyscall"></a>8.2.2 msyscall</h4><p>这是一个用户态函数，其实就是执行了 <code>syscall</code>。这条指令会触发一个异常，然后计算机就会进入中断，但是注意，即使是这样，也不能将 <code>syscall</code> 看作一个函数调用。之所以强调这点，是因为 <code>handle_sys</code> 会使用传给 <code>mysyscall</code> 的参数</p>
<pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">LEAF(msyscall) 
    syscall
	nop
	jr		ra
	nop
END(msyscall)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>我们来看一下它的参数都有啥</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token function">msyscall</span><span class="token punctuation">(</span>SYS_putchar<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span>ch<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">msyscall</span><span class="token punctuation">(</span>SYS_getenvid<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>其实每一个都不一样，这是因为只有第一个参数是为了让 <code>handler_sys</code> 选择使用哪个系统调用，而其他的参数都是为了某个具体的系统调用服务的，所以不一样。但是为了规格的统一，所以用 0 占位。</p>
<h4 id="8-2-3-handle-sys"><a href="#8-2-3-handle-sys" class="headerlink" title="8.2.3 handle_sys"></a>8.2.3 handle_sys</h4><p>与 <code>handle_int</code> 类似，都是没有用模板，但是跟用了模板没啥区别的异常处理函数。</p>
<p>上来依然是换栈，关异常，保存现场</p>
<pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">SAVE_ALL                            // Macro used to save trapframe
CLI                                 // Clean Interrupt Mask<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>然后是系统调用的一个特色，他的返回 <code>PC</code> 不是 <code>EPC</code>，而是 <code>EPC+4</code> 因为 <code>EPC</code> 对应的是 <code>syscall</code> 这条指令，所以应该返回下一条指令。</p>
<pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">// TODO: Fetch EPC from Trapframe, calculate a proper value and store it back to trapframe.
lw		t0, TF_EPC(sp)
addiu	t0, t0, 4
sw		t0, TF_EPC(sp)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>然后是根据系统调用号（也就是 <code>myscall</code> 的第一个参数）来确定需要的具体的系统调用，其原理类似与异常处理表的查询</p>
<pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">// TODO: Copy the syscall number into $a0.
lw		a0, TF_REG4(sp)
addiu   a0, a0, -__SYSCALL_BASE     // a0 &lt;- relative syscall number
sll     t0, a0, 2                   // t0 &lt;- relative syscall number times 4
la      t1, sys_call_table          // t1 &lt;- syscall table base
addu    t1, t1, t0                  // t1 &lt;- table entry of specific syscall
lw      t2, 0(t1)                   // t2 &lt;- function entry of specific syscall

.data
sys_call_table:                         // Syscall Table
.align 2
.word sys_putchar
.word sys_getenvid
.word sys_yield
.word sys_env_destroy
.word sys_set_pgfault_handler
.word sys_mem_alloc
.word sys_mem_map
.word sys_mem_unmap
.word sys_env_alloc
.word sys_set_env_status
.word sys_set_trapframe
.word sys_panic
.word sys_ipc_can_send
.word sys_ipc_recv
.word sys_cgetc<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>然后要获得第五个和第六个参数，这个同样是有 <code>ABI</code> 规范的，第五个参数和第六个参数会存在用户调用 <code>msyscall</code> 栈的上一个栈中，具体结构如图</p>
<p><img src="/posts/671ebf76/image-20220511204955352-16527034425482.png" alt="image-20220511204955352"></p>
<p>左侧为用户栈，所以我们可以从用户栈上把参数取出来</p>
<pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">lw      t0, TF_REG29(sp)            // t0 &lt;- users stack pointer
lw      t3, 16(t0)                  // t3 &lt;- the 5th argument of msyscall
lw      t4, 20(t0)                  // t4 &lt;- the 6th argument of msyscall<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>然后我们需要把六个参数都存到用户栈上，我也不知道为啥要存首位的四个，可能是约定吧。先取出前四个参数</p>
<pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">lw		a0, TF_REG4(sp)
lw		a1, TF_REG5(sp)
lw		a2, TF_REG6(sp)
lw		a3, TF_REG7(sp)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>然后再存进去</p>
<pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">addiu	sp, sp, -24
sw		a0, 0(sp)
sw		a1, 4(sp)
sw		a2, 8(sp)
sw		a3, 12(sp)
sw		t3, 16(sp)
sw		t4, 20(sp)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>然后就可以调用具体的函数了</p>
<pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">jalr    t2                          // Invoke sys_* function
nop<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>调用完之后把栈空间释放了（释放的是那六个参数空间，不知道是不是 ABI ）</p>
<pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">addiu	sp, sp, 24<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>恢复一下返回值，我觉得用 <code>ret_from_exception</code> 似乎也行</p>
<pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">sw      v0, TF_REG2(sp)             // Store return value of function sys_* (in $v0) into trapframe<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>然后返回</p>
<pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">j       ret_from_exception          // Return from exeception
nop<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<h3 id="8-3-系统调用函数总结"><a href="#8-3-系统调用函数总结" class="headerlink" title="8.3 系统调用函数总结"></a>8.3 系统调用函数总结</h3><p>真正实现系统调用函数功能的都是以 <code>sys_</code> 开头的函数，有以下函数</p>
<h4 id="8-3-1-sys-set-pgfault-handler"><a href="#8-3-1-sys-set-pgfault-handler" class="headerlink" title="8.3.1 sys_set_pgfault_handler"></a>8.3.1 sys_set_pgfault_handler</h4><p>用来给指定的进程设置它的 <code>pgfault</code> 函数和发生 <code>pgfault</code> 的时候所用的栈，是一个很基础的函数。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">sys_set_pgfault_handler</span><span class="token punctuation">(</span><span class="token keyword">int</span> sysno<span class="token punctuation">,</span> u_int envid<span class="token punctuation">,</span> u_int func<span class="token punctuation">,</span> u_int xstacktop<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token comment">// Your code here.</span>
    <span class="token keyword">struct</span> <span class="token class-name">Env</span> <span class="token operator">*</span>env<span class="token punctuation">;</span>
    <span class="token keyword">int</span> ret<span class="token punctuation">;</span>

    <span class="token comment">// get the env</span>
    ret <span class="token operator">=</span> <span class="token function">envid2env</span><span class="token punctuation">(</span>envid<span class="token punctuation">,</span> <span class="token operator">&amp;</span>env<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>ret<span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        <span class="token keyword">return</span> ret<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment">// set the env_pgfault_handler as the set_pgfault_handler</span>
    env<span class="token operator">-&gt;</span>env_pgfault_handler <span class="token operator">=</span> func<span class="token punctuation">;</span>
    env<span class="token operator">-&gt;</span>env_xstacktop <span class="token operator">=</span> xstacktop<span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token comment">//	panic("sys_set_pgfault_handler not implemented");</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>这个函数会在 <code>fork</code> 中被调用，可以理解成需要给子进程设置一些状态，好让它比较方便</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token function">syscall_set_pgfault_handler</span><span class="token punctuation">(</span>newenvid<span class="token punctuation">,</span> __asm_pgfault_handler<span class="token punctuation">,</span> UXSTACKTOP<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<h4 id="8-3-2-sys-yield"><a href="#8-3-2-sys-yield" class="headerlink" title="8.3.2 sys_yield"></a>8.3.2 sys_yield</h4><p>基本上所有的系统调用都是包装函数的形式，基本上都可以看作是一些预处理加上一些原有的 <code>API</code> 的调用。</p>
<p>对于 <code>sys_yield</code> 有个最重要的东西，就是把上下文从 <code>KERNEL_SP</code> 处拷贝到 <code>TIMESTACK</code> 上，因为后续的 <code>env_run</code> 会从 <code>TIMESTACK</code> 中恢复上下文。但是这之后使用的栈依然是内核栈。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">sys_yield</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token function">bcopy</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span><span class="token punctuation">)</span>KERNEL_SP <span class="token operator">-</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">Trapframe</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
          <span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span><span class="token punctuation">)</span>TIMESTACK <span class="token operator">-</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">Trapframe</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
          <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">Trapframe</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">sched_yield</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="8-3-3-sys-env-destory"><a href="#8-3-3-sys-env-destory" class="headerlink" title="8.3.3 sys_env_destory"></a>8.3.3 sys_env_destory</h4><p>这是一个新的预处理，就是根据 <code>envid</code> 获得需要处理的进程，可以看到如下操作</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> r<span class="token punctuation">;</span>
<span class="token keyword">struct</span> <span class="token class-name">Env</span> <span class="token operator">*</span>e<span class="token punctuation">;</span>

<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>r <span class="token operator">=</span> <span class="token function">envid2env</span><span class="token punctuation">(</span>envid<span class="token punctuation">,</span> <span class="token operator">&amp;</span>e<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">return</span> r<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>有趣的是，用户进程自己为啥知道 <code>id</code> 。有两种方法，一个是 <code>fork</code> ，可以通过返回值判断 <code>id</code> 。另一个是使用系统调用 <code>sys_getenvid</code> 。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">sys_env_destroy</span><span class="token punctuation">(</span><span class="token keyword">int</span> sysno<span class="token punctuation">,</span> u_int envid<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">int</span> r<span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">Env</span> <span class="token operator">*</span>e<span class="token punctuation">;</span>

    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>r <span class="token operator">=</span> <span class="token function">envid2env</span><span class="token punctuation">(</span>envid<span class="token punctuation">,</span> <span class="token operator">&amp;</span>e<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        <span class="token keyword">return</span> r<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"[%08x] destroying %08x\n"</span><span class="token punctuation">,</span> curenv<span class="token operator">-&gt;</span>env_id<span class="token punctuation">,</span> e<span class="token operator">-&gt;</span>env_id<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">env_destroy</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>不过有意思的是，这里并没有 <code>sys_yield</code> 中出现的上下文拷贝操作，这是因为这个拷贝操作在 <code>env_destroy</code> 中进行了。</p>
<h4 id="8-3-4-sys-mem-alloc"><a href="#8-3-4-sys-mem-alloc" class="headerlink" title="8.3.4 sys_mem_alloc"></a>8.3.4 sys_mem_alloc</h4><p>这个函数用于给指定进程的某个虚拟地址分配一个页面，这就很神奇了，我一开始以为会是只能给自己这个进程分配一个页面呢。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">sys_mem_alloc</span><span class="token punctuation">(</span><span class="token keyword">int</span> sysno<span class="token punctuation">,</span> u_int envid<span class="token punctuation">,</span> u_int va<span class="token punctuation">,</span> u_int perm<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">struct</span> <span class="token class-name">Env</span> <span class="token operator">*</span>env<span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">Page</span> <span class="token operator">*</span>ppage<span class="token punctuation">;</span>
    <span class="token keyword">int</span> ret<span class="token punctuation">;</span>

    <span class="token comment">// check the perm</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>perm <span class="token operator">&amp;</span> PTE_V<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token operator">-</span>E_INVAL<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>perm <span class="token operator">&amp;</span> PTE_COW<span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token operator">-</span>E_INVAL<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token comment">// check the va</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>va <span class="token operator">&gt;=</span> UTOP<span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token operator">-</span>E_INVAL<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    
    <span class="token comment">// we need the env to get the pgdir of the curenv</span>
    <span class="token comment">// pgdir is the key to map</span>
    ret <span class="token operator">=</span> <span class="token function">envid2env</span><span class="token punctuation">(</span>envid<span class="token punctuation">,</span> <span class="token operator">&amp;</span>env<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>ret <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        <span class="token keyword">return</span> ret<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    ret <span class="token operator">=</span> <span class="token function">page_alloc</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>ppage<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>ret <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        <span class="token keyword">return</span> ret<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    ret <span class="token operator">=</span> <span class="token function">page_insert</span><span class="token punctuation">(</span>env<span class="token operator">-&gt;</span>env_pgdir<span class="token punctuation">,</span> ppage<span class="token punctuation">,</span> va<span class="token punctuation">,</span> perm<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>ret <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        <span class="token keyword">return</span> ret<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>    

    ret <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="8-3-5-sys-mem-map"><a href="#8-3-5-sys-mem-map" class="headerlink" title="8.3.5 sys_mem_map"></a>8.3.5 sys_mem_map</h4><p>这个函数用于“共享页面”，就是说给定两个进程，将两个进程各自不同的虚拟地址映射到同一页物理内存中去。这个的灵活性很大，因为可以指定两个进程，还可以指定两个虚拟地址。所以我们一般使用它的时候，会限制两个虚拟地址相等。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">sys_mem_map</span><span class="token punctuation">(</span><span class="token keyword">int</span> sysno<span class="token punctuation">,</span> u_int srcid<span class="token punctuation">,</span> u_int srcva<span class="token punctuation">,</span> u_int dstid<span class="token punctuation">,</span> u_int dstva<span class="token punctuation">,</span>
                u_int perm<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">int</span> ret<span class="token punctuation">;</span>
    u_int round_srcva<span class="token punctuation">,</span> round_dstva<span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">Env</span> <span class="token operator">*</span>srcenv<span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">Env</span> <span class="token operator">*</span>dstenv<span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">Page</span> <span class="token operator">*</span>ppage<span class="token punctuation">;</span>
    <span class="token comment">// it's just a parameter occupy, it's useless</span>
    Pte <span class="token operator">*</span>ppte<span class="token punctuation">;</span>

    ppage <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>
    ret <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token comment">// we need the va of vpage where the parameter va located </span>
    round_srcva <span class="token operator">=</span> <span class="token function">ROUNDDOWN</span><span class="token punctuation">(</span>srcva<span class="token punctuation">,</span> BY2PG<span class="token punctuation">)</span><span class="token punctuation">;</span>
    round_dstva <span class="token operator">=</span> <span class="token function">ROUNDDOWN</span><span class="token punctuation">(</span>dstva<span class="token punctuation">,</span> BY2PG<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">// check the permission</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>perm <span class="token operator">&amp;</span> PTE_V<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token operator">-</span>E_INVAL<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token comment">// check the va</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>srcva <span class="token operator">&gt;=</span> UTOP <span class="token operator">||</span> dstva <span class="token operator">&gt;=</span> UTOP<span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token operator">-</span>E_INVAL<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment">// check the source env</span>
    ret <span class="token operator">=</span> <span class="token function">envid2env</span><span class="token punctuation">(</span>srcid<span class="token punctuation">,</span> <span class="token operator">&amp;</span>srcenv<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 
    <span class="token keyword">if</span> <span class="token punctuation">(</span>ret <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        <span class="token keyword">return</span> ret<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment">// check the destination env</span>
    ret <span class="token operator">=</span> <span class="token function">envid2env</span><span class="token punctuation">(</span>dstid<span class="token punctuation">,</span> <span class="token operator">&amp;</span>dstenv<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>ret <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        <span class="token keyword">return</span> ret<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    
    <span class="token comment">// look up for the physical page</span>
    ppage <span class="token operator">=</span> <span class="token function">page_lookup</span><span class="token punctuation">(</span>srcenv<span class="token operator">-&gt;</span>env_pgdir<span class="token punctuation">,</span> round_srcva<span class="token punctuation">,</span> <span class="token operator">&amp;</span>ppte<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>ppage <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token operator">-</span>E_INVAL<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment">// map the dstva to the ppage</span>
    ret <span class="token operator">=</span> <span class="token function">page_insert</span><span class="token punctuation">(</span>dstenv<span class="token operator">-&gt;</span>env_pgdir<span class="token punctuation">,</span> ppage<span class="token punctuation">,</span> round_dstva<span class="token punctuation">,</span> perm<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> ret<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="8-3-6-sys-mem-unmap"><a href="#8-3-6-sys-mem-unmap" class="headerlink" title="8.3.6 sys_mem_unmap"></a>8.3.6 sys_mem_unmap</h4><p>这个函数用于将指定进程的指定虚拟地址到物理页面的映射关系解除。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">sys_mem_unmap</span><span class="token punctuation">(</span><span class="token keyword">int</span> sysno<span class="token punctuation">,</span> u_int envid<span class="token punctuation">,</span> u_int va<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">int</span> ret <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">Env</span> <span class="token operator">*</span>env<span class="token punctuation">;</span>

    <span class="token comment">// check the va</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>va <span class="token operator">&gt;=</span> UTOP<span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token operator">-</span>E_INVAL<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token comment">// get the env</span>
    ret <span class="token operator">=</span> <span class="token function">envid2env</span><span class="token punctuation">(</span>envid<span class="token punctuation">,</span> <span class="token operator">&amp;</span>env<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>ret <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        <span class="token keyword">return</span> ret<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment">// umap</span>
    <span class="token function">page_remove</span><span class="token punctuation">(</span>env<span class="token operator">-&gt;</span>env_pgdir<span class="token punctuation">,</span> va<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> ret<span class="token punctuation">;</span>
    <span class="token comment">//	panic("sys_mem_unmap not implemented");</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="8-3-7-sys-env-alloc"><a href="#8-3-7-sys-env-alloc" class="headerlink" title="8.3.7 sys_env_alloc"></a>8.3.7 sys_env_alloc</h4><p>这个函数用于创造出一个新的进程。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">sys_env_alloc</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token comment">// Your code here.</span>
    <span class="token keyword">int</span> r<span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">Env</span> <span class="token operator">*</span>e<span class="token punctuation">;</span>

    <span class="token comment">// alloc a new env </span>
    r <span class="token operator">=</span> <span class="token function">env_alloc</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>e<span class="token punctuation">,</span> curenv<span class="token operator">-&gt;</span>env_id<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>r <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        <span class="token keyword">return</span> r<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token comment">// set the statur of new env    </span>
    e<span class="token operator">-&gt;</span>env_status <span class="token operator">=</span> ENV_NOT_RUNNABLE<span class="token punctuation">;</span>

    <span class="token comment">// copy the father env to the child env</span>
    e<span class="token operator">-&gt;</span>env_pri <span class="token operator">=</span> curenv<span class="token operator">-&gt;</span>env_pri<span class="token punctuation">;</span>
    <span class="token function">bcopy</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span><span class="token punctuation">)</span>KERNEL_SP <span class="token operator">-</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">Trapframe</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
          <span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token punctuation">(</span>e<span class="token operator">-&gt;</span>env_tf<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">Trapframe</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    e<span class="token operator">-&gt;</span>env_tf<span class="token punctuation">.</span>pc <span class="token operator">=</span> e<span class="token operator">-&gt;</span>env_tf<span class="token punctuation">.</span>cp0_epc<span class="token punctuation">;</span>

    <span class="token comment">// set the return value = 0</span>
    e<span class="token operator">-&gt;</span>env_tf<span class="token punctuation">.</span>regs<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> 
    <span class="token keyword">return</span> e<span class="token operator">-&gt;</span>env_id<span class="token punctuation">;</span>
    <span class="token comment">//	panic("sys_env_alloc not implemented");</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>最有意思的事实下面这个句话，他让 <code>v0</code> 的值为 0。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c">e<span class="token operator">-&gt;</span>env_tf<span class="token punctuation">.</span>regs<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<h4 id="8-3-8-sys-set-env-status"><a href="#8-3-8-sys-set-env-status" class="headerlink" title="8.3.8 sys_set_env_status"></a>8.3.8 sys_set_env_status</h4><p>设置进程的状态，主要就用于 <code>fork</code> 中，子进程并被分配后没有被设置为 <code>RUNNABLE</code> ，且并没有插入调度链表，这个函数就是解决这两件事情。从这个函数可以看出，子进程会被一种时钟中断的形式调用。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">sys_set_env_status</span><span class="token punctuation">(</span><span class="token keyword">int</span> sysno<span class="token punctuation">,</span> u_int envid<span class="token punctuation">,</span> u_int status<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token comment">// Your code here.</span>
    <span class="token keyword">struct</span> <span class="token class-name">Env</span> <span class="token operator">*</span>env<span class="token punctuation">;</span>
    <span class="token keyword">int</span> ret<span class="token punctuation">;</span>

    <span class="token comment">// check the status</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>status <span class="token operator">!=</span> ENV_RUNNABLE <span class="token operator">&amp;&amp;</span> status <span class="token operator">!=</span> ENV_NOT_RUNNABLE <span class="token operator">&amp;&amp;</span> status <span class="token operator">!=</span> ENV_FREE<span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token operator">-</span>E_INVAL<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment">// get the env</span>
    ret <span class="token operator">=</span> <span class="token function">envid2env</span><span class="token punctuation">(</span>envid<span class="token punctuation">,</span> <span class="token operator">&amp;</span>env<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>ret<span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        <span class="token keyword">return</span> ret<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>status <span class="token operator">==</span> ENV_RUNNABLE <span class="token operator">&amp;&amp;</span> env<span class="token operator">-&gt;</span>env_status <span class="token operator">!=</span> ENV_RUNNABLE<span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        <span class="token function">LIST_INSERT_TAIL</span><span class="token punctuation">(</span>env_sched_list<span class="token punctuation">,</span> env<span class="token punctuation">,</span> env_sched_link<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    env<span class="token operator">-&gt;</span>env_status <span class="token operator">=</span> status<span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token comment">//	panic("sys_env_set_status not implemented");</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="8-3-9-sys-ipc-recv"><a href="#8-3-9-sys-ipc-recv" class="headerlink" title="8.3.9 sys_ipc_recv"></a>8.3.9 sys_ipc_recv</h4><p>这个函数实现的功能就是通过设置进程控制块，来做好“被通信”的准备，然后等待，在这个函数里可能出现了唯一一个 <code>ENV_NOT_RUNNABLE</code> 。（<code>fork</code> 中也有一个）</p>
<p>对于传进来的地址，首先会做一个地址检查。每一个系统调用只要参数中有虚拟地址，都会做这个检查。其实为了保证用户不会访问到不该访问的区域，一部分检查是在这里做的，另一部分是在 <code>pageout</code> 里做的。应该检查都是由软件实现的。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">// check the va</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span>dstva <span class="token operator">&gt;=</span> UTOP<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
	<span class="token keyword">return</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>然后我们设置一些状态</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">// set the status</span>
curenv<span class="token operator">-&gt;</span>env_ipc_recving <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
<span class="token comment">// set the dstva</span>
curenv<span class="token operator">-&gt;</span>env_ipc_dstva <span class="token operator">=</span> dstva<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>最后让这个进程被阻塞，换一个进程调度。注意调度用的是 <code>sys_yield</code> 因为有一个上下文拷贝的操作需要进行。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">// block the env</span>
curenv<span class="token operator">-&gt;</span>env_status <span class="token operator">=</span> ENV_NOT_RUNNABLE<span class="token punctuation">;</span>
<span class="token comment">// we can't use the env_yield, because of the timer Irq</span>
<span class="token function">sys_yield</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="8-3-10-sys-ipc-can-send"><a href="#8-3-10-sys-ipc-can-send" class="headerlink" title="8.3.10 sys_ipc_can_send"></a>8.3.10 sys_ipc_can_send</h4><p>这个函数用来给其他进程传递数据，传递数据的方法有两种，一种是通过进程控制块里的一个 <code>env_ipc_value</code> 可以传递一个整型数，还可以通过共享页面来进行一个大数据的传输。</p>
<p>首先依然是检查虚拟地址</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">// check the srcva</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span>srcva <span class="token operator">&gt;=</span> UTOP<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token operator">-</span>E_INVAL<span class="token punctuation">;</span>
<span class="token punctuation">}</span> <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p> 然后是获得被传输进程的进程控制块，并检测相关权限</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">// get the dstenv</span>
r <span class="token operator">=</span> <span class="token function">envid2env</span><span class="token punctuation">(</span>envid<span class="token punctuation">,</span> <span class="token operator">&amp;</span>e<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span>r <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
	<span class="token keyword">return</span> r<span class="token punctuation">;</span>
<span class="token punctuation">}</span>    
<span class="token keyword">if</span> <span class="token punctuation">(</span>e<span class="token operator">-&gt;</span>env_ipc_recving <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
	<span class="token keyword">return</span> <span class="token operator">-</span>E_IPC_NOT_RECV<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>然后进行一个值传递</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">// pass the value    </span>
e<span class="token operator">-&gt;</span>env_ipc_value <span class="token operator">=</span> value<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>进行一下页面的共享，其实就是利用传输者查找出物理地址控制块，然后建立这个物理地址控制块与被传输者虚拟地址的联系</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">if</span> <span class="token punctuation">(</span>srcva <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token comment">// share the physical page</span>
    p <span class="token operator">=</span> <span class="token function">page_lookup</span><span class="token punctuation">(</span>curenv<span class="token operator">-&gt;</span>env_pgdir<span class="token punctuation">,</span> srcva<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>p <span class="token operator">==</span> <span class="token constant">NULL</span> <span class="token operator">||</span> e<span class="token operator">-&gt;</span>env_ipc_dstva <span class="token operator">&gt;=</span> UTOP<span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token operator">-</span>E_INVAL<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>    
    r <span class="token operator">=</span> <span class="token function">page_insert</span><span class="token punctuation">(</span>e<span class="token operator">-&gt;</span>env_pgdir<span class="token punctuation">,</span> p<span class="token punctuation">,</span> e<span class="token operator">-&gt;</span>env_ipc_dstva<span class="token punctuation">,</span> perm<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>r <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        <span class="token keyword">return</span> r<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>    
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>最后设置一下被传输进程的状态，使其停止阻塞</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c">e<span class="token operator">-&gt;</span>env_ipc_from <span class="token operator">=</span> curenv<span class="token operator">-&gt;</span>env_id<span class="token punctuation">;</span>
e<span class="token operator">-&gt;</span>env_ipc_perm <span class="token operator">=</span> perm<span class="token punctuation">;</span>
e<span class="token operator">-&gt;</span>env_ipc_recving <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
e<span class="token operator">-&gt;</span>env_status <span class="token operator">=</span> ENV_RUNNABLE<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="8-4-fork"><a href="#8-4-fork" class="headerlink" title="8.4 fork"></a>8.4 fork</h3><h4 id="8-4-1-不是系统调用函数"><a href="#8-4-1-不是系统调用函数" class="headerlink" title="8.4.1 不是系统调用函数"></a>8.4.1 不是系统调用函数</h4><p>首先最需要强调的是，<code>fork</code> 不是一个系统调用函数，但是它使用了很多的系统调用函数。而且很多的系统调用函数都是<strong>专门</strong>为 <code>fork</code> 服务的，所以入过光看某些系统调用函数，会觉得有很多的操作是多余甚至冗余的。事实也确实是如此，比如说 <code>sys_env_alloc</code> ，按照自面理解，其实只需要一句 <code>env_alloc</code> 就结束这个函数了，但是实际上呢？</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c">e<span class="token operator">-&gt;</span>env_status <span class="token operator">=</span> ENV_NOT_RUNNABLE<span class="token punctuation">;</span>						<span class="token comment">// 	为啥要设置成 NOT_RUNNABLE</span>
e<span class="token operator">-&gt;</span>env_pri <span class="token operator">=</span> curenv<span class="token operator">-&gt;</span>env_pri<span class="token punctuation">;</span>							<span class="token comment">//	为啥要设置这个优先级</span>
<span class="token function">bcopy</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span><span class="token punctuation">)</span>KERNEL_SP <span class="token operator">-</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">Trapframe</span><span class="token punctuation">)</span><span class="token punctuation">,</span>		<span class="token comment">//	为啥要拷贝</span>
<span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token punctuation">(</span>e<span class="token operator">-&gt;</span>env_tf<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">Trapframe</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>		
e<span class="token operator">-&gt;</span>env_tf<span class="token punctuation">.</span>pc <span class="token operator">=</span> e<span class="token operator">-&gt;</span>env_tf<span class="token punctuation">.</span>cp0_epc<span class="token punctuation">;</span>						<span class="token comment">//	为啥要这样设置 PC</span>
e<span class="token operator">-&gt;</span>env_tf<span class="token punctuation">.</span>regs<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> 									<span class="token comment">//	为啥要设置 v0</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>这一大堆语句我都不知道它在干啥。这是因为这些操作都是为了 <code>fork</code> 这个语境服务的，如果不是用在 <code>fork</code> 里，这些语句就很无厘头。</p>
<p>所以理解某些系统调用，不能从其功能区理解，而是要从其语境理解，因为有的时候功能并不是一个泛化的功能，而可能只是一个函数里特化的一步而已。</p>
<h4 id="8-4-2-duppage"><a href="#8-4-2-duppage" class="headerlink" title="8.4.2 duppage"></a>8.4.2 duppage</h4><p>这个函数用于根据父进程的映射关系，去复制子进程的映射关系，<code>pn</code> 是虚拟页面号的意思。复制最困难的是对于权限位的考量，其实就是对于 <code>COW</code> 的设置。如果一个页面，他不是只读的（说明有写的可能），而且也没有明确说是可以共享的（只共享写），那么就是应该增设 <code>PTE_COW</code> 位，这种增设是对于父子进程都要设置的。所以尽管这里有两个<code>map</code>，但是第一个 <code>map</code> 是用于子进程建立页面映射，而第二个是用于修改父进程的映射权限。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">duppage</span><span class="token punctuation">(</span>u_int envid<span class="token punctuation">,</span> u_int pn<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token comment">// addr is the va we need to process</span>
    u_int addr <span class="token operator">=</span> pn <span class="token operator">&lt;&lt;</span> PGSHIFT<span class="token punctuation">;</span>
    <span class="token comment">// *vpt + pn is the adress of page_table_entry which is corresponded to the va</span>
    u_int perm <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>Pte <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token operator">*</span>vpt<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">[</span>pn<span class="token punctuation">]</span> <span class="token operator">&amp;</span> <span class="token number">0xfff</span><span class="token punctuation">;</span>

    <span class="token comment">// if the page can be write and is not shared, so the page need to be COW and map twice</span>
    <span class="token keyword">int</span> flag <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>perm <span class="token operator">&amp;</span> PTE_R<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span><span class="token punctuation">(</span>perm <span class="token operator">&amp;</span> PTE_LIBRARY<span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        perm <span class="token operator">|=</span> PTE_COW<span class="token punctuation">;</span>
        flag <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token function">syscall_mem_map</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> addr<span class="token punctuation">,</span> envid<span class="token punctuation">,</span> addr<span class="token punctuation">,</span> perm<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>flag<span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        <span class="token function">syscall_mem_map</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> addr<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> addr<span class="token punctuation">,</span> perm<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment">//	user_panic("duppage not implemented");</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="8-4-3-fork"><a href="#8-4-3-fork" class="headerlink" title="8.4.3 fork"></a>8.4.3 fork</h4><p>这个函数用于产生一个子进程，并且设置其状态和各种配置。这里需要强调的一个有趣的点是，<code>fork</code> 本身并不是系统调用函数，他是由一系列系统调用函数组成的一个用户函数。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">fork</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    u_int newenvid<span class="token punctuation">;</span>
    <span class="token keyword">extern</span> <span class="token keyword">struct</span> <span class="token class-name">Env</span> <span class="token operator">*</span>envs<span class="token punctuation">;</span>
    <span class="token keyword">extern</span> <span class="token keyword">struct</span> <span class="token class-name">Env</span> <span class="token operator">*</span>env<span class="token punctuation">;</span>
    u_int i<span class="token punctuation">;</span>

    <span class="token comment">// The parent installs pgfault using set_pgfault_handler</span>
    <span class="token function">set_pgfault_handler</span><span class="token punctuation">(</span>pgfault<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">// alloc a new alloc</span>
    newenvid <span class="token operator">=</span> <span class="token function">syscall_env_alloc</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>newenvid <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        env <span class="token operator">=</span> envs <span class="token operator">+</span> <span class="token function">ENVX</span><span class="token punctuation">(</span><span class="token function">syscall_getenvid</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token function">VPN</span><span class="token punctuation">(</span>USTACKTOP<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token operator">*</span>vpd<span class="token punctuation">)</span><span class="token punctuation">[</span>i <span class="token operator">&gt;&gt;</span> <span class="token number">10</span><span class="token punctuation">]</span> <span class="token operator">&amp;</span> PTE_V<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token operator">*</span>vpt<span class="token punctuation">)</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&amp;</span> PTE_V<span class="token punctuation">)</span><span class="token punctuation">)</span>
        <span class="token punctuation">{</span>
            <span class="token function">duppage</span><span class="token punctuation">(</span>newenvid<span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token function">syscall_mem_alloc</span><span class="token punctuation">(</span>newenvid<span class="token punctuation">,</span> UXSTACKTOP <span class="token operator">-</span> BY2PG<span class="token punctuation">,</span> PTE_V <span class="token operator">|</span> PTE_R<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">syscall_set_pgfault_handler</span><span class="token punctuation">(</span>newenvid<span class="token punctuation">,</span> __asm_pgfault_handler<span class="token punctuation">,</span> UXSTACKTOP<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">syscall_set_env_status</span><span class="token punctuation">(</span>newenvid<span class="token punctuation">,</span> ENV_RUNNABLE<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> newenvid<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>首先我们先进行了一个父进程的配置，我们用这个函数为父进程分配了处理 <code>COW</code> 的时候的栈，还指定了处理 <code>pgfault</code> 异常的函数。至于为啥不一早就分配好了呢？我觉得是因为不是每个进程都需要用到这个栈，所以为了避免页面的浪费，就没有改成了用函数手动配置，而不是默认配置。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token function">set_pgfault_handler</span><span class="token punctuation">(</span>pgfault<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>然后我们利用系统调用创造一个进程</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c">newenvid <span class="token operator">=</span> <span class="token function">syscall_env_alloc</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>我们先看子进程，它会被时钟中断调度（先别管咋调度的），那么就会从内存控制块里恢复现场，那么此时被恢复的 <code>v0</code> 就是 <code>0</code>，返回的 PC 就是 <code>syscall_env_alloc</code> 所导致的 <code>syscall</code> 的下一条，也就是 <code>msyscall</code> 中的这条</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token function">LEAF</span><span class="token punctuation">(</span>msyscall<span class="token punctuation">)</span>
	syscall
	nop				<span class="token comment">// 这条</span>
	jr		ra
	nop
<span class="token function">END</span><span class="token punctuation">(</span>msyscall<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>那么再次返回的时候 <code>syscall_env_alloc</code> 的返回值就变成了 0。然后就会进入下面这个分支判断</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">if</span> <span class="token punctuation">(</span>newenvid <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    env <span class="token operator">=</span> envs <span class="token operator">+</span> <span class="token function">ENVX</span><span class="token punctuation">(</span><span class="token function">syscall_getenvid</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><code>env</code> 是对于用户进程的一个全局变量，他表示正在运行的进程块，一般会在 <code>start</code> 到 <code>main</code> 之间设置，但是以为 <code>fork</code> 出的子进程没有设置这个，所以需要在这里设置，然后就可以结束 <code>fork</code> 了，返回值是 <code>0</code>。</p>
<p>但是对于父进程来说，对于子进程的修改还没有结束，他还需要将虚拟环境完全的复制给子进程，也就是下面的语句。这里的 <code>i</code> 是虚页号，我们可以用 <code>(*vpd)[i &gt;&gt; 10]</code> 的找出这个虚页号对应的一级页表项，用 <code>(*vpt)[i]</code> 找出二级页表项，为什么可以这样呢？</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token function">VPN</span><span class="token punctuation">(</span>USTACKTOP<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token operator">*</span>vpd<span class="token punctuation">)</span><span class="token punctuation">[</span>i <span class="token operator">&gt;&gt;</span> <span class="token number">10</span><span class="token punctuation">]</span> <span class="token operator">&amp;</span> PTE_V<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token operator">*</span>vpt<span class="token punctuation">)</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&amp;</span> PTE_V<span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        <span class="token function">duppage</span><span class="token punctuation">(</span>newenvid<span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>首先我们需要弄清 <code>extern</code> 的用法，这似乎是理解的最难点，对于一个在 <code>file1</code> 中定义的全局变量 <code>a</code></p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>  		<span class="token comment">// 假设地址 &amp;a = 0x8000_5000</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>那么在文件 <code>file2</code> 的时候需要引入这个变量，那么可以有两种写法（虽然正常人只会用第一种）</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">extern</span> <span class="token keyword">int</span> a<span class="token punctuation">;</span>
<span class="token keyword">extern</span> <span class="token keyword">int</span> a<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>但是两者的结果是不同的，如果我们打印第一个变量 <code>a</code>，那么会出现 <code>1</code>，如果打印第二个变量（我都感觉这是个指针常量了），那么就会出现 <code>a = 0x80005000</code> 。我不知道为啥是这样的，但是确实是这样的。</p>
<p>然后我们来看一下 <code>vpt</code> 和 <code>vpd</code> 的定义，在 <code>user</code> 文件夹下的 <code>entry.S</code> 下</p>
<pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">	.globl vpt
vpt:
	.word UVPT

	.globl vpd
vpd:
	.word (UVPT+(UVPT&gt;&gt;12)*4)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>可以看到是一个自映射的标准写法，相关的宏就是我们在 <code>mmu.h</code> 中定义的，而且我们在进程创建之初，就完成了这个设置，</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c">e<span class="token operator">-&gt;</span>env_pgdir<span class="token punctuation">[</span><span class="token function">PDX</span><span class="token punctuation">(</span>UVPT<span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token operator">=</span> e<span class="token operator">-&gt;</span>env_cr3 <span class="token operator">|</span> PTE_V<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>但是最让人困惑的莫过于教程中“指针的指针”这一说法，我个人觉得直接认为他是错误的就好了。因为在引入的时候，我们用的是这种方法</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">extern</span> <span class="token keyword">volatile</span> Pte <span class="token operator">*</span>vpt<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token keyword">extern</span> <span class="token keyword">volatile</span> Pde <span class="token operator">*</span>vpd<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>按照 c 的语法，<code>vpt</code> 应该是一个指针数组，但是这个操作 <code>(*vpt)[i]</code> 如果需要先按照数组方式理解，然后再按照指针方式理解，那么就会变成这样 <code>*(vpt[0] + i)</code> 或者直观一些 <code>vpt[0][i]</code> 。这都是无厘头的，因为类似于我们声明了一个指针数组，但是只用它的第一个元素当指针，为啥我们不直接声明一个指针 <code>Pte* vpt</code>。这是个未解之谜，我与叶哥哥讨论，叶哥哥也认为如果写成</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c">u_int <span class="token operator">*</span>vpt <span class="token operator">=</span> <span class="token punctuation">(</span>u_int<span class="token operator">*</span><span class="token punctuation">)</span> UVPT<span class="token punctuation">;</span>
<span class="token comment">// use vpt[i]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>会很好看，鬼知道他为啥写成这样。</p>
<p>但是既然写了，就要从语法上解释通，对于 <code>(*vpt)</code> 操作，结合上面介绍的 <code>extern</code> 知识，可以知道，<code>vpt</code> 的值不再是 <code>0x7fc0 0000</code>了，而是 <code>vpt</code> 的地址（恶心）。然后 <code>(*vpt)</code> 的值才是 <code>0x7fc0 0000</code> 。所以再结合 <code>(*vpt) + VPN</code> ，知道这是在计算二级页表项的虚拟地址，然后取地址，就可以得到二级页表项 <code>*((*vpt) + VPN) = (*vpt)[VPN]</code> 。</p>
<p>在有了这些知识打底的基础上，我们就可以看到底要干啥了，我们遍历了所有的二级页表项和一级页表项，如果他是有效的，那么就要给子进程复制他，人物交给了 <code>duppage</code>。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token function">VPN</span><span class="token punctuation">(</span>USTACKTOP<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token operator">*</span>vpd<span class="token punctuation">)</span><span class="token punctuation">[</span>i <span class="token operator">&gt;&gt;</span> <span class="token number">10</span><span class="token punctuation">]</span> <span class="token operator">&amp;</span> PTE_V<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token operator">*</span>vpt<span class="token punctuation">)</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&amp;</span> PTE_V<span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        <span class="token function">duppage</span><span class="token punctuation">(</span>newenvid<span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>然后我们需要设置一些子进程的对于 <code>COW</code> 的设置</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token function">syscall_mem_alloc</span><span class="token punctuation">(</span>newenvid<span class="token punctuation">,</span> UXSTACKTOP <span class="token operator">-</span> BY2PG<span class="token punctuation">,</span> PTE_V <span class="token operator">|</span> PTE_R<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">syscall_set_pgfault_handler</span><span class="token punctuation">(</span>newenvid<span class="token punctuation">,</span> __asm_pgfault_handler<span class="token punctuation">,</span> UXSTACKTOP<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>上面两句话的作用其实跟父进程的 <code>set_pgfault_handler(pgfault)</code> 作用一样，就是没有设置 <code>pgout</code> 因为之前似乎已经设置了。</p>
<p>最后我们需要让子进程进入调度序列，就是底下这个函数实现的</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token function">syscall_set_env_status</span><span class="token punctuation">(</span>newenvid<span class="token punctuation">,</span> ENV_RUNNABLE<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>最后偷一张图放在这里：</p>
<p><img src="/posts/671ebf76/4_fork_process.png" alt="fork 流程图"></p>
<hr>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/S4%E8%AF%BE%E4%B8%8A/" rel="tag"><i class="fa fa-tag"></i> S4课上</a>
              <a href="/tags/%E7%9B%B4%E8%A7%82%E7%90%86%E8%A7%A3/" rel="tag"><i class="fa fa-tag"></i> 直观理解</a>
              <a href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" rel="tag"><i class="fa fa-tag"></i> 操作系统</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/posts/b1ba6344/" rel="prev" title="吃喝玩乐-爱德华八世">
      <i class="fa fa-chevron-left"></i> 吃喝玩乐-爱德华八世
    </a></div>
      <div class="post-nav-item">
    <a href="/posts/45420b6b/" rel="next" title="操作系统-OS不相信抽象">
      操作系统-OS不相信抽象 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          
<script src="https://utteranc.es/client.js"
        repo="Thysrael/blog-comment"
        issue-term="title"
        theme="github-light"
        crossorigin="anonymous"
        async>
</script>

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%80%E3%80%81%E6%80%BB%E8%AE%BA"><span class="nav-text">一、总论</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-1-%E8%BD%AF%E7%A1%AC%E4%BB%B6%E5%88%86%E5%B7%A5"><span class="nav-text">1.1 软硬件分工</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-2-%E6%98%8E%E7%A1%AE%E6%A6%82%E5%BF%B5"><span class="nav-text">1.2 明确概念</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-3-%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E6%B5%81%E7%A8%8B"><span class="nav-text">1.3 异常处理流程</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%8C%E3%80%81%E7%A1%AC%E4%BB%B6%E9%83%A8%E5%88%86"><span class="nav-text">二、硬件部分</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2-1-%E8%AE%A1%E7%BB%84-CP0-%E7%BB%93%E6%9E%84"><span class="nav-text">2.1 计组 CP0 结构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-2-SR-%E5%AF%84%E5%AD%98%E5%99%A8"><span class="nav-text">2.2 SR 寄存器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-3-Cause-%E5%AF%84%E5%AD%98%E5%99%A8"><span class="nav-text">2.3 Cause 寄存器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-4-EPC-%E5%AF%84%E5%AD%98%E5%99%A8"><span class="nav-text">2.4 EPC 寄存器</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%89%E3%80%81%E8%BD%AF%E4%BB%B6%E6%80%BB%E8%AE%BA"><span class="nav-text">三、软件总论</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#3-1-%E6%96%87%E7%AB%A0%E7%BB%93%E6%9E%84"><span class="nav-text">3.1 文章结构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-2-%E7%9B%B4%E8%A7%82%E7%90%86%E8%A7%A3"><span class="nav-text">3.2 直观理解</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9B%9B%E3%80%81%E5%BC%82%E5%B8%B8%E7%9A%84%E5%85%B1%E6%80%A7"><span class="nav-text">四、异常的共性</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#4-1-%E6%99%AE%E9%81%8D%E6%B5%81%E7%A8%8B"><span class="nav-text">4.1 普遍流程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-2-%E9%80%89%E6%8B%A9%E5%86%85%E6%A0%B8%E6%A0%88"><span class="nav-text">4.2 选择内核栈</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#4-2-1-%E5%86%85%E6%A0%B8%E4%B8%AD%E7%9A%84%E6%A0%88"><span class="nav-text">4.2.1 内核中的栈</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-2-2-get-sp"><span class="nav-text">4.2.2 get_sp</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-3-%E4%BF%9D%E5%AD%98%E4%B8%8A%E4%B8%8B%E6%96%87"><span class="nav-text">4.3 保存上下文</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-4-%E7%A6%81%E6%AD%A2%E4%B8%AD%E6%96%AD"><span class="nav-text">4.4 禁止中断</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-5-%E8%BF%9B%E8%A1%8C%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86"><span class="nav-text">4.5 进行异常处理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-6-%E4%BB%8E%E5%BC%82%E5%B8%B8%E8%BF%94%E5%9B%9E"><span class="nav-text">4.6 从异常返回</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#4-6-1-ret-from-exception"><span class="nav-text">4.6.1 ret_from_exception</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-6-2-restore-some"><span class="nav-text">4.6.2 restore_some</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-7-%E5%BC%82%E5%B8%B8%E7%9A%84%E5%88%86%E5%8F%91"><span class="nav-text">4.7 异常的分发</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%94%E3%80%81TLB-%E7%BC%BA%E5%A4%B1%E4%B8%AD%E6%96%AD"><span class="nav-text">五、TLB 缺失中断</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#5-1-%E6%80%BB%E4%BD%93%E6%A6%82%E8%A7%88"><span class="nav-text">5.1 总体概览</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-2-TLB-%E7%BB%93%E6%9E%84"><span class="nav-text">5.2 TLB 结构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-3-do-refill"><span class="nav-text">5.3 do_refill</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-5-COW-%E7%9A%84%E5%A4%84%E7%90%86"><span class="nav-text">5.5 COW 的处理</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%85%AD%E3%80%81%E6%97%B6%E9%92%9F%E4%B8%AD%E6%96%AD"><span class="nav-text">六、时钟中断</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#6-1-%E6%80%BB%E4%BD%93%E6%A6%82%E8%A7%88"><span class="nav-text">6.1 总体概览</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-2-%E6%81%A2%E5%A4%8D%E5%8F%A6%E4%B8%80%E4%B8%AA%E7%8E%B0%E5%9C%BA"><span class="nav-text">6.2 恢复另一个现场</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-3-handle-int"><span class="nav-text">6.3 handle_int</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-4-env-yield"><span class="nav-text">6.4 env_yield</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-5-%E6%96%B0%E8%BF%9B%E7%A8%8B%E8%BF%90%E8%A1%8C"><span class="nav-text">6.5 新进程运行</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#6-5-1-lcontext"><span class="nav-text">6.5.1 lcontext</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6-5-2-env-pop-tf"><span class="nav-text">6.5.2 env_pop_tf</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6-5-3-env-run"><span class="nav-text">6.5.3 env_run</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-6-%E8%AE%A1%E6%97%B6%E5%99%A8%E7%9A%84%E8%AE%BE%E7%BD%AE"><span class="nav-text">6.6 计时器的设置</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%83%E3%80%81%E8%AF%BB%E5%86%99%E5%BC%82%E5%B8%B8"><span class="nav-text">七、读写异常</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#7-1-%E6%80%BB%E4%BD%93%E6%A6%82%E8%BF%B0"><span class="nav-text">7.1 总体概述</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-2-%E5%BE%AE%E5%86%85%E6%A0%B8%E8%AE%BE%E8%AE%A1"><span class="nav-text">7.2 微内核设计</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#7-2-1-%E5%88%86%E5%B8%83%E5%BC%8F"><span class="nav-text">7.2.1 分布式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#7-2-2-%E7%94%A8%E6%88%B7%E5%BC%82%E5%B8%B8%E6%A0%88"><span class="nav-text">7.2.2 用户异常栈</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-3-%E5%86%85%E6%A0%B8%E9%83%A8%E5%88%86"><span class="nav-text">7.3 内核部分</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-4-%E7%94%A8%E6%88%B7%E9%83%A8%E5%88%86"><span class="nav-text">7.4 用户部分</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#7-4-1-asm-pgfault-handler"><span class="nav-text">7.4.1 __asm_pgfault_handler</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#7-4-2-pgfault"><span class="nav-text">7.4.2 pgfault</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-5-%E8%AE%BE%E7%BD%AE%E5%87%BD%E6%95%B0%E6%8C%87%E9%92%88"><span class="nav-text">7.5 设置函数指针</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#7-1-1-set-pgfault-handler"><span class="nav-text">7.1.1 set_pgfault_handler</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#7-1-2-sys-set-pgfault-handler"><span class="nav-text">7.1.2 sys_set_pgfault_handler</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%85%AB%E3%80%81%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E5%BC%82%E5%B8%B8"><span class="nav-text">八、系统调用异常</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#8-1-%E6%80%BB%E4%BD%93%E6%A6%82%E8%BF%B0"><span class="nav-text">8.1 总体概述</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#8-2-%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E7%9A%84%E5%89%8D%E6%9C%9F"><span class="nav-text">8.2 系统调用的前期</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#8-2-1-syscall"><span class="nav-text">8.2.1 syscall_*</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#8-2-2-msyscall"><span class="nav-text">8.2.2 msyscall</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#8-2-3-handle-sys"><span class="nav-text">8.2.3 handle_sys</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#8-3-%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E5%87%BD%E6%95%B0%E6%80%BB%E7%BB%93"><span class="nav-text">8.3 系统调用函数总结</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#8-3-1-sys-set-pgfault-handler"><span class="nav-text">8.3.1 sys_set_pgfault_handler</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#8-3-2-sys-yield"><span class="nav-text">8.3.2 sys_yield</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#8-3-3-sys-env-destory"><span class="nav-text">8.3.3 sys_env_destory</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#8-3-4-sys-mem-alloc"><span class="nav-text">8.3.4 sys_mem_alloc</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#8-3-5-sys-mem-map"><span class="nav-text">8.3.5 sys_mem_map</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#8-3-6-sys-mem-unmap"><span class="nav-text">8.3.6 sys_mem_unmap</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#8-3-7-sys-env-alloc"><span class="nav-text">8.3.7 sys_env_alloc</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#8-3-8-sys-set-env-status"><span class="nav-text">8.3.8 sys_set_env_status</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#8-3-9-sys-ipc-recv"><span class="nav-text">8.3.9 sys_ipc_recv</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#8-3-10-sys-ipc-can-send"><span class="nav-text">8.3.10 sys_ipc_can_send</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#8-4-fork"><span class="nav-text">8.4 fork</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#8-4-1-%E4%B8%8D%E6%98%AF%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E5%87%BD%E6%95%B0"><span class="nav-text">8.4.1 不是系统调用函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#8-4-2-duppage"><span class="nav-text">8.4.2 duppage</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#8-4-3-fork"><span class="nav-text">8.4.3 fork</span></a></li></ol></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Thysrael"
      src="/images/avatar2.png">
  <p class="site-author-name" itemprop="name">Thysrael</p>
  <div class="site-description" itemprop="description">Can you hear me ?</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">195</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">31</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">68</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>
  <div class="">
    <a target="_blank" class="social-link" href="/atom.xml" style="color: burlywood;">
      <span class="icon">
        <i class="fa fa-rss"></i>
      </span>
      <span class="label">RSS</span>
    </a>
  </div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/thysrael" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;thysrael" rel="noopener external nofollow noreferrer" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:thysrael@163.com" title="E-Mail → mailto:thysrael@163.com" rel="noopener external nofollow noreferrer" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 2021.12.18 – 
  <span itemprop="copyrightYear">2025</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Thysrael</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
    <span title="Symbols count total">1.3m</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="Reading time total">19:56</span>
</div>

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="Total Visitors">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="Total Views">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  
  <script>
    (function(){
      var canonicalURL, curProtocol;
      //Get the <link> tag
      var x=document.getElementsByTagName("link");
		//Find the last canonical URL
		if(x.length > 0){
			for (i=0;i<x.length;i++){
				if(x[i].rel.toLowerCase() == 'canonical' && x[i].href){
					canonicalURL=x[i].href;
				}
			}
		}
    //Get protocol
	    if (!canonicalURL){
	    	curProtocol = window.location.protocol.split(':')[0];
	    }
	    else{
	    	curProtocol = canonicalURL.split(':')[0];
	    }
      //Get current URL if the canonical URL does not exist
	    if (!canonicalURL) canonicalURL = window.location.href;
	    //Assign script content. Replace current URL with the canonical URL
      !function(){var e=/([http|https]:\/\/[a-zA-Z0-9\_\.]+\.baidu\.com)/gi,r=canonicalURL,t=document.referrer;if(!e.test(r)){var n=(String(curProtocol).toLowerCase() === 'https')?"https://sp0.baidu.com/9_Q4simg2RQJ8t7jm9iCKT-xh_/s.gif":"//api.share.baidu.com/s.gif";t?(n+="?r="+encodeURIComponent(document.referrer),r&&(n+="&l="+r)):r&&(n+="?l="+r);var i=new Image;i.src=n}}(window);})();
  </script>




  
<script src="/js/local-search.js"></script>













  

  
      

<script>
  if (typeof MathJax === 'undefined') {
    window.MathJax = {
      loader: {
        source: {
          '[tex]/amsCd': '[tex]/amscd',
          '[tex]/AMScd': '[tex]/amscd'
        }
      },
      tex: {
        inlineMath: {'[+]': [['$', '$']]},
        tags: 'ams'
      },
      options: {
        renderActions: {
          findScript: [10, doc => {
            document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
              const display = !!node.type.match(/; *mode=display/);
              const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
              const text = document.createTextNode('');
              node.parentNode.replaceChild(text, node);
              math.start = {node: text, delim: '', n: 0};
              math.end = {node: text, delim: '', n: 0};
              doc.math.push(math);
            });
          }, '', false],
          insertedScript: [200, () => {
            document.querySelectorAll('mjx-container').forEach(node => {
              let target = node.parentNode;
              if (target.nodeName.toLowerCase() === 'li') {
                target.parentNode.classList.add('has-jax');
              }
            });
          }, '', false]
        }
      }
    };
    (function () {
      var script = document.createElement('script');
      script.src = '//cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js';
      script.defer = true;
      document.head.appendChild(script);
    })();
  } else {
    MathJax.startup.document.state(0);
    MathJax.texReset();
    MathJax.typeset();
  }
</script>

    

  

</body>
</html>
