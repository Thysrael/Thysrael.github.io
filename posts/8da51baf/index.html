<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-wall.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-wall.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">
  <meta name="baidu-site-verification" content="code-jsxllPgZAX">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="https://fonts.loli.net/css?family=Noto Serif SC:300,300italic,400,400italic,700,700italic|JetBrains Mono:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">
<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">
  <link rel="stylesheet" href="/lib/pace/pace-theme-minimal.min.css">
  <script src="/lib/pace/pace.min.js"></script>

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"thysrael.github.io","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"always","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":false,"style":"flat"},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="[TOC] 一、总论1.1 题目特点虽然这三周哪次作业题目描述都很多，多到经常看不懂的地步。但是应该怎么概括呢？又是一件需要仔细思考的事情。 我们可以看一看我们的要求，给出一个表达式，然后去括号，最后比较的是表达式的长度。如果来看 19 年的题目，那么是给出一个比较简单表达式，然后求导。两年的侧重点不同，比如 19 年的题目，会有提取公因式的操作（因为当不需要去括号的时候，提取公因式会让表达式变得">
<meta property="og:type" content="article">
<meta property="og:title" content="面向对象-表达式">
<meta property="og:url" content="https://thysrael.github.io/posts/8da51baf/index.html">
<meta property="og:site_name" content="钟鼓楼">
<meta property="og:description" content="[TOC] 一、总论1.1 题目特点虽然这三周哪次作业题目描述都很多，多到经常看不懂的地步。但是应该怎么概括呢？又是一件需要仔细思考的事情。 我们可以看一看我们的要求，给出一个表达式，然后去括号，最后比较的是表达式的长度。如果来看 19 年的题目，那么是给出一个比较简单表达式，然后求导。两年的侧重点不同，比如 19 年的题目，会有提取公因式的操作（因为当不需要去括号的时候，提取公因式会让表达式变得">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://thysrael.github.io/posts/8da51baf/image-20220318194222857.png">
<meta property="og:image" content="https://thysrael.github.io/posts/8da51baf/image-20220318212607101.png">
<meta property="og:image" content="https://thysrael.github.io/posts/8da51baf/image-20220318201635765.png">
<meta property="og:image" content="https://thysrael.github.io/posts/8da51baf/竹子.png">
<meta property="og:image" content="https://thysrael.github.io/posts/8da51baf/image-20220318224020113.png">
<meta property="og:image" content="https://thysrael.github.io/posts/8da51baf/image-20220318224054506.png">
<meta property="og:image" content="https://thysrael.github.io/posts/8da51baf/image-20220319191643634.png">
<meta property="og:image" content="https://thysrael.github.io/posts/8da51baf/image-20220324203224255.png">
<meta property="og:image" content="https://thysrael.github.io/posts/8da51baf/image-20220318211808370.png">
<meta property="og:image" content="https://thysrael.github.io/posts/8da51baf/image-20220324203608068.png">
<meta property="og:image" content="https://thysrael.github.io/posts/8da51baf/image-20220319100442309.png">
<meta property="og:image" content="https://thysrael.github.io/posts/8da51baf/image-20220324204151016.png">
<meta property="og:image" content="https://thysrael.github.io/posts/8da51baf/image-20220319110344401.png">
<meta property="og:image" content="https://thysrael.github.io/posts/8da51baf/image-20220319110317982.png">
<meta property="og:image" content="https://thysrael.github.io/posts/8da51baf/image-20220319111157850.png">
<meta property="og:image" content="https://thysrael.github.io/posts/8da51baf/image-20220319111529219.png">
<meta property="article:published_time" content="2022-03-11T11:33:29.000Z">
<meta property="article:modified_time" content="2025-08-15T12:16:49.118Z">
<meta property="article:author" content="Thysrael">
<meta property="article:tag" content="直观理解">
<meta property="article:tag" content="S4课上">
<meta property="article:tag" content="面向对象">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://thysrael.github.io/posts/8da51baf/image-20220318194222857.png">

<link rel="canonical" href="https://thysrael.github.io/posts/8da51baf/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'en'
  };
</script>

  <title>面向对象-表达式 | 钟鼓楼</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

  <!-- Google tag (gtag.js) -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=G-1K2CH25PS7"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());
    gtag('config', 'G-1K2CH25PS7');
  </script>

<style>.github-emoji { position: relative; display: inline-block; width: 1.2em; min-height: 1.2em; overflow: hidden; vertical-align: top; color: transparent; }  .github-emoji > span { position: relative; z-index: 10; }  .github-emoji img, .github-emoji .fancybox { margin: 0 !important; padding: 0 !important; border: none !important; outline: none !important; text-decoration: none !important; user-select: none !important; cursor: auto !important; }  .github-emoji img { height: 1.2em !important; width: 1.2em !important; position: absolute !important; left: 50% !important; top: 50% !important; transform: translate(-50%, -50%) !important; user-select: none !important; cursor: auto !important; } .github-emoji-fallback { color: inherit; } .github-emoji-fallback img { opacity: 0 !important; }</style>
<link rel="alternate" href="/atom.xml" title="钟鼓楼" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>
      <a target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/thysrael" class="github-corner" aria-label="View source on GitHub"><svg width="80" height="80" viewBox="0 0 250 250" style="fill:#151513; color:#fff; position: absolute; top: 0; border: 0; right: 0;" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a><style>.github-corner:hover .octo-arm{animation:octocat-wave 560ms ease-in-out}@keyframes octocat-wave{0%,100%{transform:rotate(0)}20%,60%{transform:rotate(-25deg)}40%,80%{transform:rotate(10deg)}}@media (max-width:500px){.github-corner:hover .octo-arm{animation:none}.github-corner .octo-arm{animation:octocat-wave 560ms ease-in-out}}</style>
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">钟鼓楼</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">钟楼瘦，鼓楼胖</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories<span class="badge">31</span></a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags<span class="badge">70</span></a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives<span class="badge">201</span></a>

  </li>
        <li class="menu-item menu-item-resources">

    <a href="/resource/" rel="section"><i class="fa fa-book fa-fw"></i>Resources</a>

  </li>
        <li class="menu-item menu-item-projects">

    <a href="/projects/" rel="section"><i class="fa fa-briefcase fa-fw"></i>Projects</a>

  </li>
        <li class="menu-item menu-item-friends">

    <a href="/links/" rel="section"><i class="fa fa-link fa-fw"></i>Friends</a>

  </li>
        <li class="menu-item menu-item-roam">

    <a href="/obsidian-quartz/" rel="section"><i class="fa fa-sitemap fa-fw"></i>Roam</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>About</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>Search
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="Searching..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://thysrael.github.io/posts/8da51baf/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar2.png">
      <meta itemprop="name" content="Thysrael">
      <meta itemprop="description" content="Can you hear me?">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="钟鼓楼">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          面向对象-表达式
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-03-11 19:33:29" itemprop="dateCreated datePublished" datetime="2022-03-11T19:33:29+08:00">2022-03-11</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-08-15 20:16:49" itemprop="dateModified" datetime="2025-08-15T20:16:49+08:00">2025-08-15</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/" itemprop="url" rel="index"><span itemprop="name">面向对象</span></a>
                </span>
            </span>

          
            <span class="post-meta-item" title="Views" id="busuanzi_container_page_pv" style="display: none;">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">Views: </span>
              <span id="busuanzi_value_page_pv"></span>
            </span><br>
            <span class="post-meta-item" title="Symbols count in article">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">Symbols count in article: </span>
              <span>17k</span>
            </span>
            <span class="post-meta-item" title="Reading time">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">Reading time &asymp;</span>
              <span>16 mins.</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>[TOC]</p>
<h2 id="一、总论"><a href="#一、总论" class="headerlink" title="一、总论"></a>一、总论</h2><h3 id="1-1-题目特点"><a href="#1-1-题目特点" class="headerlink" title="1.1 题目特点"></a>1.1 题目特点</h3><p>虽然这三周哪次作业题目描述都很多，多到经常看不懂的地步。但是应该怎么概括呢？又是一件需要仔细思考的事情。</p>
<p>我们可以看一看我们的要求，给出一个表达式，然后去括号，最后比较的是表达式的长度。如果来看 19 年的题目，那么是给出一个比较简单表达式，然后求导。两年的侧重点不同，比如 19 年的题目，会有提取公因式的操作（因为当不需要去括号的时候，提取公因式会让表达式变得更短），而 20 年的题目，多了自定义函数，这样给表达式的处理增加了难度。</p>
<p>我不妄加猜测课程组的意图，不过选择这样的题目作为第一单元的内容，肯定是有设计在里面的。在后续的实践中会发现，这个题目呈现一下特征</p>
<h4 id="1-1-1-重结构轻算法"><a href="#1-1-1-重结构轻算法" class="headerlink" title="1.1.1 重结构轻算法"></a>1.1.1 重结构轻算法</h4><p>从数据结构的角度谈，表达式本身就是与树结构和栈结构密切相关，当然也不排除现实所有问题都可以找到合适的数据结构。但是表达式明显的无穷无尽的<strong>递归特性</strong>，还有已经有了数据结构基础的前置引导。很难让人不选择树结构作为解题的关键（栈结构可以看做隐式地建立了一棵树，毕竟具有等价性）。而树结构又绑定了一大堆算法，比如说 DFS，BFS，这种遍历几乎是唯一的算法模型。可以说，只要独立的思考出要采用树结构，那么可以说，架构设计<strong>最关键</strong>的部分已经被解决了。不过课程组已经给了联系单元做明示，我个人解题的时候不是去思考要用一个树结构，而是自己想出了一个算法，然后发现原来是树上的算法，然后暗自震惊一下，继续 debug。</p>
<p>从算法的角度看，我将其分为两个部分，一个是<strong>与树相关的</strong>，一个是<strong>与树无关的</strong>。与树相关的算法可以说很精妙，难以理解，除非意识到这是一个与树相关的算法，才能把树的知识迁移过来辅助理解，比如说递归下降法，如果没有意识到这是一个建树的过程，或者说意识到这是一个 DFS 的话，那么甚至理解他是一个递归算法都困难，因为它<strong>并没有自己调用自己</strong>，而是几个函数在一起<strong>转着圈的调用</strong>。而与树无关的算法都极其简单，而且甚至缺少设计空间，比如加法，其实就是根的节点组对应的表达式里的每一项都写到一起，跟没说一样，再比如乘法，就是系数相乘，指数相加，没有一点优化空间，就好像没有办法去优化 1+1=2 一样。而性能优化采用的算法，大体思路也是极其丑陋的，比如合并同类项就是把相同的项相加，然后删掉；做三角的平方和优化，就是把原来的平方项去掉，乘上一个新的项，其他优化都是如此，都是以遍历和简单数组操作为主。哪怕不谈具体的优化，优化总体的设计感也并不好，我见到的，都是一项优化一项优化的作，然后不断的尝试，最后记录下来一个最好的结果。对于<strong>优化的调度</strong>，就是<strong>重复的试错，大量的试错</strong>的思路，比<strong>枚举</strong>还要朴素。可以说做优化的唯一难点就是<strong>“说服自己，采用这个丑陋的算法，而不是冥思苦想，不得结果。”</strong></p>
<p>当然这么说有失偏颇，比如我看 19 级陈昊哥哥的博客，里面的计时熔断机制，而且对于替换调度的队列结构（这个我到现在都没有实现，应该是有特定的数据结构支持），可以说给人一种极端的暴力美感，是十分优秀的，十分体现算法智慧的。</p>
<h4 id="1-1-2-重架构设计"><a href="#1-1-2-重架构设计" class="headerlink" title="1.1.2 重架构设计"></a>1.1.2 重架构设计</h4><p>我给架构的定义就是解决整个问题的总体设计。比如说我的架构设计就是<strong>“输入 -&gt; 建立在 AST 递归解析 -&gt; AST -&gt; 标准项集合 -&gt; 建立在标准项的优化 -&gt; 输出”</strong>。我现在对于架构的追求就是<strong>尽量解偶联</strong>。解偶联的好处在于，工作就那么多，只要把任务分的更多，每个任务就可以分的更小更简单。</p>
<p>不可否认，得出“重架构设计”的结论应该有我个人的主观因素的影响，因为我的特点就是没有实力做出很漂亮的细节。比方说我身边很多人是没有<strong>标准项</strong>这层结构的，很多人可以采用树结构进行运算和字符串输出，无疑是需要更加强大的算法能力，而我是不具有。我只有把输出的任务从树结构上剥离出来，单独做出一个标准项集合来承担这个工作，才比较符合我的性格。</p>
<p>我在后面希望能够达到的目标是<strong>局部的算法水平不超过整体的架构设计水平</strong>，如果算法水平过高，那么就把这部分算法拿出来单独作为一个架构结构进行设计。像那些只用树可以输出字符串的项目，其实在算法实现的过程中，已经在中间实现了某些类似标准项的结构，只是没有单独做出来而已。我称为这种现象就是<strong>局部算法超过了整体的架构设计</strong>，是我不希望见到的。</p>
<p>之所以有这样的想法，是因为当一个算法的等级提高（从局部升级到整体），那么服务它的数据结构和算法就可以更加精细的操作，比如说这个部分就可以进行面向对象的设计，而不是在一个方法里面腾挪。而就我个人实践而言，确实有这种倾向。</p>
<p>当然并不是不允许强悍的算法设计，架构设计也不应该是靠算法的复杂倒逼的。架构设计最重要的就是贴切，贴切于解空间，贴切于到达解的路径。比如说在实现自定义函数的带入的时候，在树上直接操作的算法难度要高于预处理字符串，但是在树上操作，更加符合题目的思路，所以还是应当采用树上的实现。</p>
<p>前面似乎有埋汰预处理字符串的嫌疑，但是其实如果预处理字符串设计的足够巧妙，比如说蕴含了递归的思想，这何尝又不是一种对树结构压力的分担呢，又何尝不是一种优秀的设计呢？</p>
<h3 id="1-2-架构设计"><a href="#1-2-架构设计" class="headerlink" title="1.2 架构设计"></a>1.2 架构设计</h3><h4 id="1-2-1-整体架构"><a href="#1-2-1-整体架构" class="headerlink" title="1.2.1 整体架构"></a>1.2.1 整体架构</h4><p>整体架构分为如下部分</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>组成</th>
<th>结构</th>
<th>算法</th>
<th>功能</th>
</tr>
</thead>
<tbody>
<tr>
<td>解析</td>
<td>树</td>
<td>递归下降</td>
<td>根据输入字符串建立树</td>
</tr>
<tr>
<td>抽象语法树</td>
<td>树</td>
<td>递归遍历</td>
<td>根据抽象语法树生成标准项集合</td>
</tr>
<tr>
<td>标准项集合</td>
<td>集合</td>
<td>增删改查</td>
<td>包括运算，优化，输出三大功能</td>
</tr>
</tbody>
</table>
</div>
<p>架构图如下：</p>
<p><img src="/posts/8da51baf/image-20220318194222857.png" alt="image-20220318194222857"></p>
<h4 id="1-2-2-类设计"><a href="#1-2-2-类设计" class="headerlink" title="1.2.2 类设计"></a>1.2.2 类设计</h4><p>类设计如下：</p>
<p><img src="/posts/8da51baf/image-20220318212607101.png" alt="image-20220318212607101"></p>
<p>parse 包下有 Lexer，Parser，CustomParser，ExprParser。Lexer 是每个 Parser 必须有的属性。因为解析自定义函数的定义和解析表达式存在一定差异，所以现有 Parser 抽象类，CustomParser，ExprParser 继承了 Parser。</p>
<p>ast 包下所有类都实现了 Node 接口，这是为了 AST 的一致性问题。</p>
<p>poly 包下有 Polynomial，他管理着一个 PolyTerm 的集合。</p>
<h3 id="1-3-设计思想"><a href="#1-3-设计思想" class="headerlink" title="1.3 设计思想"></a>1.3 设计思想</h3><h4 id="1-3-1-齐物观"><a href="#1-3-1-齐物观" class="headerlink" title="1.3.1 齐物观"></a>1.3.1 齐物观</h4><p>都是画眼睛的高光，有人喜欢用橡皮，有人喜欢用电动橡皮，有人喜欢用小刀划，有人喜欢用 12B 去衬，有人喜欢用白颜料去点，有人喜欢直接将眼睛从画面中抹去，有人喜欢将高光画成黑色，有人用摘下雪花作为高光，洁白而且温暖，有人画的不好，却会讲故事。</p>
<p>我只是喜欢那双眼睛，其他皆可齐物。</p>
<p><img src="/posts/8da51baf/image-20220318201635765.png" alt="image-20220318201635765"></p>
<h4 id="1-3-2-代码分类"><a href="#1-3-2-代码分类" class="headerlink" title="1.3.2 代码分类"></a>1.3.2 代码分类</h4><p>仅代表我个人观点，我感觉面向对象对我们的帮助<strong>不在于帮我们解决更难的问题，而是帮助我们解决规模更大的问题</strong>。</p>
<p>就我个人观点，面向对象由一部分是<strong>对代码进行分类</strong>。分类是一种人本位的思想，他默认我们可以<strong>对任何客观事物完成主观上的抽象与分类</strong>。这点上我持观望态度。</p>
<p><img src="/posts/8da51baf/竹子.png" alt="Image result for 竹子"></p>
<p>上图是竹子的花，因为古典植物学坚持以繁殖器官的解剖结构对植物进行分类，而竹子具有开花难，花期短，花的结构存在普遍差异性的特点，成为了分类学的难题。</p>
<hr>
<h2 id="二、标准项集合"><a href="#二、标准项集合" class="headerlink" title="二、标准项集合"></a>二、标准项集合</h2><h3 id="2-1-倒着讲"><a href="#2-1-倒着讲" class="headerlink" title="2.1 倒着讲"></a>2.1 倒着讲</h3><p>虽然算法是<strong>“解析，建树，建集合，输出”</strong>这样一个过程，但是要是从理解的角度，我更愿意倒着讲述。这是因为标准项集合跟现实中的运算更为类似，后面的数据结构也会调用他的方法，所以不然先放到前面来讲。</p>
<h3 id="2-2-格式"><a href="#2-2-格式" class="headerlink" title="2.2 格式"></a>2.2 格式</h3><p>这里说的是标准项的格式，大概是这个样子的</p>
<script type="math/tex; mode=display">
a \times x^b \times \Pi \sin \times \Pi \cos</script><p>也就是说，想要确定一个标准项，就要确定<strong>他的系数、指数、三角函数列表，三角函数又有内容和幂次的属性</strong>。</p>
<p>这里首先要明确，这是一个数学概念，是可以用多种数据结构来实现，不同的数据结构是为了需求的不同而设计的，比方说我的标准项设计，就用到了 HashMap 的结构。但是其实最容易想到的是用 ArrayList 来存。我这么做是服务于乘法。</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">private</span> <span class="token class-name">BigInteger</span> coefficient<span class="token punctuation">;</span>
<span class="token keyword">private</span> <span class="token class-name">BigInteger</span> exponent<span class="token punctuation">;</span>
<span class="token keyword">private</span> <span class="token class-name">HashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Polynomial</span><span class="token punctuation">,</span> <span class="token class-name">BigInteger</span><span class="token punctuation">&gt;</span></span> sin<span class="token punctuation">;</span>
<span class="token keyword">private</span> <span class="token class-name">HashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Polynomial</span><span class="token punctuation">,</span> <span class="token class-name">BigInteger</span><span class="token punctuation">&gt;</span></span> cos<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>标准项集合描述的就是一堆标准项，其形式如下</p>
<script type="math/tex; mode=display">
a_1 \times x^{b_1} \times \Pi^1 \sin \times \Pi^1 \cos + a_2 \times x^{b_2} \times \Pi^2 \sin \times \Pi^2 \cos + ...</script><p>我个人这里偷懒了，直接采用的是 ArrayList，</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">private</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">PolyTerm</span><span class="token punctuation">&gt;</span></span> polyTerms<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>但是如果细致考量，就会发现 ArrayList 赋予了每个标准项<strong>顺序</strong>的概念，而对于标准项来说，朴素的看，每一项应该是等价的，即满足加法交换律，所以无脑的用 ArrayList 不是一个很好的设计。</p>
<p>对此我想了两个比较好的优化结构，一个是 HashSet，它模糊了顺序的概念，这样比较两个项的时候，就可以不用管顺序了，也就是说，满足了加法交换律。对于 ArrayList 而言</p>
<script type="math/tex; mode=display">
x + x^2 \neq x^2 + x</script><p>但是 HashSet 没有这个问题。</p>
<p>此外就是对标准项实现 <code>Comparable</code> 接口，这样就可以利用 ArrayList 的排序功能，完成相同标准项集合的比对。</p>
<h3 id="2-3-方法"><a href="#2-3-方法" class="headerlink" title="2.3 方法"></a>2.3 方法</h3><p>我觉得这里的方法设计消耗脑力最少，而且可以设计出实现各种功能的方法。这些方法还可以进行组合，生成更加复杂的方法。给人的感觉就是在定义数学的运算空间一样。这里仅介绍与运算相关的方法：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>方法</th>
<th>解释</th>
</tr>
</thead>
<tbody>
<tr>
<td>add</td>
<td>描述两个多项式相加的结果</td>
</tr>
<tr>
<td>multi</td>
<td>描述两个多项式相乘的结果</td>
</tr>
<tr>
<td>isZero</td>
<td>判断当前表达式的值是不是 0</td>
</tr>
<tr>
<td>negative</td>
<td>描述一个多项式的负值</td>
</tr>
</tbody>
</table>
</div>
<p>剩下的方法在优化部分介绍。</p>
<hr>
<h2 id="三、拙劣的抽象语法树"><a href="#三、拙劣的抽象语法树" class="headerlink" title="三、拙劣的抽象语法树"></a>三、拙劣的抽象语法树</h2><h3 id="3-1-树结构"><a href="#3-1-树结构" class="headerlink" title="3.1 树结构"></a>3.1 树结构</h3><p>还是先明晰一点，就是<strong>形式化表述</strong>与<strong>树结构</strong>并不那么等价，在形式化表述里，对于树的强调并不多，甚至给人一种“Expression 是 Term 的集合，Term 是 Factor 的集合”的感觉，这种感觉很不利与我发现树。而且有的因子，并不对应一个叶节点，比如 <code>x**2</code> 其实他对应的是这样的一种结构</p>
<p><img src="/posts/8da51baf/image-20220318224020113.png" alt="image-20220318224020113"></p>
<p>而不是一个节点，像这样</p>
<p><img src="/posts/8da51baf/image-20220318224054506.png" alt="image-20220318224054506"></p>
<p>也就是说，这棵树，更像是数据结构里的<strong>表达式树</strong>，里面是没有 Expression，Term，Factor 概念的    </p>
<p>其次，是这棵树的来源问题，这棵树是我从网上看了好多代码以后找出来我比较喜欢的一款，应该是叫做抽象语法树（Abstract syntax tree，AST）。但是我看人家都是解决那种特别复杂的问题的，而且我看见那个还是个二叉树，而我这个应该是<strong>多叉有序树</strong>，所以不确定是不是，就放这里，有兴趣再了解吧。</p>
<h3 id="3-2-举例"><a href="#3-2-举例" class="headerlink" title="3.2 举例"></a>3.2 举例</h3><p>还是举一个例子，来明确一下这棵树的样子，这是表达式</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token function">sin</span><span class="token punctuation">(</span>x<span class="token operator">*</span><span class="token operator">*</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token operator">*</span><span class="token operator">*</span><span class="token number">2</span><span class="token operator">*</span>x<span class="token operator">-</span><span class="token function">f</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span>x<span class="token operator">*</span><span class="token operator">*</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token punctuation">(</span>x<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">*</span><span class="token operator">*</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token operator">+</span><span class="token punctuation">(</span>x<span class="token operator">*</span><span class="token operator">*</span><span class="token number">2</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">*</span><span class="token function">sum</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span>i<span class="token operator">*</span><span class="token operator">*</span><span class="token number">2</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>转换成表达式树，就是如下结构</p>
<p><img src="/posts/8da51baf/image-20220319191643634.png" alt="image-20220319191643634"></p>
<p>这里面，每一个方框就是一个节点，也就是一个类，这些类均实现了 <code>Node</code> 接口，方便管理。（除了幂次，我没有写成图那样，因为那样有点繁琐，标准项不适合幂次运算）。</p>
<h3 id="3-3-Node"><a href="#3-3-Node" class="headerlink" title="3.3 Node"></a>3.3 Node</h3><p><img src="/posts/8da51baf/image-20220324203224255.png" alt="image-20220324203224255"></p>
<p>我们构建这棵树的目的就是为让它通过递归，生成我们的标准项集合，所以每个节点其实完成的是一件什么事情呢？是他的所有孩子都已经标准项集合化了，它需要把孩子们的标准项集合经过一定的处理，生成一个标准项集合，并返回给其父节点。那么要经过怎样的处理呢？这其实是由两部分组成，即</p>
<ul>
<li>运算</li>
<li>运算法则</li>
</ul>
<p>运算部分是在标准项集合中实现的，比如加法，乘法。而运算法则是节点的信息，比如说 <code>Add</code> 的运算法则就是对所有的孩子进行加法运算。这个是比较直观的，稍微复杂一点的是 <code>Power</code> ，他的法则是将底数（他的一个孩子节点）进行乘法运算指数次。代码如下</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token class-name">Polynomial</span> <span class="token function">toPoly</span><span class="token punctuation">(</span><span class="token class-name">HashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">,</span> <span class="token class-name">Node</span><span class="token punctuation">&gt;</span></span> arguments<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>

    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">long</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> exponent<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        polynomial <span class="token operator">=</span> polynomial<span class="token punctuation">.</span><span class="token function">multi</span><span class="token punctuation">(</span>factor<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> polynomial<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="3-4-自定义函数"><a href="#3-4-自定义函数" class="headerlink" title="3.4 自定义函数"></a>3.4 自定义函数</h3><p>自定义函数看着挺难的，但是其实很简单，只需要意识到，自定义函数也是一种<strong>运算节点</strong>，只不过它的运算法则更为复杂，是以一棵表达式树定义的（就是我们用 CustomPaser 解析出来的树，往下看就知道了）。我们践行这种运算法则的方式就是遍历这棵树，并且在合适的位置将形参换成实参即可。因为不让放代码，所以不能说的太清楚。</p>
<hr>
<h2 id="四、解析"><a href="#四、解析" class="headerlink" title="四、解析"></a>四、解析</h2><h3 id="4-1-形式化表述与递归下降法"><a href="#4-1-形式化表述与递归下降法" class="headerlink" title="4.1 形式化表述与递归下降法"></a>4.1 形式化表述与递归下降法</h3><p>我个人最大的一个体会，就是<strong>形式化表述</strong>与<strong>递归下降法</strong>是对应的，甚至在数学上是等价的。但是指导书里的形式化表述还不是最终形式，这里安利一篇博文（找不到了，大概就是这样，具体的忘了，肯定不严谨），他在最开始的时候将形式化表述做了一个转化，我觉得更有 DFS 的感觉了。</p>
<script type="math/tex; mode=display">
Expr -> Term \quad| \quad  Term\quad Expr \\
Term -> Factor\quad| \quad Factor\quad Term\\
Factor -> factor1 \quad| \quad factor2 \quad | \quad factor3</script><h3 id="4-2-递归调用"><a href="#4-2-递归调用" class="headerlink" title="4.2 递归调用"></a>4.2 递归调用</h3><p>因为递归下降很难看出来，因为不是传统的递归，即<strong>自己调用自己</strong>，而是一种循环的调用。我们以第三次作业中 parse 的逻辑来谈，可知如图：</p>
<p><img src="/posts/8da51baf/image-20220318211808370.png" alt="image-20220318211808370"></p>
<p>可以看出，所谓的递归调用，就是 <code>parseExpr() -&gt; parseTerm() -&gt; parseFactor -&gt; parseExpr</code> 的一个过程。可以发现是一个循环。</p>
<h3 id="4-3-掩盖细节"><a href="#4-3-掩盖细节" class="headerlink" title="4.3 掩盖细节"></a>4.3 掩盖细节</h3><p>如果观察我的主代码就会发现，在解析部分其实只出现了一个 <code>ExprParser</code> 类，如下</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token class-name">ExprInput</span> scanner <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ExprInput</span><span class="token punctuation">(</span><span class="token class-name">ExprInputMode<span class="token punctuation">.</span>NormalMode</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> n <span class="token operator">=</span> scanner<span class="token punctuation">.</span><span class="token function">getCount</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token class-name">ExprParser</span> parser <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ExprParser</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        parser<span class="token punctuation">.</span><span class="token function">addFunction</span><span class="token punctuation">(</span>scanner<span class="token punctuation">.</span><span class="token function">readLine</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    parser<span class="token punctuation">.</span><span class="token function">setLexer</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Lexer</span><span class="token punctuation">(</span>scanner<span class="token punctuation">.</span><span class="token function">readLine</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token class-name">Node</span> tree <span class="token operator">=</span> parser<span class="token punctuation">.</span><span class="token function">parseExpression</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token class-name">Polynomial</span> polynomial <span class="token operator">=</span> tree<span class="token punctuation">.</span><span class="token function">toPoly</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>polynomial<span class="token punctuation">.</span><span class="token function">selectShortest</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>可以看到，没有出现 <code>Lexer,CustomParser</code> 类，这是我觉得设计比较好的地方，用户程序员其实没必要掌握 <code>Lexer,CustomParser</code>  的知识，其实只要给他呈现一个解析器就好了，<code>Lexer,CustomParser</code> 出现在 <code>ExprParser</code> 的内部，我觉得是一个很好的封装处理。</p>
<h3 id="4-4-类设计"><a href="#4-4-类设计" class="headerlink" title="4.4 类设计"></a>4.4 类设计</h3><p><img src="/posts/8da51baf/image-20220324203608068.png" alt="image-20220324203608068"></p>
<h4 id="4-3-1-Lexer"><a href="#4-3-1-Lexer" class="headerlink" title="4.3.1 Lexer"></a>4.3.1 Lexer</h4><p>译作词法分析器，其实好像没那么玄，就是把一个一个的字符拆成有意义的语义元素，比如将 <code>sin(x**2)**3</code> 就顺序拆成 <code>sin</code>，<code>(</code>，<code>x</code>，<code>**</code>，<code>2</code>，<code>)</code>，<code>**</code>，<code>3</code> 即可。</p>
<p>对于实现的方法</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>方法</th>
<th>功能</th>
</tr>
</thead>
<tbody>
<tr>
<td>next</td>
<td>Lexer 移动指向下一个元素</td>
</tr>
<tr>
<td>peek</td>
<td>返回 Lexer 当前指向的元素</td>
</tr>
</tbody>
</table>
</div>
<p>对了，我个人觉得如果把 Lexer 作为 Parse 的一个内部类，封装性会更好。</p>
<h4 id="4-3-2-Parser"><a href="#4-3-2-Parser" class="headerlink" title="4.3.2 Parser"></a>4.3.2 Parser</h4><p>Parser 只有一个属性，就是 lexer，可以说如果不是 lexer，parser 的大部分方法其实写成静态更好。这里就涉及到一个关于面向对象的<strong>朴素思考</strong>，即一个类必须封装一些属性，然后再封装一些以这个属性为参数的函数，不然就没有面向对象的意义。</p>
<p>作为一个抽象类，其中其实实现了大部分方法，在这里展示一下递归下降的写法，对于 parseExpr，parseTerm，有</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">Term</span> <span class="token function">parseTerm</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
	factors<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>parseFactor<span class="token punctuation">)</span>
	<span class="token keyword">while</span><span class="token punctuation">(</span>有分隔符<span class="token punctuation">)</span>
	<span class="token punctuation">{</span>
		factors<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>parseFactor<span class="token punctuation">)</span>
	<span class="token punctuation">}</span>
	
	<span class="token keyword">return</span> term<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>而对于 parseFactor，是交由子类实现的，但是大体的思路是一致的，都是根据当前语义元素进行判断，选择出具体的 factor 类型，然后调用具体的方法。</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">Factor</span> <span class="token function">parseFactor</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span>语义元素是表达式<span class="token punctuation">)</span>
	<span class="token punctuation">{</span>
		factor <span class="token operator">=</span> <span class="token function">parseExpressionFactor</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>语义元素是数字<span class="token punctuation">)</span>
	<span class="token punctuation">{</span>
		factor <span class="token operator">=</span> <span class="token function">parseNumFactor</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>语义元素是幂函数<span class="token punctuation">)</span>
	<span class="token punctuation">{</span>
		factor <span class="token operator">=</span> <span class="token function">parsePowerFuncFactor</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span>
	<span class="token punctuation">{</span>
		<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
	<span class="token punctuation">}</span>
	
	<span class="token keyword">return</span> factor<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="4-3-3-CustomParser"><a href="#4-3-3-CustomParser" class="headerlink" title="4.3.3 CustomParser"></a>4.3.3 CustomParser</h4><p> CustomParser 是一个专门解析自定义函数的定义的 Parser，相较于普通的 Parser，他多了三个属性，而这三个属性刚好代表他功能的特殊性。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>属性</th>
<th>解释</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>HashMap&lt;String, Integer&gt; argPosTable</code></td>
<td>完成一个由形参名到形参位置的映射，比如说 f(y,z,x)，则有 <code>y -&gt; 1, z -&gt; 2, x -&gt; 3</code></td>
</tr>
<tr>
<td><code>String name</code></td>
<td>该自定义函数的名字，比如 <code>f,g,h</code></td>
</tr>
<tr>
<td><code>Node expr</code></td>
<td>该自定义函数的表达式，是一种树结构</td>
</tr>
</tbody>
</table>
</div>
<p>当我们用 CustomParser 解析一条定义的时候，他需要告诉我们，这个函数的名字是什么，这个函数的表达式是什么，而且这个表达式已经经过了处理，在变量部分已经变成了形参的位置，而不是形参名（这是因为形参 <code>y</code> 可以出现在第一个位置，也可以出现在第二、三个位置，所以没办法确立替换规则）。我们需要在 Variable 节点里包含的信息是“第一个形参，第二个形参……”，而不是“x，y……”。</p>
<h4 id="4-3-4-ExprParser"><a href="#4-3-4-ExprParser" class="headerlink" title="4.3.4 ExprParser"></a>4.3.4 ExprParser</h4><p>这是用来解析待化简的表达式的类，可以说是在解析部分最重要的类。经过它的解析以后，我们会生成我们需要的树结构。</p>
<p>这个最大的容易出 bug 就是 lexer 的移动问题，真的超容易出 bug，放一个解析 sum 的给大家感受一下</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">private</span> <span class="token class-name">Node</span> <span class="token function">parseSumFactor</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token comment">// 此时指向 sum</span>
    <span class="token function">getLexer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 此时指向 (</span>
    <span class="token function">getLexer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 此时指向 i</span>
    <span class="token function">getLexer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 此时指向 ,</span>
    <span class="token function">getLexer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 此时指向 begin</span>
    <span class="token keyword">final</span> <span class="token class-name">String</span> begin <span class="token operator">=</span> <span class="token function">getNum</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 此时指向 ,</span>
    <span class="token function">getLexer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 此时指向 end</span>
    <span class="token keyword">final</span> <span class="token class-name">String</span> end <span class="token operator">=</span> <span class="token function">getNum</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 此时指向 ,</span>
    <span class="token function">getLexer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token class-name">Node</span> factor <span class="token operator">=</span> <span class="token function">parseFactor</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 此时指向 )</span>
    <span class="token function">getLexer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Sum</span><span class="token punctuation">(</span>begin<span class="token punctuation">,</span> end<span class="token punctuation">,</span> factor<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>然后这个方法就 bug 了，de 了好久。</p>
<hr>
<h2 id="五、优化"><a href="#五、优化" class="headerlink" title="五、优化"></a>五、优化</h2><h3 id="5-1-合并同类项"><a href="#5-1-合并同类项" class="headerlink" title="5.1 合并同类项"></a>5.1 合并同类项</h3><p>这里我做了两版，一般是普通的合并同类项，采用的方法就是判断两个标准项的幂次，三角是不是相同，写作下面</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">return</span> exponent<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>other<span class="token punctuation">.</span>exponent<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> sin<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>other<span class="token punctuation">.</span>sin<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> cos<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>other<span class="token punctuation">.</span>cos<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>第二版就更加灵活一些，考虑到这样的情形</p>
<script type="math/tex; mode=display">
\sin(x-1) = -\sin(1-x)</script><p>所以放宽了比较的条件，每次进行比较的时候，先比较一次 <code>x-1</code> 和 <code>x-1</code> ，在比较一次 <code>x-1</code> 和 <code>-x+1</code> 。这样就可以达到合并更多的同类项的目的。这是用 <code>negative</code> 方法实现的。</p>
<p>需要注意的是，不是每次变换，都需要修改系数的值，<code>sin</code> 的奇数次才需要修改，<code>cos</code> 永远不需要修改</p>
<script type="math/tex; mode=display">
\sin(x-1) = -\sin(1-x)\\
\sin^2(x-1) = \sin^2(1-x)</script><h3 id="5-2-去零"><a href="#5-2-去零" class="headerlink" title="5.2 去零"></a>5.2 去零</h3><p>这里也是写了两版，第一版是直接判断系数为不为 0，如果为 0，那么就认为这个标准项为 0。这里刚学了 lambda 表达式，就献了个丑。（不是这节的重点）</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">polyTerms<span class="token punctuation">.</span><span class="token function">removeIf</span><span class="token punctuation">(</span>e <span class="token operator">-&gt;</span> e<span class="token punctuation">.</span><span class="token function">getCoefficient</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span><span class="token class-name">BigInteger</span><span class="token punctuation">.</span>ZERO<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>lambda 表达式分为三个部分，即：</p>
<ul>
<li>参数，一般用 <code>()</code> 括起</li>
<li>连接符，即 <code>-&gt;</code></li>
<li>函数体，可以是一个表达式或者一个语句块。如果是一个表达式，表达式的值会被作为返回值返回；如果是语句块，需要用return语句指定返回值。</li>
</ul>
<p>第二版去零考虑到了这些情况</p>
<script type="math/tex; mode=display">
\sin(0),\sin((x-x))</script><p>所以是这样实现的：</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">isZero</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token comment">// 系数为 0，则整个项为 0</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>coefficient<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span><span class="token class-name">BigInteger</span><span class="token punctuation">.</span>ZERO<span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">else</span>
    <span class="token punctuation">{</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">Polynomial</span> p <span class="token operator">:</span> sin<span class="token punctuation">.</span><span class="token function">keySet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
        <span class="token punctuation">{</span>
            <span class="token comment">// sin 的因子为 0，则整个项为 0</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>p<span class="token punctuation">.</span><span class="token function">isZero</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
            <span class="token punctuation">{</span>
                <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>

        <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="5-3-平方和"><a href="#5-3-平方和" class="headerlink" title="5.3 平方和"></a>5.3 平方和</h3><p>这个看上去挺难的，但是怎么说呢，其实只要硬着头皮写，是可以写出来的。我个人经验，如果在标准项层面实现不了，那么就把他转换成标准项集合看看能不能实现，效果十分好，这是因为标准项集合拥有的方法更多，<strong>更接近数学定义</strong>。算法流程如下：</p>
<p><img src="/posts/8da51baf/image-20220319100442309.png" alt="image-20220319100442309"></p>
<p>此外，还需要注意的是，从 Map 去掉某一项的操作容易抛出异常（第十个点 RE ），具体原因和解决办法这里有：</p>
<p><a target="_blank" rel="noopener external nofollow noreferrer" href="https://blog.csdn.net/weixin_40807247/article/details/88413347">https://blog.csdn.net/weixin_40807247/article/details/88413347</a></p>
<h3 id="5-4-诱导公式"><a href="#5-4-诱导公式" class="headerlink" title="5.4 诱导公式"></a>5.4 诱导公式</h3><p>不是特别复杂的诱导公式，就是很普通的</p>
<script type="math/tex; mode=display">
\sin(x) = -\sin(x)\\
\cos(x) = \cos(-x)</script><p>这个就更简单了，可以在标准项层面就完成，不需要升级到标准相机集合的层面。</p>
<h3 id="5-5-优化调度"><a href="#5-5-优化调度" class="headerlink" title="5.5 优化调度"></a>5.5 优化调度</h3><p>如果实现了很多个优化，那么就会意识到，不同的优化的执行顺序，是会对优化结果产生影响的，比如（没有遵循形式化表述）</p>
<script type="math/tex; mode=display">
2\sin^2(x)\cos(x)+2\cos^3(x)</script><p>如果先执行平方和化简</p>
<script type="math/tex; mode=display">
2\cos(x)</script><p>可如果先使用正弦二倍角化简</p>
<script type="math/tex; mode=display">
\sin(2x)\sin(x)+2\cos^3(x)</script><p>会发现结果由差异。所以怎么确定先采用哪个形式去化简呢？我反正没有实现这个事情，摆烂了。不过陈昊哥哥说可以用<strong>队列</strong>做，我昨晚又想了想，似乎这个具有后无效性？<strong>可以动态规划吗</strong>？甚至还可以加上时间的限制条件。反正我摆了，就不想了。</p>
<h3 id="5-6-输出优化"><a href="#5-6-输出优化" class="headerlink" title="5.6 输出优化"></a>5.6 输出优化</h3><p>标准项集合除了实现计算方法之外，最重要的就是实现 <code>toString</code> ,对于这里，有如下优化</p>
<ul>
<li>把正项移到前面：1-x 优于 -x+1</li>
<li>系数为 1 或者 -1 的时候不输出系数：x 优于 1*x</li>
<li>指数为 0 的时候，不输出 x：1 优于 x**0</li>
<li>指数为 1 的时候，不输出指数：x 优于 x**1</li>
<li>项有负号的时候，不输出 +：-x 优于 +-x</li>
</ul>
<hr>
<h2 id="六、评测机与-bug"><a href="#六、评测机与-bug" class="headerlink" title="六、评测机与 bug"></a>六、评测机与 bug</h2><h3 id="6-1-组成"><a href="#6-1-组成" class="headerlink" title="6.1 组成"></a>6.1 组成</h3><p>评测机由三部分组成：</p>
<ul>
<li>数据生成器：用于生成测试数据</li>
<li>自动调用机：可以进行自动化的测试</li>
<li>检验机：可以用于检验正确性</li>
</ul>
<h3 id="6-2-数据生成器"><a href="#6-2-数据生成器" class="headerlink" title="6.2 数据生成器"></a>6.2 数据生成器</h3><h4 id="6-2-1-原理"><a href="#6-2-1-原理" class="headerlink" title="6.2.1 原理"></a>6.2.1 原理</h4><p>到了 6.3 终于可以贴合完整的命题空间了。其实生成数据的过程可以看做是<strong>解析的逆过程</strong>，基本上解析有几个函数，生成就有一个函数，这里放下 UML 图</p>
<p><img src="/posts/8da51baf/image-20220324204151016.png" alt="image-20220324204151016"></p>
<p>可以发现，基本跟 Parser 上一模一样。同样也是递归的创建。</p>
<h4 id="6-2-2-复杂性控制"><a href="#6-2-2-复杂性控制" class="headerlink" title="6.2.2 复杂性控制"></a>6.2.2 复杂性控制</h4><p>可以从两个方向控制：</p>
<ul>
<li>项数和因子数，可以作为参数传入，控制循环的次数</li>
<li>递归深度，也可以作为参数传入，当调用某些方法的时候（比如创建表达式因子），就让深度减 1，当深度为 0 的时候，就限制一些构造的方法，比如禁止构造表达式因子</li>
</ul>
<h4 id="6-2-3-体验"><a href="#6-2-3-体验" class="headerlink" title="6.2.3 体验"></a>6.2.3 体验</h4><p>我在第二次作业第一次写数据生成器，体验很不好，虽然领悟到了<strong>递归构造就是最贴切的构造方法</strong>，但是具体实现的时候，依然 bug 连连，最后还得重构，然后为了 debug，又给评测机写了一个评测机。</p>
<p>而且我意识到数据生成器只是评测机的一个组件，其他组件虽然对于不同的项目复用性会更高，但是依然是很体现技术的。而我当时年少轻狂，现在也是。总之吃了很多亏，干了很多费力不讨好的事情。</p>
<h3 id="6-3-bug-分析"><a href="#6-3-bug-分析" class="headerlink" title="6.3 bug 分析"></a>6.3 bug 分析</h3><h4 id="6-3-1-BigInteger"><a href="#6-3-1-BigInteger" class="headerlink" title="6.3.1 BigInteger"></a>6.3.1 BigInteger</h4><p>我这三次作业，强测都是满分，自己被 hack 了一次。出现的 bug 在 sum 的起始和终止都是 <code>long</code> 类型，而不是 <code>BigInteger</code>。我当时写的时候只考虑到因为长度限制，所以 begin 和 end 之间的差值不会超过 long，所以就图省事没有用 <code>BigInteger</code> ，但是没有想到起始和终止都是可以特别大的。</p>
<h4 id="6-3-2-hack-策略"><a href="#6-3-2-hack-策略" class="headerlink" title="6.3.2 hack 策略"></a>6.3.2 hack 策略</h4><p>虽然写评测机的时候满心都以为可以用评测机发现别人的 bug，后来发现能 hack 到别人的数据都是手动构造的，尤其是还有一个构造是卡 TLE 的。我分析这是因为我写评测机的功力还不够，没有办法构造出特别刁钻的数据。还是以后多多参与，多多锻炼为好。</p>
<hr>
<h2 id="七、补充知识"><a href="#七、补充知识" class="headerlink" title="七、补充知识"></a>七、补充知识</h2><h3 id="7-1-对象处理流"><a href="#7-1-对象处理流" class="headerlink" title="7.1 对象处理流"></a>7.1 对象处理流</h3><p>总之就是深浅克隆问题，简单的定义就不说了。我做的时候一直在思考必要性，因为我第一次作业就没有用到 clone，所以影响我的是，我不知道如果浅克隆的会发生啥问题，反正大家都说有问题，我也不知道有啥问题。可能是因为我树上操作少，没有嫁接操作？总之就是因为没出过这个方面的bug，所以很难理解到底哪里有问题。第二次作业本来也不打算用 clone 的，但是想了想，还是改成有 clone 的交了。但是真的不明白会在哪里出问题，这可能跟我对于算法的需求不高有关。</p>
<p>但是还是担心的学了序列化和反序列化的知识，并用在了 clone 上，序列化和反序列化属于是<strong>对象处理流</strong>里的概念：</p>
<ul>
<li>序列化就是保存数据的时候，保存数据的值和数据类型</li>
<li>反序列化就是在恢复数据时，恢复数据的值和数据类型</li>
<li>需要让某个对象支持序列化机制，则必须让其类是可序列化的。为了让某个类是可序列化的，该类必须实现如下两个接口之一（他的每个属性也必须实现这两个接口之一）<ul>
<li>Serializable</li>
<li>Externalizable</li>
</ul>
</li>
</ul>
<p>我们用序列化反序列化实现 clone 的原理就是我们相当于是把对象保存到了一个文件中，然后立刻又从文件中把这个对象读了出来，此时这个新的对象就是一个深度 clone 的副本了。</p>
<p>这是标准写法</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">SerialCloneable</span> <span class="token keyword">implements</span> <span class="token class-name">Cloneable</span><span class="token punctuation">,</span><span class="token class-name">Serializable</span>  
<span class="token punctuation">{</span>  
    <span class="token keyword">public</span> <span class="token class-name">Object</span> <span class="token function">clone</span><span class="token punctuation">(</span><span class="token punctuation">)</span>  
    <span class="token punctuation">{</span>  
        <span class="token keyword">try</span>  
        <span class="token punctuation">{</span>  
            <span class="token comment">//save the object to a byte array  </span>
            <span class="token class-name">ByteArrayOutputStream</span> bout <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ByteArrayOutputStream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  
            <span class="token class-name">ObjectOutputStream</span> out <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ObjectOutputStream</span><span class="token punctuation">(</span>bout<span class="token punctuation">)</span><span class="token punctuation">;</span>  
            out<span class="token punctuation">.</span><span class="token function">writeObject</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  
            out<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  

            <span class="token comment">//read a clone of the object from the byte array  </span>
            <span class="token class-name">ByteArrayInputStream</span> bin <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ByteArrayInputStream</span><span class="token punctuation">(</span>bout<span class="token punctuation">.</span><span class="token function">toByteArray</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  
            <span class="token class-name">ObjectInputStream</span> in <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ObjectInputStream</span><span class="token punctuation">(</span>bin<span class="token punctuation">)</span><span class="token punctuation">;</span>  
            <span class="token class-name">Object</span> result <span class="token operator">=</span> in<span class="token punctuation">.</span><span class="token function">readObject</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  
            in<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  

            <span class="token keyword">return</span> result<span class="token punctuation">;</span>  
        <span class="token punctuation">}</span>
        <span class="token keyword">catch</span><span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span>  
        <span class="token punctuation">{</span>  
            <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span>    
        <span class="token punctuation">}</span>  
    <span class="token punctuation">}</span>  

<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>我的写法，以标准项为例：</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token class-name">PolyTerm</span> <span class="token function">clone</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">try</span>
    <span class="token punctuation">{</span>
        <span class="token comment">//save the object to a byte array</span>
        <span class="token class-name">ByteArrayOutputStream</span> bout <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ByteArrayOutputStream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">ObjectOutputStream</span> out <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ObjectOutputStream</span><span class="token punctuation">(</span>bout<span class="token punctuation">)</span><span class="token punctuation">;</span>
        out<span class="token punctuation">.</span><span class="token function">writeObject</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        out<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token comment">//read a clone of the object from the byte array</span>
        <span class="token class-name">ByteArrayInputStream</span> bin <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ByteArrayInputStream</span><span class="token punctuation">(</span>bout<span class="token punctuation">.</span><span class="token function">toByteArray</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">ObjectInputStream</span> in <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ObjectInputStream</span><span class="token punctuation">(</span>bin<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">Object</span> result <span class="token operator">=</span> in<span class="token punctuation">.</span><span class="token function">readObject</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        in<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token class-name">PolyTerm</span><span class="token punctuation">)</span> result<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="7-2-不可变类"><a href="#7-2-不可变类" class="headerlink" title="7.2 不可变类"></a>7.2 不可变类</h3><p>看了讨论区赵姑娘的文章，感觉颇受启发，可能我的设计更偏向于不可变对象设计。赵姑娘主要讲了怎么实现不可变设计，我想对为啥不可变类可以解决 clone 问题。</p>
<p>这是我们容易出现的场景</p>
<p><img src="/posts/8da51baf/image-20220319110344401.png" alt="image-20220319110344401"></p>
<p>我看见这个场景就天生反感，因为这东西不是我想要的，我想要的是这个东西</p>
<p><img src="/posts/8da51baf/image-20220319110317982.png" alt="image-20220319110317982"></p>
<p>但是其实第一种图其实没啥不好的，只要不修改 10 的值，那么第一种就够了，就好像犯不着为每个人都配一个小便池，小便池能用就行了。我们对于厕所的问题，其实有人上完厕所不冲小便池，对应这里就是修改了 10 的值，只有这个时候我们会说，要是有独立卫浴就好了，这就对应了第二幅图的情况。</p>
<p>当我们使用了不可变对象的时候，就好像规定了人使用完小便池以后必须冲水，不然就枪毙他（保持对象的不可变性）。只要定下这个规矩，人们共享小便池的意愿就会高一些。</p>
<p>这是第一点，也就是说，不可变类减少了人们去 clone 对象的需求。就好像没人在有绝对干净的公厕时还会花钱修建个人卫浴（仅是比喻）。而另一点，如果真的有修改需求怎么办，我们如果用 clone 思想去做，是这样的</p>
<p><img src="/posts/8da51baf/image-20220319111157850.png" alt="image-20220319111157850"></p>
<p>我们先 clone 出一个原对象，然后把值给修改了，就好像先仿造公厕里的小便池造一个小便池安自己家里，然后在给这个小便池镶上钻石来满足自己的品味需求。这时是需要 clone 的，因为如果不克隆，所有的人第二天上厕所的时候，都会发现自己居然会使用是一个镶钻石的小便池。</p>
<p>那么这种<strong>修改</strong>的请求不可变对象是如何处理的呢？如图</p>
<p><img src="/posts/8da51baf/image-20220319111529219.png" alt="image-20220319111529219"></p>
<p>他直接新建了一个对象，然后对其进行了设置。就好像是现在开了一个新的公厕，这个公厕里的小便池是镶钻石的，现在这个高雅的人改去这个公厕了。相当于是将原来的“<strong>克隆并在克隆件上修改</strong>”，改成了“<strong>模仿原对象不需要修改的部分，结合需要修改的部分，重新建立一个新的对象</strong>”。</p>
<p>以上两种处理很好的满足了需求。</p>
<hr>
<h2 id="八、量化分析"><a href="#八、量化分析" class="headerlink" title="八、量化分析"></a>八、量化分析</h2><h3 id="8-1-基础知识"><a href="#8-1-基础知识" class="headerlink" title="8.1 基础知识"></a>8.1 基础知识</h3><p>方法的衡量指标：</p>
<ul>
<li>CogC（Cognitive complexity）认知复杂度：衡量一个方法的控制流程有多困难去理解。具有高认知复杂度的方法将难以维护。sonar要求复杂度要在15以下。计算的大致思路是统计方法中控制流程语句的个数</li>
<li>ev(G)（essential cyclomatic complexity）：方法的基本圈复杂度，衡量程序非结构化程度的。</li>
<li>iv(G) （Design complexity）：设计复杂度</li>
<li>v(G)（cyclomatic complexity）：方法的圈复杂度，衡量判断模块的复杂度。数值越高说明独立路径越多，测试完备的难度越大。</li>
</ul>
<p>类的衡量指标：</p>
<ul>
<li>OCavg（Average opearation complexity）：平均操作复杂度</li>
<li>OCmax（Maximum operation complexity）：最大操作复杂度</li>
<li>WMC（Weighted method complexity）：加权方法复杂度</li>
</ul>
<h3 id="8-2-ast-包"><a href="#8-2-ast-包" class="headerlink" title="8.2 ast 包"></a>8.2 ast 包</h3><p>方法分析</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>method</th>
<th>CogC</th>
<th>ev(G)</th>
<th>iv(G)</th>
<th>v(G)</th>
</tr>
</thead>
<tbody>
<tr>
<td>ast.Add.addTerm(Node)</td>
<td>0.0</td>
<td>1.0</td>
<td>1.0</td>
<td>1.0</td>
</tr>
<tr>
<td>ast.Add.toPoly(HashMap)</td>
<td>1.0</td>
<td>1.0</td>
<td>2.0</td>
<td>2.0</td>
</tr>
<tr>
<td>ast.Custom.Custom(Node, HashMap)</td>
<td>0.0</td>
<td>1.0</td>
<td>1.0</td>
<td>1.0</td>
</tr>
<tr>
<td>ast.Custom.toPoly(HashMap)</td>
<td>0.0</td>
<td>1.0</td>
<td>1.0</td>
<td>1.0</td>
</tr>
<tr>
<td>ast.Multi.addFactor(Node)</td>
<td>0.0</td>
<td>1.0</td>
<td>1.0</td>
<td>1.0</td>
</tr>
<tr>
<td>ast.Multi.toPoly(HashMap)</td>
<td>1.0</td>
<td>1.0</td>
<td>2.0</td>
<td>2.0</td>
</tr>
<tr>
<td>ast.Num.Num(String)</td>
<td>0.0</td>
<td>1.0</td>
<td>1.0</td>
<td>1.0</td>
</tr>
<tr>
<td>ast.Num.toPoly(HashMap)</td>
<td>0.0</td>
<td>1.0</td>
<td>1.0</td>
<td>1.0</td>
</tr>
<tr>
<td>ast.Power.Power(Node, String)</td>
<td>0.0</td>
<td>1.0</td>
<td>1.0</td>
<td>1.0</td>
</tr>
<tr>
<td>ast.Power.toPoly(HashMap)</td>
<td>0.0</td>
<td>1.0</td>
<td>1.0</td>
<td>1.0</td>
</tr>
<tr>
<td>ast.Sum.Sum(String, String, Node)</td>
<td>0.0</td>
<td>1.0</td>
<td>1.0</td>
<td>1.0</td>
</tr>
<tr>
<td>ast.Sum.toPoly(HashMap)</td>
<td>1.0</td>
<td>1.0</td>
<td>2.0</td>
<td>2.0</td>
</tr>
<tr>
<td>ast.Triangle.toPoly(HashMap)</td>
<td>8.0</td>
<td>1.0</td>
<td>5.0</td>
<td>5.0</td>
</tr>
<tr>
<td>ast.Triangle.Triangle(String, Node)</td>
<td>3.0</td>
<td>1.0</td>
<td>3.0</td>
<td>3.0</td>
</tr>
<tr>
<td>ast.Variable.toPoly(HashMap)</td>
<td>2.0</td>
<td>1.0</td>
<td>2.0</td>
<td>2.0</td>
</tr>
<tr>
<td>ast.Variable.Variable(int)</td>
<td>1.0</td>
<td>1.0</td>
<td>1.0</td>
<td>5.0</td>
</tr>
<tr>
<td>ast.VarType.add()</td>
<td>1.0</td>
<td>5.0</td>
<td>1.0</td>
<td>5.0</td>
</tr>
</tbody>
</table>
</div>
<p>分析：</p>
<p>可以看到所有的方法都很规矩，除了跟 <code>Triangle</code> 相关的方法。因为 <code>Triangle</code> 包括 <code>Cos</code> 和 <code>Sin</code> 两种，所以导致各种方法都需要写两个分支，然后相应的复杂度就上去了。之所以这样设计，是因为单独开设两个三角函数类，会出现大量的重复代码。修改起来也十分麻烦。如果再建立一个抽象类来提取公共代码，在利用多态来实现区别，应该是更好的设计思路。</p>
<p>类分析</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>class</th>
<th>OCavg</th>
<th>OCmax</th>
<th>WMC</th>
</tr>
</thead>
<tbody>
<tr>
<td>ast.Add</td>
<td>2.6666666666666665</td>
<td>5.0</td>
<td>8.0</td>
</tr>
<tr>
<td>ast.Custom</td>
<td>1.3333333333333333</td>
<td>2.0</td>
<td>4.0</td>
</tr>
<tr>
<td>ast.Multi</td>
<td>3.0</td>
<td>6.0</td>
<td>9.0</td>
</tr>
<tr>
<td>ast.Num</td>
<td>1.3333333333333333</td>
<td>2.0</td>
<td>4.0</td>
</tr>
<tr>
<td>ast.Power</td>
<td>1.6666666666666667</td>
<td>3.0</td>
<td>5.0</td>
</tr>
<tr>
<td>ast.Sum</td>
<td>1.3333333333333333</td>
<td>2.0</td>
<td>4.0</td>
</tr>
<tr>
<td>ast.Triangle</td>
<td>4.0</td>
<td>5.0</td>
<td>8.0</td>
</tr>
<tr>
<td>ast.TriType</td>
<td></td>
<td></td>
<td>0.0</td>
</tr>
<tr>
<td>ast.Variable</td>
<td>4.333333333333333</td>
<td>6.0</td>
<td>13.0</td>
</tr>
<tr>
<td>ast.VarType</td>
<td>6.0</td>
<td>6.0</td>
<td>6.0</td>
</tr>
</tbody>
</table>
</div>
<p>分析：</p>
<p>这个复杂度有些高啊，但是如果把这个里面的 <code>toString</code> 方法去掉，那么复杂度会大大减少。这里面其实 <code>toString</code> 方法没有用，就是我写出来用来调试的。所以其实这个复杂度还在可以接受的范围内。这里的分析也告诉我，不要把多功能集中在一个类上，而应该按照姜姐姐在研讨课上提供的思路<strong>单一职责</strong>。否则复杂度就会升高。</p>
<h3 id="8-3-parser-包"><a href="#8-3-parser-包" class="headerlink" title="8.3 parser 包"></a>8.3 parser 包</h3><p>方法分析</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>method</th>
<th>CogC</th>
<th>ev(G)</th>
<th>iv(G)</th>
<th>v(G)</th>
</tr>
</thead>
<tbody>
<tr>
<td>parser.CustomParser.CustomParser(String)</td>
<td>0.0</td>
<td>1.0</td>
<td>1.0</td>
<td>1.0</td>
</tr>
<tr>
<td>parser.CustomParser.getExpr()</td>
<td>0.0</td>
<td>1.0</td>
<td>1.0</td>
<td>1.0</td>
</tr>
<tr>
<td>parser.CustomParser.getName()</td>
<td>0.0</td>
<td>1.0</td>
<td>1.0</td>
<td>1.0</td>
</tr>
<tr>
<td>parser.CustomParser.parseCustomFunc()</td>
<td>1.0</td>
<td>1.0</td>
<td>2.0</td>
<td>2.0</td>
</tr>
<tr>
<td>parser.CustomParser.parseFactor()</td>
<td>7.0</td>
<td>1.0</td>
<td>8.0</td>
<td>8.0</td>
</tr>
<tr>
<td>parser.CustomParser.parseVariable()</td>
<td>0.0</td>
<td>1.0</td>
<td>1.0</td>
<td>1.0</td>
</tr>
<tr>
<td>parser.ExprParser.addFunction(String)</td>
<td>0.0</td>
<td>1.0</td>
<td>1.0</td>
<td>1.0</td>
</tr>
<tr>
<td>parser.ExprParser.parseCustomFuncFactor()</td>
<td>1.0</td>
<td>1.0</td>
<td>2.0</td>
<td>2.0</td>
</tr>
<tr>
<td>parser.ExprParser.parseFactor()</td>
<td>10.0</td>
<td>1.0</td>
<td>11.0</td>
<td>11.0</td>
</tr>
<tr>
<td>parser.ExprParser.parseSumFactor()</td>
<td>0.0</td>
<td>1.0</td>
<td>1.0</td>
<td>1.0</td>
</tr>
<tr>
<td>parser.ExprParser.parseVariable()</td>
<td>3.0</td>
<td>1.0</td>
<td>2.0</td>
<td>3.0</td>
</tr>
<tr>
<td>parser.Lexer.getNumber()</td>
<td>2.0</td>
<td>1.0</td>
<td>3.0</td>
<td>3.0</td>
</tr>
<tr>
<td>parser.Lexer.Lexer(String)</td>
<td>0.0</td>
<td>1.0</td>
<td>1.0</td>
<td>1.0</td>
</tr>
<tr>
<td>parser.Lexer.next()</td>
<td>9.0</td>
<td>2.0</td>
<td>5.0</td>
<td>7.0</td>
</tr>
<tr>
<td>parser.Lexer.peek()</td>
<td>0.0</td>
<td>1.0</td>
<td>1.0</td>
<td>1.0</td>
</tr>
<tr>
<td>parser.Parser.getLexer()</td>
<td>0.0</td>
<td>1.0</td>
<td>1.0</td>
<td>1.0</td>
</tr>
<tr>
<td>parser.Parser.getNum()</td>
<td>2.0</td>
<td>1.0</td>
<td>3.0</td>
<td>3.0</td>
</tr>
<tr>
<td>parser.Parser.isInteger(String)</td>
<td>0.0</td>
<td>1.0</td>
<td>1.0</td>
<td>1.0</td>
</tr>
<tr>
<td>parser.Parser.parseExpression()</td>
<td>2.0</td>
<td>1.0</td>
<td>3.0</td>
<td>3.0</td>
</tr>
<tr>
<td>parser.Parser.parseExprFactor()</td>
<td>0.0</td>
<td>1.0</td>
<td>1.0</td>
<td>1.0</td>
</tr>
<tr>
<td>parser.Parser.parseFuncPowerFactor()</td>
<td>0.0</td>
<td>1.0</td>
<td>1.0</td>
<td>1.0</td>
</tr>
<tr>
<td>parser.Parser.parseNP()</td>
<td>2.0</td>
<td>1.0</td>
<td>3.0</td>
<td>3.0</td>
</tr>
<tr>
<td>parser.Parser.parsePower(Node)</td>
<td>2.0</td>
<td>1.0</td>
<td>2.0</td>
<td>2.0</td>
</tr>
<tr>
<td>parser.Parser.parseTerm(int)</td>
<td>1.0</td>
<td>1.0</td>
<td>2.0</td>
<td>2.0</td>
</tr>
<tr>
<td>parser.Parser.parseTriangle(String)</td>
<td>0.0</td>
<td>1.0</td>
<td>1.0</td>
<td>1.0</td>
</tr>
<tr>
<td>parser.Parser.setLexer(Lexer)</td>
<td>0.0</td>
<td>1.0</td>
<td>1.0</td>
<td>1.0</td>
</tr>
</tbody>
</table>
</div>
<p>分析：</p>
<p>这里的设计就很好，各种方法的复杂度都很低，这是因为将大量的方法的内部再次进行拆解，拆解成了私有方法，这样大大降低了方法的复杂度。这个设计的技巧在之后的调试中也要用到。</p>
<p>类分析</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>class</th>
<th>OCavg</th>
<th>OCmax</th>
<th>WMC</th>
</tr>
</thead>
<tbody>
<tr>
<td>parser.CustomParser</td>
<td>1.8333333333333333</td>
<td>5.0</td>
<td>11.0</td>
</tr>
<tr>
<td>parser.ExprParser</td>
<td>2.8</td>
<td>7.0</td>
<td>14.0</td>
</tr>
<tr>
<td>parser.Lexer</td>
<td>2.75</td>
<td>7.0</td>
<td>11.0</td>
</tr>
<tr>
<td>parser.Parser</td>
<td>1.5454545454545454</td>
<td>3.0</td>
<td>17.0</td>
</tr>
</tbody>
</table>
</div>
<p>分析：</p>
<p>这些类的复杂度都比之前 ast 包的类的复杂度高一些。这应该是是这些类的功能更多的原因。但是用私有方法的方式，可以方便的定义bug。</p>
<h3 id="8-4-poly-包"><a href="#8-4-poly-包" class="headerlink" title="8.4 poly 包"></a>8.4 poly 包</h3><div class="table-container">
<table>
<thead>
<tr>
<th>method</th>
<th>CogC</th>
<th>ev(G)</th>
<th>iv(G)</th>
<th>v(G)</th>
</tr>
</thead>
<tbody>
<tr>
<td>poly.Polynomial.multi(Polynomial)</td>
<td>3.0</td>
<td>1.0</td>
<td>3.0</td>
<td>3.0</td>
</tr>
<tr>
<td>poly.Polynomial.negative()</td>
<td>1.0</td>
<td>1.0</td>
<td>2.0</td>
<td>2.0</td>
</tr>
<tr>
<td>poly.Polynomial.Polynomial()</td>
<td>0.0</td>
<td>1.0</td>
<td>1.0</td>
<td>1.0</td>
</tr>
<tr>
<td>poly.Polynomial.power(long, Polynomial)</td>
<td>1.0</td>
<td>1.0</td>
<td>2.0</td>
<td>2.0</td>
</tr>
<tr>
<td>poly.Polynomial.removeIfZero()</td>
<td>0.0</td>
<td>1.0</td>
<td>1.0</td>
<td>1.0</td>
</tr>
<tr>
<td>poly.Polynomial.selectShortest()</td>
<td>4.0</td>
<td>1.0</td>
<td>4.0</td>
<td>5.0</td>
</tr>
<tr>
<td>poly.Polynomial.simplify()</td>
<td>0.0</td>
<td>1.0</td>
<td>1.0</td>
<td>1.0</td>
</tr>
<tr>
<td>poly.Polynomial.squareTrans(TriType)</td>
<td>1.0</td>
<td>1.0</td>
<td>2.0</td>
<td>2.0</td>
</tr>
<tr>
<td>poly.Polynomial.toString()</td>
<td>7.0</td>
<td>1.0</td>
<td>4.0</td>
<td>5.0</td>
</tr>
<tr>
<td>poly.Polynomial.traverse(Polynomial, TriType)</td>
<td>2.0</td>
<td>1.0</td>
<td>2.0</td>
<td>2.0</td>
</tr>
<tr>
<td>poly.PolyTerm.clone()</td>
<td>1.0</td>
<td>1.0</td>
<td>1.0</td>
<td>2.0</td>
</tr>
<tr>
<td>poly.PolyTerm.equals(Object)</td>
<td>4.0</td>
<td>3.0</td>
<td>5.0</td>
<td>7.0</td>
</tr>
<tr>
<td>poly.PolyTerm.getCoefficient()</td>
<td>0.0</td>
<td>1.0</td>
<td>1.0</td>
<td>1.0</td>
</tr>
<tr>
<td>poly.PolyTerm.hashCode()</td>
<td>0.0</td>
<td>1.0</td>
<td>1.0</td>
<td>1.0</td>
</tr>
<tr>
<td>poly.PolyTerm.isFactor()</td>
<td>6.0</td>
<td>4.0</td>
<td>7.0</td>
<td>10.0</td>
</tr>
<tr>
<td>poly.PolyTerm.isSameType(PolyTerm)</td>
<td>3.0</td>
<td>2.0</td>
<td>4.0</td>
<td>4.0</td>
</tr>
<tr>
<td>poly.PolyTerm.isSameTypeRough(PolyTerm)</td>
<td>24.0</td>
<td>10.0</td>
<td>14.0</td>
<td>19.0</td>
</tr>
<tr>
<td>poly.PolyTerm.isZero()</td>
<td>7.0</td>
<td>4.0</td>
<td>3.0</td>
<td>4.0</td>
</tr>
<tr>
<td>poly.PolyTerm.multi(PolyTerm)</td>
<td>13.0</td>
<td>1.0</td>
<td>8.0</td>
<td>8.0</td>
</tr>
<tr>
<td>poly.PolyTerm.PolyTerm(BigInteger, BigInteger)</td>
<td>0.0</td>
<td>1.0</td>
<td>1.0</td>
<td>1.0</td>
</tr>
<tr>
<td>poly.PolyTerm.setCoefficient(BigInteger)</td>
<td>0.0</td>
<td>1.0</td>
<td>1.0</td>
<td>1.0</td>
</tr>
<tr>
<td>poly.PolyTerm.setCos(HashMap)</td>
<td>0.0</td>
<td>1.0</td>
<td>1.0</td>
<td>1.0</td>
</tr>
<tr>
<td>poly.PolyTerm.setSin(HashMap)</td>
<td>0.0</td>
<td>1.0</td>
<td>1.0</td>
<td>1.0</td>
</tr>
<tr>
<td>poly.PolyTerm.squareTrans(TriType)</td>
<td>6.0</td>
<td>1.0</td>
<td>4.0</td>
<td>5.0</td>
</tr>
<tr>
<td>poly.PolyTerm.toPoly()</td>
<td>0.0</td>
<td>1.0</td>
<td>1.0</td>
<td>1.0</td>
</tr>
<tr>
<td>poly.PolyTerm.toString()</td>
<td>17.0</td>
<td>2.0</td>
<td>8.0</td>
<td>8.0</td>
</tr>
<tr>
<td>poly.PolyTerm.triangleToString(HashMap, String)</td>
<td>11.0</td>
<td>1.0</td>
<td>5.0</td>
<td>5.0</td>
</tr>
</tbody>
</table>
</div>
<p>分析：</p>
<p>这个包里的方法的复杂度都偏高，这是因为这里的方法不是优化，就是输出，为了性能分，大量的引入了各种特判条件，导致了复杂度提高。这里其实也揭示了一个道理，就是优化性能有可能导致正确性的牺牲。或者说<strong>复杂就容易失误</strong>。这样的话，简洁优秀的算法，就是一个很好的设计目标。</p>
<p>类分析</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>class</th>
<th>OCavg</th>
<th>OCmax</th>
<th>WMC</th>
</tr>
</thead>
<tbody>
<tr>
<td>poly.Polynomial</td>
<td>2.3333333333333335</td>
<td>5.0</td>
<td>49.0</td>
</tr>
<tr>
<td>poly.PolyTerm</td>
<td>3.4705882352941178</td>
<td>12.0</td>
<td>59.0</td>
</tr>
</tbody>
</table>
</div>
<p>分析：</p>
<p>感觉是因为方法的调用次数，导致了加权偏高。我曾经考虑过单独做出一个包来分担优化的功能。但是设计能力有限，遗漏了这个设计。</p>
<hr>
<h2 id="九、迭代"><a href="#九、迭代" class="headerlink" title="九、迭代"></a>九、迭代</h2><p>其实怎么说呢，虽然我觉得我第一次架构就可以应付三次的作业。但是我最为骄傲的就是，每次我都是重构的，虽然这些重构并不是对架构的调整，但是我尽量在重构的过程中将代码写的更加简洁优雅。</p>
<p>在第二次作业中，我把原来的 <code>Expression</code>、<code>Term</code>、<code>Factor</code> 类都去掉，换成了更为抽象的 <code>Node</code>。这个重构使架构中的树结构更加明显。</p>
<p>在第三次作业中，我把 <code>Parser</code> 作为一个抽象类，这样减少了重复代码量，而且更加贯彻面向对象的思想。</p>
<hr>
<h2 id="十、鸣谢"><a href="#十、鸣谢" class="headerlink" title="十、鸣谢"></a>十、鸣谢</h2><p>首先最最应该感谢的人就是李寻欢，可以说真的真的对我的帮助很大。我第一单元的所有设计，都是对李寻欢设计思想拙劣的模仿。似乎给我画出了我这种实力的破学生的设计的极限。每每我恍然大悟，就发现李寻欢早已在那里等着我。</p>
<p>不仅是设计方面，李寻欢设计中透露的那种粗粝的美感，那种果决与英气，都是我不具有的，可以说李寻欢在我进入 OO 这门课初，塑造了我对于项目的审美。</p>
<p>其次感谢郭嵩阳，在我深陷困难的时候及时帮忙，感谢至极。</p>
<p>最后感谢我的其他朋友们，他们或多或少在我的实践中为我提供了帮助。感谢之至。</p>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/%E7%9B%B4%E8%A7%82%E7%90%86%E8%A7%A3/" rel="tag"><i class="fa fa-tag"></i> 直观理解</a>
              <a href="/tags/S4%E8%AF%BE%E4%B8%8A/" rel="tag"><i class="fa fa-tag"></i> S4课上</a>
              <a href="/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/" rel="tag"><i class="fa fa-tag"></i> 面向对象</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/posts/94fef56a/" rel="prev" title="Linux-编译工具">
      <i class="fa fa-chevron-left"></i> Linux-编译工具
    </a></div>
      <div class="post-nav-item">
    <a href="/posts/dc1e00db/" rel="next" title="操作系统-系统启动">
      操作系统-系统启动 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          
<script src="https://utteranc.es/client.js"
        repo="Thysrael/blog-comment"
        issue-term="title"
        theme="github-light"
        crossorigin="anonymous"
        async>
</script>

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%80%E3%80%81%E6%80%BB%E8%AE%BA"><span class="nav-text">一、总论</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-1-%E9%A2%98%E7%9B%AE%E7%89%B9%E7%82%B9"><span class="nav-text">1.1 题目特点</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-1-1-%E9%87%8D%E7%BB%93%E6%9E%84%E8%BD%BB%E7%AE%97%E6%B3%95"><span class="nav-text">1.1.1 重结构轻算法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-1-2-%E9%87%8D%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1"><span class="nav-text">1.1.2 重架构设计</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-2-%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1"><span class="nav-text">1.2 架构设计</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-2-1-%E6%95%B4%E4%BD%93%E6%9E%B6%E6%9E%84"><span class="nav-text">1.2.1 整体架构</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-2-2-%E7%B1%BB%E8%AE%BE%E8%AE%A1"><span class="nav-text">1.2.2 类设计</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-3-%E8%AE%BE%E8%AE%A1%E6%80%9D%E6%83%B3"><span class="nav-text">1.3 设计思想</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-3-1-%E9%BD%90%E7%89%A9%E8%A7%82"><span class="nav-text">1.3.1 齐物观</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-3-2-%E4%BB%A3%E7%A0%81%E5%88%86%E7%B1%BB"><span class="nav-text">1.3.2 代码分类</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%8C%E3%80%81%E6%A0%87%E5%87%86%E9%A1%B9%E9%9B%86%E5%90%88"><span class="nav-text">二、标准项集合</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2-1-%E5%80%92%E7%9D%80%E8%AE%B2"><span class="nav-text">2.1 倒着讲</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-2-%E6%A0%BC%E5%BC%8F"><span class="nav-text">2.2 格式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-3-%E6%96%B9%E6%B3%95"><span class="nav-text">2.3 方法</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%89%E3%80%81%E6%8B%99%E5%8A%A3%E7%9A%84%E6%8A%BD%E8%B1%A1%E8%AF%AD%E6%B3%95%E6%A0%91"><span class="nav-text">三、拙劣的抽象语法树</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#3-1-%E6%A0%91%E7%BB%93%E6%9E%84"><span class="nav-text">3.1 树结构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-2-%E4%B8%BE%E4%BE%8B"><span class="nav-text">3.2 举例</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-3-Node"><span class="nav-text">3.3 Node</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-4-%E8%87%AA%E5%AE%9A%E4%B9%89%E5%87%BD%E6%95%B0"><span class="nav-text">3.4 自定义函数</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9B%9B%E3%80%81%E8%A7%A3%E6%9E%90"><span class="nav-text">四、解析</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#4-1-%E5%BD%A2%E5%BC%8F%E5%8C%96%E8%A1%A8%E8%BF%B0%E4%B8%8E%E9%80%92%E5%BD%92%E4%B8%8B%E9%99%8D%E6%B3%95"><span class="nav-text">4.1 形式化表述与递归下降法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-2-%E9%80%92%E5%BD%92%E8%B0%83%E7%94%A8"><span class="nav-text">4.2 递归调用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-3-%E6%8E%A9%E7%9B%96%E7%BB%86%E8%8A%82"><span class="nav-text">4.3 掩盖细节</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-4-%E7%B1%BB%E8%AE%BE%E8%AE%A1"><span class="nav-text">4.4 类设计</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#4-3-1-Lexer"><span class="nav-text">4.3.1 Lexer</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-3-2-Parser"><span class="nav-text">4.3.2 Parser</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-3-3-CustomParser"><span class="nav-text">4.3.3 CustomParser</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-3-4-ExprParser"><span class="nav-text">4.3.4 ExprParser</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%94%E3%80%81%E4%BC%98%E5%8C%96"><span class="nav-text">五、优化</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#5-1-%E5%90%88%E5%B9%B6%E5%90%8C%E7%B1%BB%E9%A1%B9"><span class="nav-text">5.1 合并同类项</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-2-%E5%8E%BB%E9%9B%B6"><span class="nav-text">5.2 去零</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-3-%E5%B9%B3%E6%96%B9%E5%92%8C"><span class="nav-text">5.3 平方和</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-4-%E8%AF%B1%E5%AF%BC%E5%85%AC%E5%BC%8F"><span class="nav-text">5.4 诱导公式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-5-%E4%BC%98%E5%8C%96%E8%B0%83%E5%BA%A6"><span class="nav-text">5.5 优化调度</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-6-%E8%BE%93%E5%87%BA%E4%BC%98%E5%8C%96"><span class="nav-text">5.6 输出优化</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%85%AD%E3%80%81%E8%AF%84%E6%B5%8B%E6%9C%BA%E4%B8%8E-bug"><span class="nav-text">六、评测机与 bug</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#6-1-%E7%BB%84%E6%88%90"><span class="nav-text">6.1 组成</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-2-%E6%95%B0%E6%8D%AE%E7%94%9F%E6%88%90%E5%99%A8"><span class="nav-text">6.2 数据生成器</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#6-2-1-%E5%8E%9F%E7%90%86"><span class="nav-text">6.2.1 原理</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6-2-2-%E5%A4%8D%E6%9D%82%E6%80%A7%E6%8E%A7%E5%88%B6"><span class="nav-text">6.2.2 复杂性控制</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6-2-3-%E4%BD%93%E9%AA%8C"><span class="nav-text">6.2.3 体验</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-3-bug-%E5%88%86%E6%9E%90"><span class="nav-text">6.3 bug 分析</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#6-3-1-BigInteger"><span class="nav-text">6.3.1 BigInteger</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6-3-2-hack-%E7%AD%96%E7%95%A5"><span class="nav-text">6.3.2 hack 策略</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%83%E3%80%81%E8%A1%A5%E5%85%85%E7%9F%A5%E8%AF%86"><span class="nav-text">七、补充知识</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#7-1-%E5%AF%B9%E8%B1%A1%E5%A4%84%E7%90%86%E6%B5%81"><span class="nav-text">7.1 对象处理流</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-2-%E4%B8%8D%E5%8F%AF%E5%8F%98%E7%B1%BB"><span class="nav-text">7.2 不可变类</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%85%AB%E3%80%81%E9%87%8F%E5%8C%96%E5%88%86%E6%9E%90"><span class="nav-text">八、量化分析</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#8-1-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86"><span class="nav-text">8.1 基础知识</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#8-2-ast-%E5%8C%85"><span class="nav-text">8.2 ast 包</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#8-3-parser-%E5%8C%85"><span class="nav-text">8.3 parser 包</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#8-4-poly-%E5%8C%85"><span class="nav-text">8.4 poly 包</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B9%9D%E3%80%81%E8%BF%AD%E4%BB%A3"><span class="nav-text">九、迭代</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8D%81%E3%80%81%E9%B8%A3%E8%B0%A2"><span class="nav-text">十、鸣谢</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Thysrael"
      src="/images/avatar2.png">
  <p class="site-author-name" itemprop="name">Thysrael</p>
  <div class="site-description" itemprop="description">Can you hear me?</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">201</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">31</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">70</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>
  <div class="">
    <a target="_blank" class="social-link" href="/atom.xml" style="color: burlywood;">
      <span class="icon">
        <i class="fa fa-rss"></i>
      </span>
      <span class="label">RSS</span>
    </a>
  </div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/thysrael" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;thysrael" rel="noopener external nofollow noreferrer" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:thysrael@163.com" title="E-Mail → mailto:thysrael@163.com" rel="noopener external nofollow noreferrer" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 2021.12.18 – 
  <span itemprop="copyrightYear">2026</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Thysrael</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
    <span title="Symbols count total">1.4m</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="Reading time total">20:28</span>
</div>

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="Total Visitors">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="Total Views">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  
  <script>
    (function(){
      var canonicalURL, curProtocol;
      //Get the <link> tag
      var x=document.getElementsByTagName("link");
		//Find the last canonical URL
		if(x.length > 0){
			for (i=0;i<x.length;i++){
				if(x[i].rel.toLowerCase() == 'canonical' && x[i].href){
					canonicalURL=x[i].href;
				}
			}
		}
    //Get protocol
	    if (!canonicalURL){
	    	curProtocol = window.location.protocol.split(':')[0];
	    }
	    else{
	    	curProtocol = canonicalURL.split(':')[0];
	    }
      //Get current URL if the canonical URL does not exist
	    if (!canonicalURL) canonicalURL = window.location.href;
	    //Assign script content. Replace current URL with the canonical URL
      !function(){var e=/([http|https]:\/\/[a-zA-Z0-9\_\.]+\.baidu\.com)/gi,r=canonicalURL,t=document.referrer;if(!e.test(r)){var n=(String(curProtocol).toLowerCase() === 'https')?"https://sp0.baidu.com/9_Q4simg2RQJ8t7jm9iCKT-xh_/s.gif":"//api.share.baidu.com/s.gif";t?(n+="?r="+encodeURIComponent(document.referrer),r&&(n+="&l="+r)):r&&(n+="?l="+r);var i=new Image;i.src=n}}(window);})();
  </script>




  
<script src="/js/local-search.js"></script>













  

  
      

<script>
  if (typeof MathJax === 'undefined') {
    window.MathJax = {
      loader: {
        source: {
          '[tex]/amsCd': '[tex]/amscd',
          '[tex]/AMScd': '[tex]/amscd'
        }
      },
      tex: {
        inlineMath: {'[+]': [['$', '$']]},
        tags: 'ams',
        macros: {
          unicodeInt: ['\\mathop{\\vcenter{\\mathchoice{\\huge\\unicode{#1}}{\\unicode{#1}}{\\unicode{#1}}{\\unicode{#1}}}}\\nolimits', 1],
          oiint: '\\unicodeInt{x222F}',
          oiiint: '\\unicodeInt{x2230}'
        }
      },
      options: {
        renderActions: {
          findScript: [10, doc => {
            document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
              const display = !!node.type.match(/; *mode=display/);
              const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
              const text = document.createTextNode('');
              node.parentNode.replaceChild(text, node);
              math.start = {node: text, delim: '', n: 0};
              math.end = {node: text, delim: '', n: 0};
              doc.math.push(math);
            });
          }, '', false],
          insertedScript: [200, () => {
            document.querySelectorAll('mjx-container').forEach(node => {
              let target = node.parentNode;
              if (target.nodeName.toLowerCase() === 'li') {
                target.parentNode.classList.add('has-jax');
              }
            });
          }, '', false]
        }
      }
    };
    (function () {
      var script = document.createElement('script');
      script.src = '//cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js';
      script.defer = true;
      document.head.appendChild(script);
    })();
  } else {
    MathJax.startup.document.state(0);
    MathJax.texReset();
    MathJax.typeset();
  }
</script>

    

  

</body>
</html>
